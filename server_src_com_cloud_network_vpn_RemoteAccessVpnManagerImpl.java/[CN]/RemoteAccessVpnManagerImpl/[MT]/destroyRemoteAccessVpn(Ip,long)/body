{
  long userId=UserContext.current().getCallerUserId();
  Account caller=UserContext.current().getCaller();
  RemoteAccessVpnVO vpn=_remoteAccessVpnDao.findById(ip);
  if (vpn == null) {
    s_logger.debug("vpn does not exists " + ip);
    return;
  }
  _accountMgr.checkAccess(caller,vpn);
  Account owner=_accountDao.findById(vpn.getAccountId());
  Network network=_networkMgr.getNetwork(vpn.getNetworkId());
  EventUtils.saveStartedEvent(userId,owner.getId(),EventTypes.EVENT_REMOTE_ACCESS_VPN_DESTROY,"Deleting Remote Access VPN for account: " + owner.getAccountName() + " in "+ ip,startEventId);
  vpn.setState(RemoteAccessVpn.State.Removed);
  List<? extends RemoteAccessVpnElement> elements=_networkMgr.getRemoteAccessVpnElements();
  boolean success=false;
  try {
    for (    RemoteAccessVpnElement element : elements) {
      if (element.stop(network,vpn)) {
        success=true;
        break;
      }
    }
  }
  finally {
    if (!success) {
      EventUtils.saveEvent(userId,owner.getId(),EventVO.LEVEL_ERROR,EventTypes.EVENT_REMOTE_ACCESS_VPN_DESTROY,"Unable to delete Remote Access VPN ",owner.getAccountName());
    }
 else {
      Transaction txn=Transaction.currentTxn();
      txn.start();
      _remoteAccessVpnDao.remove(ip);
      if (!_rulesMgr.releasePorts(ip,NetUtils.UDP_PROTO,Purpose.Vpn,NetUtils.VPN_L2TP_PORT,NetUtils.VPN_NATT_PORT,NetUtils.VPN_PORT)) {
        s_logger.warn("Unable to release the three vpn ports from the firewall rules");
        txn.rollback();
      }
 else {
        EventUtils.saveEvent(userId,owner.getId(),EventTypes.EVENT_REMOTE_ACCESS_VPN_DESTROY,"Deleted Remote Access VPN for account: " + owner.getAccountName());
      }
      txn.commit();
    }
  }
}

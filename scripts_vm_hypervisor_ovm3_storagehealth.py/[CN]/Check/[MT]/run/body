def run(self, timeout):

    def target():
        filesystems = []
        filesystems.extend(self.nfsoutput())
        for fs in filesystems:
            if self.file:
                if (self.check == False):
                    self.writehb(('%s/%s' % (fs, file)))
                else:
                    res = self.readhb(('%s/%s' % (fs, file)))
                    delay = (time.time() - float(res))
                    if ((delay < timeout) and (self.ok == None)):
                        self.logger.info(('%s/%s is ok %s with %s' % (fs, file, timeout, delay)))
                        self.ok = True
                    elif (delay > timeout):
                        self.logger.warning(('%s/%s exceeded timeout %s with %s' % (fs, file, timeout, delay)))
                        self.ok = False
                    self.results[fs] = [self.ok, delay]
        epoch = time.time()
        if self.cmd:
            self.logger.debug(('Executing: %s' % cmd))
            self.process = subprocess.Popen(self.cmd, shell=True)
            self.process.communicate()
            self.logger.info(('Executed: %s in %s' % (cmd, (time.time() - epoch))))
    thread = threading.Thread(target=target)
    thread.start()
    thread.join(self.timeout)
    if (thread.isAlive() and (self.check == False)):
        self.logger.critical(('Critical: thread timeout; %s' % timeout))
        if self.failcmd:
            self.logger.critical(('Critical: executing; %s' % failcmd))
            p = subprocess.Popen(failcmd, shell=True, stdout=subprocess.PIPE)

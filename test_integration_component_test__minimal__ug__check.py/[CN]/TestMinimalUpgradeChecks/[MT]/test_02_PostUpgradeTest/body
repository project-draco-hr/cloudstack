@attr(tags=['postupgrade'])
def test_02_PostUpgradeTest(self):
    ' Test case no : Verification of CCP Objects Post Upgrade\n        '
    try:
        with open(TestMinimalUpgradeChecks.services['ug_stp_obj_file'], 'rb') as fp:
            self.pullobjects = json.load(fp)
        self.service_offering_h1 = ServiceOffering(self.pullobjects['service_offering_h1'])
        self.service_offering_h2 = ServiceOffering(self.pullobjects['service_offering_h2'])
        self.disk_offering_5gb = DiskOffering(self.pullobjects['disk_offering_5gb'])
        self.disk_offering_15gb = DiskOffering(self.pullobjects['disk_offering_15gb'])
        self.firstaccount = Account(self.pullobjects['firstaccount'])
        self.template = Template(self.pullobjects['template'])
        self.iso = Iso(self.pullobjects['iso'])
        self.firstvm = VirtualMachine(self.pullobjects['firstvm'], TestMinimalUpgradeChecks.services)
        self.secondvm = VirtualMachine(self.pullobjects['secondvm'], TestMinimalUpgradeChecks.services)
        self.thirdvm = VirtualMachine(self.pullobjects['thirdvm'], TestMinimalUpgradeChecks.services)
        self.secondaccount = Account(self.pullobjects['secondaccount'])
        self.vpc_offering = VpcOffering(self.pullobjects['vpc_offering'])
        self.firstvpc = VPC(self.pullobjects['firstvpc'])
        self.network_off = NetworkOffering(self.pullobjects['network_off'])
        self.firstnetworktier = Network(self.pullobjects['firstnetworktier'])
        self.vm1 = VirtualMachine(self.pullobjects['vm1'], TestMinimalUpgradeChecks.services)
        self.vm2 = VirtualMachine(self.pullobjects['vm2'], TestMinimalUpgradeChecks.services)
        self.root_volume_firstvm = Volume(self.pullobjects['root_volume_firstvm'])
        self.snapshot_root_firstvm = Snapshot(self.pullobjects['snapshot_root_firstvm'])
        self.root_volume_secondvm = Volume(self.pullobjects['root_volume_secondvm'])
        self.snapshot_root_secondvm = Snapshot(self.pullobjects['snapshot_root_secondvm'])
        self.template.download(self.apiclient, interval=120)
        self.iso.download(self.apiclient, interval=120)
        self.thirdaccount = Account.create(self.apiclient, TestMinimalUpgradeChecks.services['account'], admin=True, domainid=TestMinimalUpgradeChecks.domain.id)
        self.fourthvm = VirtualMachine.create(self.apiclient, TestMinimalUpgradeChecks.services['virtual_machine'], accountid=self.thirdaccount.name, zoneid=TestMinimalUpgradeChecks.zone.id, domainid=self.thirdaccount.domainid, serviceofferingid=self.service_offering_h1.id, templateid=self.template.id, diskofferingid=self.disk_offering_5gb.id)
        TestMinimalUpgradeChecks.ug_dict.update({'fourthvm': self.fourthvm.__dict__, })
        self.fourthvm.access_ssh_over_nat(self.apiclient, TestMinimalUpgradeChecks.services, self.fourthvm, allow_egress=True)
        self.debug(('Fourth VM that will be used to check SSH Access to other VMs Got Created with Public IP Address %s' % self.fourthvm.public_ip))
        self.debug('Wait for one minute to check for the accessibility of the Fourth VM')
        time.sleep(60)
        self.debug('Verify the network accessibility of the firstvm from fourthvm')
        self.vm_accessibility_check(self.fourthvm, self.firstvm)
        self.debug('Verify the network accessibility of the secondvm from fourthvm')
        self.vm_accessibility_check(self.fourthvm, self.secondvm)
        self.debug(('Stopping First VM - ID: %s' % self.firstvm.id))
        self.firstvm.stop(self.apiclient)
        list_vm_response = list_virtual_machines(self.apiclient, id=self.firstvm.id)
        self.assertEqual(isinstance(list_vm_response, list), True, 'Check list response returns a valid list')
        self.assertNotEqual(len(list_vm_response), 0, 'Check First VM available in List Virtual Machines')
        self.assertEqual(list_vm_response[0].state, 'Stopped', 'Check First virtual machine is in stopped state')
        self.debug('Verify that the Stopped First VM is no longer accessible')
        self.vm_inaccessibility_check(self.fourthvm, self.firstvm)
        self.debug(('Stopping Second VM - ID: %s' % self.secondvm.id))
        self.secondvm.stop(self.apiclient)
        list_vm_response = list_virtual_machines(self.apiclient, id=self.secondvm.id)
        self.assertEqual(isinstance(list_vm_response, list), True, 'Check list response returns a valid list')
        self.assertNotEqual(len(list_vm_response), 0, 'Check Second VM available in List Virtual Machines')
        self.assertEqual(list_vm_response[0].state, 'Stopped', 'Check Second virtual machine is in stopped state')
        self.debug('Verify that the Stopped Second VM is no longer accessible')
        self.vm_inaccessibility_check(self.fourthvm, self.secondvm)
        self.debug('Create Template from Root Volume of the First VM')
        self.template_from_root_volume_firstvm = Template.create(self.apiclient, TestMinimalUpgradeChecks.services['template_from_root_volume'], volumeid=self.root_volume_firstvm.id, account=self.firstaccount.name, domainid=self.firstaccount.domainid)
        self.debug('Create Template from Root Volume of the Second VM')
        self.template_from_root_volume_secondvm = Template.create(self.apiclient, TestMinimalUpgradeChecks.services['template_from_root_volume'], volumeid=self.root_volume_secondvm.id, account=self.firstaccount.name, domainid=self.firstaccount.domainid)
        self.debug('Deploy Fifth VM in third account using the Template created from the ROOT Volume of the First VM')
        self.firstvm.start(self.apiclient)
        self.debug(('Starting Second VM - ID: %s' % self.secondvm.id))
        self.secondvm.start(self.apiclient)
        time.sleep(TestMinimalUpgradeChecks.services['sleep'])
        timeout = TestMinimalUpgradeChecks.services['timeout']
        self.debug('Verify Whether the Template From ROOT Volume of First VM is Ready')
        while True:
            list_template_response = list_templates(self.apiclient, templatefilter='all', id=self.template_from_root_volume_firstvm.id, zoneid=TestMinimalUpgradeChecks.zone.id, account=self.firstaccount.name, domainid=TestMinimalUpgradeChecks.domain.id)
            if isinstance(list_template_response, list):
                break
            elif (timeout == 0):
                raise Exception('List template failed!')
            time.sleep(5)
            timeout = (timeout - 1)
            assert isinstance(list_template_response, list), 'Check for list template response return valid data'
            assert (len(list_template_response) != 0), 'Check Template From ROOT Volume of First VM available in List Templates'
            template_response = list_template_response[0]
            assert template_response.isready, ('Template From ROOT Volume of First VM state is not ready, it is %r' % template_response.isready)
            if isinstance(list_template_response, list):
                break
            elif (timeout == 0):
                raise Exception('List template failed!')
            time.sleep(5)
            timeout = (timeout - 1)
        assert isinstance(list_template_response, list), 'Check for list template response return valid data'
        assert (len(list_template_response) != 0), 'Check Template From ROOT Volume of Second VM available in List Templates'
        template_response = list_template_response[0]
        assert template_response.isready, ('Template From ROOT Volume of Second VM state is not ready, it is %r' % template_response.isready)
        self.debug('Download the created Template From ROOT Volume of First VM')
        self.template_from_root_volume_firstvm.download(self.apiclient, interval=120)
        self.debug('Download the created Template From ROOT Volume of Second VM')
        self.template_from_root_volume_secondvm.download(self.apiclient, interval=120)
        self.debug('Deploy Fifth VM in third account using the Template created from the ROOT Volume of the First VM')
        self.fifthvm = VirtualMachine.create(self.apiclient, TestMinimalUpgradeChecks.services['virtual_machine'], accountid=self.thirdaccount.name, zoneid=TestMinimalUpgradeChecks.zone.id, domainid=self.thirdaccount.domainid, serviceofferingid=self.service_offering_h2.id, templateid=self.template_from_root_volume_firstvm.id, diskofferingid=self.disk_offering_15gb.id)
        self.debug("Verify whether the started First VM is in 'Running' State")
        list_vm_response = list_virtual_machines(self.apiclient, id=self.firstvm.id)
        self.assertEqual(isinstance(list_vm_response, list), True, 'Check list response returns a valid list')
        self.assertNotEqual(len(list_vm_response), 0, 'Check First VM avaliable in List Virtual Machines')
        self.debug(('Verify listVirtualMachines response for First virtual machine: %s' % self.firstvm.id))
        self.assertEqual(list_vm_response[0].state, 'Running', 'Check First virtual machine is in running state')
        self.debug("Verify whether the started Second VM is in 'Running' State")
        list_vm_response = list_virtual_machines(self.apiclient, id=self.secondvm.id)
        self.assertEqual(isinstance(list_vm_response, list), True, 'Check list response returns a valid list')
        self.assertNotEqual(len(list_vm_response), 0, 'Check Second VM avaliable in List Virtual Machines')
        self.debug(('Verify listVirtualMachines response for Second virtual machine: %s' % self.secondvm.id))
        self.assertEqual(list_vm_response[0].state, 'Running', 'Check Second virtual machine is in running state')
        self.debug('Verify whether the Running First VM is accessible after Stopping and Starting it.')
        self.debug('Wait for one minute to check for the accessibility of the First VM')
        time.sleep(60)
        self.vm_accessibility_check(self.fourthvm, self.firstvm, first_time=False)
        self.debug('Verify whether the Running Second VM is accessible after Stopping and Starting it.')
        self.debug('Wait for one minute to check for the accessibility of the Second VM')
        time.sleep(60)
        self.vm_accessibility_check(self.fourthvm, self.secondvm, first_time=False)
        self.debug('Reboot the Running First VM')
        self.firstvm.reboot(self.apiclient)
        list_vm_response = list_virtual_machines(self.apiclient, id=self.firstvm.id)
        self.assertEqual(isinstance(list_vm_response, list), True, 'Check list response returns a valid list')
        self.assertNotEqual(len(list_vm_response), 0, 'Check First VM avaliable in List Virtual Machines')
        self.debug(('Verify listVirtualMachines response for First virtual machine: %s' % self.firstvm.id))
        self.assertEqual(list_vm_response[0].state, 'Running', 'Check First virtual machine is in running state')
        self.debug('Reboot the Running Second VM')
        self.secondvm.reboot(self.apiclient)
        self.debug("Verify whether the rebooted Second VM is in 'Running' State")
        list_vm_response = list_virtual_machines(self.apiclient, id=self.secondvm.id)
        self.assertEqual(isinstance(list_vm_response, list), True, 'Check list response returns a valid list')
        self.assertNotEqual(len(list_vm_response), 0, 'Check Second VM avaliable in List Virtual Machines')
        self.debug(('Verify listVirtualMachines response for Second virtual machine: %s' % self.secondvm.id))
        self.assertEqual(list_vm_response[0].state, 'Running', 'Check Second virtual machine is in running state')
        self.debug('Verify whether the Running First VM is accessible after Rebooting it.')
        self.debug('Wait for one minute to check for the accessibility of the First VM')
        time.sleep(60)
        self.vm_accessibility_check(self.fourthvm, self.firstvm, first_time=False)
        self.debug('Verify whether the Running Second VM is accessible after Rebooting it.')
        self.debug('Wait for one minute to check for the accessibility of the Second VM')
        time.sleep(60)
        self.vm_accessibility_check(self.fourthvm, self.secondvm, first_time=False)
        self.debug("Create Snapshot of First VM's Root Disk")
        self.snapshot_root_firstvm_afterug = Snapshot.create(self.apiclient, volume_id=self.root_volume_firstvm.id, account=self.firstaccount.name, domainid=self.firstaccount.domainid)
        TestMinimalUpgradeChecks.ug_dict.update({'snapshot_root_firstvm_afterug': self.snapshot_root_firstvm_afterug.__dict__, })
        self.debug("Create Snapshot of Second VM's Root Disk")
        self.snapshot_root_secondvm_afterug = Snapshot.create(self.apiclient, volume_id=self.root_volume_secondvm.id, account=self.firstaccount.name, domainid=self.firstaccount.domainid)
        TestMinimalUpgradeChecks.ug_dict.update({'snapshot_root_secondvm_afterug': self.snapshot_root_secondvm_afterug.__dict__, })
        TestMinimalUpgradeChecks.ug_dict.update(self.pullobjects)
        self.debug('Check Type Value:')
        type_dict = self.check_type_value(TestMinimalUpgradeChecks.ug_dict)
        self.debug(type_dict)
        self.debug('Value Types Information is as follows')
        self.debug(type_dict.keys())
        self.debug('Upgrade Dictionary Objects stored in ug_dict are as mentioned below:')
        self.debug(TestMinimalUpgradeChecks.ug_dict)
        self.debug('Refine the Upgrade Dictionary Objects inorder to store them in a Json File')
        refined_dict = self.contruct_dictionary(TestMinimalUpgradeChecks.ug_dict, type_dict)
        self.debug('Re-Use the Objects for Future Validations')
        with open(TestMinimalUpgradeChecks.services['ug_stp_obj_file'], 'wb') as fp:
            json.dump(refined_dict, fp)
    except Exception as e:
        raise Exception(('Warning: Exception during PreUpgrade Test Suite Execution : %s' % e))
    return

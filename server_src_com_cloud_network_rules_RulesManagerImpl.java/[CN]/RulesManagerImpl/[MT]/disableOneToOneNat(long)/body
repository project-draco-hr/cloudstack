{
  boolean success=true;
  Account caller=UserContext.current().getCaller();
  IPAddressVO ipAddress=_ipAddressDao.findById(ipId);
  checkIpAndUserVm(ipAddress,null,caller);
  if (!ipAddress.isOneToOneNat()) {
    throw new InvalidParameterValueException("One to one nat is not enabled for the ip id=" + ipId);
  }
  if (!revokeAllRulesForIp(ipId,UserContext.current().getCallerUserId(),caller)) {
    s_logger.warn("Unable to revoke all static nat rules for ip " + ipAddress);
    success=false;
  }
  if (success) {
    long vmId=ipAddress.getAssociatedWithVmId();
    Nic guestNic=_networkMgr.getNicInNetwork(vmId,ipAddress.getAssociatedWithNetworkId());
    if (guestNic == null) {
      throw new InvalidParameterValueException("Vm doesn't belong to the network " + ipAddress.getAssociatedWithNetworkId());
    }
    List<StaticNatRule> staticNatRules=new ArrayList<StaticNatRule>();
    FirewallRuleVO ruleVO=new FirewallRuleVO(null,ipAddress.getId(),0,0,"icmp",ipAddress.getAssociatedWithNetworkId(),ipAddress.getAccountId(),ipAddress.getDomainId(),Purpose.StaticNat);
    ruleVO.setState(State.Revoke);
    staticNatRules.add(new StaticNatRuleImpl(ruleVO,guestNic.getIp4Address()));
    try {
      if (!applyRules(staticNatRules,true)) {
        return false;
      }
    }
 catch (    ResourceUnavailableException ex) {
      s_logger.warn("Failed to apply icmp firewall rules due to ",ex);
      return false;
    }
  }
  if (success) {
    ipAddress.setOneToOneNat(false);
    ipAddress.setAssociatedWithVmId(null);
    _ipAddressDao.update(ipAddress.getId(),ipAddress);
    return true;
  }
 else {
    s_logger.warn("Failed to disable one to one nat for the ip address id" + ipId);
    return false;
  }
}

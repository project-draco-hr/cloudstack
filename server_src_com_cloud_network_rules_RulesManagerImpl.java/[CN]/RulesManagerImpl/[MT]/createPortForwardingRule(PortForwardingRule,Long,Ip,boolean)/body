{
  UserContext ctx=UserContext.current();
  Account caller=ctx.getCaller();
  Long ipAddrId=rule.getSourceIpAddressId();
  IPAddressVO ipAddress=_ipAddressDao.findById(ipAddrId);
  if (ipAddress == null) {
    throw new InvalidParameterValueException("Unable to create port forwarding rule; ip id=" + ipAddrId + " doesn't exist in the system");
  }
 else   if (ipAddress.isOneToOneNat()) {
    throw new InvalidParameterValueException("Unable to create port forwarding rule; ip id=" + ipAddrId + " has static nat enabled");
  }
  Long networkId=rule.getNetworkId();
  Network network=_networkModel.getNetwork(networkId);
  boolean performedIpAssoc=false;
  Nic guestNic;
  if (ipAddress.getAssociatedWithNetworkId() == null) {
    boolean assignToVpcNtwk=network.getVpcId() != null && ipAddress.getVpcId() != null && ipAddress.getVpcId().longValue() == network.getVpcId();
    if (assignToVpcNtwk) {
      _networkModel.checkIpForService(ipAddress,Service.PortForwarding,networkId);
      s_logger.debug("The ip is not associated with the VPC network id=" + networkId + ", so assigning");
      try {
        ipAddress=_networkMgr.associateIPToGuestNetwork(ipAddrId,networkId,false);
        performedIpAssoc=true;
      }
 catch (      Exception ex) {
        throw new CloudRuntimeException("Failed to associate ip to VPC network as " + "a part of port forwarding rule creation");
      }
    }
  }
 else {
    _networkModel.checkIpForService(ipAddress,Service.PortForwarding,null);
  }
  if (ipAddress.getAssociatedWithNetworkId() == null) {
    throw new InvalidParameterValueException("Ip address " + ipAddress + " is not assigned to the network "+ network);
  }
  try {
    _firewallMgr.validateFirewallRule(caller,ipAddress,rule.getSourcePortStart(),rule.getSourcePortEnd(),rule.getProtocol(),Purpose.PortForwarding,FirewallRuleType.User,networkId,rule.getTrafficType());
    Long accountId=ipAddress.getAllocatedToAccountId();
    Long domainId=ipAddress.getAllocatedInDomainId();
    if (rule.getDestinationPortStart() > rule.getDestinationPortEnd()) {
      throw new InvalidParameterValueException("Start port can't be bigger than end port");
    }
    if ((rule.getDestinationPortEnd() - rule.getDestinationPortStart()) != (rule.getSourcePortEnd() - rule.getSourcePortStart())) {
      throw new InvalidParameterValueException("Source port and destination port ranges should be of equal sizes.");
    }
    UserVm vm=_vmDao.findById(vmId);
    if (vm == null) {
      throw new InvalidParameterValueException("Unable to create port forwarding rule on address " + ipAddress + ", invalid virtual machine id specified ("+ vmId+ ").");
    }
 else {
      checkRuleAndUserVm(rule,vm,caller);
    }
    Ip dstIp=rule.getDestinationIpAddress();
    guestNic=_networkModel.getNicInNetwork(vmId,networkId);
    if (guestNic == null || guestNic.getIp4Address() == null) {
      throw new InvalidParameterValueException("Vm doesn't belong to network associated with ipAddress");
    }
 else {
      dstIp=new Ip(guestNic.getIp4Address());
    }
    if (vmIp != null) {
      if (!dstIp.equals(vmIp)) {
        NicSecondaryIp secondaryIp=_nicSecondaryDao.findByIp4AddressAndNicId(vmIp.toString(),guestNic.getId());
        if (secondaryIp == null) {
          throw new InvalidParameterValueException("IP Address is not in the VM nic's network ");
        }
        dstIp=vmIp;
      }
    }
    boolean validatePortRange=false;
    if (rule.getSourcePortStart().intValue() != rule.getSourcePortEnd().intValue() || rule.getDestinationPortStart() != rule.getDestinationPortEnd()) {
      validatePortRange=true;
    }
    if (validatePortRange) {
      if (rule.getSourcePortStart().intValue() != rule.getDestinationPortStart()) {
        throw new InvalidParameterValueException("Private port start should be equal to public port start");
      }
      if (rule.getSourcePortEnd().intValue() != rule.getDestinationPortEnd()) {
        throw new InvalidParameterValueException("Private port end should be equal to public port end");
      }
    }
    Transaction txn=Transaction.currentTxn();
    txn.start();
    PortForwardingRuleVO newRule=new PortForwardingRuleVO(rule.getXid(),rule.getSourceIpAddressId(),rule.getSourcePortStart(),rule.getSourcePortEnd(),dstIp,rule.getDestinationPortStart(),rule.getDestinationPortEnd(),rule.getProtocol().toLowerCase(),networkId,accountId,domainId,vmId);
    newRule=_portForwardingDao.persist(newRule);
    if (openFirewall) {
      _firewallMgr.createRuleForAllCidrs(ipAddrId,caller,rule.getSourcePortStart(),rule.getSourcePortEnd(),rule.getProtocol(),null,null,newRule.getId(),networkId);
    }
    try {
      _firewallMgr.detectRulesConflict(newRule);
      if (!_firewallDao.setStateToAdd(newRule)) {
        throw new CloudRuntimeException("Unable to update the state to add for " + newRule);
      }
      UserContext.current().setEventDetails("Rule Id: " + newRule.getId());
      UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_RULE_ADD,newRule.getAccountId(),ipAddress.getDataCenterId(),newRule.getId(),null,PortForwardingRule.class.getName(),newRule.getUuid());
      txn.commit();
      return newRule;
    }
 catch (    Exception e) {
      if (newRule != null) {
        txn.start();
        _firewallMgr.revokeRelatedFirewallRule(newRule.getId(),false);
        removePFRule(newRule);
        txn.commit();
      }
      if (e instanceof NetworkRuleConflictException) {
        throw (NetworkRuleConflictException)e;
      }
      throw new CloudRuntimeException("Unable to add rule for the ip id=" + ipAddrId,e);
    }
  }
  finally {
    if (performedIpAssoc) {
      IpAddress ip=_ipAddressDao.findById(ipAddress.getId());
      _vpcMgr.unassignIPFromVpcNetwork(ip.getId(),networkId);
    }
  }
}

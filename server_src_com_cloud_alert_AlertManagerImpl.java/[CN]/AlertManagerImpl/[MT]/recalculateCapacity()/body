{
  if (s_logger.isTraceEnabled()) {
    s_logger.trace("recalculating system capacity");
  }
  List<CapacityVO> newCapacities=new ArrayList<CapacityVO>();
  SearchCriteria<HostVO> sc=_hostDao.createSearchCriteria();
  sc.addAnd("status",SearchCriteria.Op.EQ,Status.Up.toString());
  List<HostVO> hosts=_hostDao.search(sc,null);
  List<ServiceOfferingVO> offerings=_offeringsDao.listAllIncludingRemoved();
  Map<Long,ServiceOfferingVO> offeringsMap=new HashMap<Long,ServiceOfferingVO>();
  for (  ServiceOfferingVO offering : offerings) {
    offeringsMap.put(offering.getId(),offering);
  }
  if (!_useNewNetworking) {
    for (    HostVO host : hosts) {
      if (host.getType() != Host.Type.Routing) {
        continue;
      }
      long cpu=0;
      long usedMemory=0;
      List<DomainRouterVO> domainRouters=_routerDao.listUpByHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + domainRouters.size() + " router domains on host "+ host.getId());
      }
      for (      DomainRouterVO router : domainRouters) {
        usedMemory+=router.getRamSize() * 1024L * 1024L;
      }
      List<ConsoleProxyVO> proxys=_consoleProxyDao.listUpByHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + proxys.size() + " console proxy on host "+ host.getId());
      }
      for (      ConsoleProxyVO proxy : proxys) {
        usedMemory+=proxy.getRamSize() * 1024L * 1024L;
      }
      List<SecondaryStorageVmVO> secStorageVms=_secStorgaeVmDao.listUpByHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + secStorageVms.size() + " secondary storage VM on host "+ host.getId());
      }
      for (      SecondaryStorageVmVO secStorageVm : secStorageVms) {
        usedMemory+=secStorageVm.getRamSize() * 1024L * 1024L;
      }
      List<UserVmVO> vms=_userVmDao.listUpByHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + vms.size() + " user VM on host "+ host.getId());
      }
      for (      UserVmVO vm : vms) {
        ServiceOffering so=offeringsMap.get(vm.getServiceOfferingId());
        usedMemory+=so.getRamSize() * 1024L * 1024L;
        cpu+=so.getCpu() * (so.getSpeed() * 0.99);
      }
      long totalMemory=host.getTotalMemory();
      CapacityVO newMemoryCapacity=new CapacityVO(host.getId(),host.getDataCenterId(),host.getPodId(),usedMemory,totalMemory,CapacityVO.CAPACITY_TYPE_MEMORY);
      CapacityVO newCPUCapacity=new CapacityVO(host.getId(),host.getDataCenterId(),host.getPodId(),cpu,(long)(host.getCpus() * host.getSpeed() * _cpuOverProvisioningFactor),CapacityVO.CAPACITY_TYPE_CPU);
      newCapacities.add(newMemoryCapacity);
      newCapacities.add(newCPUCapacity);
    }
  }
{
    for (    HostVO host : hosts) {
      if (host.getType() != Host.Type.Routing) {
        continue;
      }
      long usedCpu=0;
      long usedMemory=0;
      long reservedMemory=0;
      long reservedCpu=0;
      List<DomainRouterVO> domainRouters=_routerDao.listUpByHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + domainRouters.size() + " router domains on host "+ host.getId());
      }
      for (      DomainRouterVO router : domainRouters) {
        ServiceOffering so=offeringsMap.get(router.getServiceOfferingId());
        if (router.getState() == State.Running) {
          usedMemory+=so.getRamSize() * 1024L * 1024L;
          usedCpu+=so.getCpu() * so.getSpeed();
        }
      }
      List<DomainRouterVO> domainRoutersByLastHostId=_routerDao.listByLastHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + domainRoutersByLastHostId.size() + " router domains, not running on host "+ host.getId());
      }
      for (      DomainRouterVO router : domainRoutersByLastHostId) {
        ServiceOffering so=offeringsMap.get(router.getServiceOfferingId());
        reservedMemory+=so.getRamSize() * 1024L * 1024L;
        usedCpu+=so.getCpu() * so.getSpeed();
      }
      List<ConsoleProxyVO> proxys=_consoleProxyDao.listUpByHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + proxys.size() + " console proxy on host "+ host.getId());
      }
      for (      ConsoleProxyVO proxy : proxys) {
        ServiceOffering so=offeringsMap.get(proxy.getServiceOfferingId());
        if (proxy.getState() == State.Running) {
          usedMemory+=so.getRamSize() * 1024L * 1024L;
          usedCpu+=so.getCpu() * so.getSpeed();
        }
      }
      List<ConsoleProxyVO> proxysByLastHostId=_consoleProxyDao.listByLastHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + proxysByLastHostId.size() + " console proxy, not running on host "+ host.getId());
      }
      for (      ConsoleProxyVO proxy : proxysByLastHostId) {
        ServiceOffering so=offeringsMap.get(proxy.getServiceOfferingId());
        reservedMemory+=so.getRamSize() * 1024L * 1024L;
        usedCpu+=so.getCpu() * so.getSpeed();
      }
      List<SecondaryStorageVmVO> secStorageVms=_secStorgaeVmDao.listUpByHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + secStorageVms.size() + " secondary storage VM on host "+ host.getId());
      }
      for (      SecondaryStorageVmVO secStorageVm : secStorageVms) {
        ServiceOffering so=offeringsMap.get(secStorageVm.getServiceOfferingId());
        if (secStorageVm.getState() == State.Running) {
          usedMemory+=so.getRamSize() * 1024L * 1024L;
          usedCpu+=so.getCpu() * so.getSpeed();
        }
      }
      List<SecondaryStorageVmVO> secStorageVmsByLastHostId=_secStorgaeVmDao.listByLastHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + secStorageVmsByLastHostId.size() + " secondary storage VM, not running on host "+ host.getId());
      }
      for (      SecondaryStorageVmVO secStorageVm : secStorageVmsByLastHostId) {
        ServiceOffering so=offeringsMap.get(secStorageVm.getServiceOfferingId());
        reservedMemory+=so.getRamSize() * 1024L * 1024L;
        usedCpu+=so.getCpu() * so.getSpeed();
      }
      List<UserVmVO> vms=_userVmDao.listUpByHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + vms.size() + " user VM on host "+ host.getId());
      }
      for (      UserVmVO vm : vms) {
        ServiceOffering so=offeringsMap.get(vm.getServiceOfferingId());
        if (vm.getState() == State.Running) {
          usedMemory+=so.getRamSize() * 1024L * 1024L;
          usedCpu+=so.getCpu() * so.getSpeed();
        }
      }
      List<UserVmVO> vmsByLastHostId=_userVmDao.listByLastHostId(host.getId());
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Found " + secStorageVmsByLastHostId.size() + " user VM, not running on host "+ host.getId());
      }
      for (      UserVmVO vm : vmsByLastHostId) {
        ServiceOffering so=offeringsMap.get(vm.getServiceOfferingId());
        reservedMemory+=so.getRamSize() * 1024L * 1024L;
        reservedCpu+=so.getCpu() * so.getSpeed();
      }
      CapacityVO cpuCap=_capacityDao.findByHostIdType(host.getId(),CapacityVO.CAPACITY_TYPE_CPU);
      CapacityVO memCap=_capacityDao.findByHostIdType(host.getId(),CapacityVO.CAPACITY_TYPE_MEMORY);
      if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {
        s_logger.debug("Cool, no need to calibrate cpu capacity, host:" + host.getId() + " usedCpu: "+ cpuCap.getUsedCapacity()+ " reservedCpu: "+ cpuCap.getReservedCapacity());
      }
 else       if (cpuCap.getReservedCapacity() != reservedCpu) {
        s_logger.debug("Calibrate reserved cpu for host: " + host.getId() + " old reservedCpu:"+ cpuCap.getReservedCapacity()+ " new reservedCpu:"+ reservedCpu);
        cpuCap.setReservedCapacity(reservedCpu);
      }
 else {
        s_logger.debug("host: " + host.getId() + ", old usedCpu: "+ cpuCap.getUsedCapacity()+ ", new usedCpu: "+ usedCpu+ ", no calibration");
      }
      if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {
        s_logger.debug("Cool, no need to calibrate memory capacity, host:" + host.getId() + " usedMem: "+ memCap.getUsedCapacity()+ " reservedMem: "+ memCap.getReservedCapacity());
      }
 else       if (memCap.getReservedCapacity() != reservedMemory) {
        s_logger.debug("Calibrate reserved memory for host: " + host.getId() + " old reservedMem:"+ memCap.getReservedCapacity()+ " new reservedMem:"+ reservedMemory);
        memCap.setReservedCapacity(reservedMemory);
      }
 else {
        s_logger.debug("host: " + host.getId() + ", old usedMem: "+ memCap.getUsedCapacity()+ ", new nesedMem: "+ usedMemory+ ", no calibration");
      }
      try {
        _capacityDao.update(cpuCap.getId(),cpuCap);
        _capacityDao.update(memCap.getId(),memCap);
      }
 catch (      Exception e) {
      }
    }
  }
  List<StoragePoolVO> storagePools=_storagePoolDao.listAll();
  for (  StoragePoolVO pool : storagePools) {
    long disk=0l;
    Pair<Long,Long> sizes=_volumeDao.getCountAndTotalByPool(pool.getId());
    disk=sizes.second();
    _storageMgr.createCapacityEntry(pool,disk);
  }
  List<DataCenterVO> datacenters=_dcDao.listAllIncludingRemoved();
  for (  DataCenterVO datacenter : datacenters) {
    long dcId=datacenter.getId();
    int totalPublicIPs=_publicIPAddressDao.countIPsForDashboard(dcId,false);
    int allocatedPublicIPs=_publicIPAddressDao.countIPsForDashboard(dcId,true);
    CapacityVO newPublicIPCapacity=new CapacityVO(null,dcId,null,allocatedPublicIPs,totalPublicIPs,CapacityVO.CAPACITY_TYPE_PUBLIC_IP);
    newCapacities.add(newPublicIPCapacity);
  }
  List<HostPodVO> pods=_podDao.listAllIncludingRemoved();
  for (  HostPodVO pod : pods) {
    long podId=pod.getId();
    long dcId=pod.getDataCenterId();
    int totalPrivateIPs=_privateIPAddressDao.countIPs(podId,dcId,false);
    int allocatedPrivateIPs=_privateIPAddressDao.countIPs(podId,dcId,true);
    CapacityVO newPrivateIPCapacity=new CapacityVO(null,dcId,podId,allocatedPrivateIPs,totalPrivateIPs,CapacityVO.CAPACITY_TYPE_PRIVATE_IP);
    newCapacities.add(newPrivateIPCapacity);
  }
  Transaction txn=Transaction.currentTxn();
  try {
    txn.start();
    if (_useNewNetworking) {
      _capacityDao.clearNonStorageCapacities2();
    }
 else {
      _capacityDao.clearNonStorageCapacities();
    }
    for (    CapacityVO newCapacity : newCapacities) {
      s_logger.trace("Executing capacity update");
      _capacityDao.persist(newCapacity);
      s_logger.trace("Done with capacity update");
    }
    txn.commit();
  }
 catch (  Exception ex) {
    txn.rollback();
    s_logger.error("Unable to start transaction for capacity update");
  }
 finally {
    txn.close();
  }
}

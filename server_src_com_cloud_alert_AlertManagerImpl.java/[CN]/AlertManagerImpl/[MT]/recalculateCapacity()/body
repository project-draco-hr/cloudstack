{
  if (s_logger.isTraceEnabled()) {
    s_logger.trace("recalculating system capacity");
  }
  List<CapacityVO> newCapacities=new ArrayList<CapacityVO>();
  SearchCriteria<HostVO> sc=_hostDao.createSearchCriteria();
  sc.addAnd("status",SearchCriteria.Op.EQ,Status.Up.toString());
  List<HostVO> hosts=_hostDao.search(sc,null);
  List<ServiceOfferingVO> offerings=_offeringsDao.listAllIncludingRemoved();
  Map<Long,ServiceOfferingVO> offeringsMap=new HashMap<Long,ServiceOfferingVO>();
  for (  ServiceOfferingVO offering : offerings) {
    offeringsMap.put(offering.getId(),offering);
  }
  List<StoragePoolVO> storagePools=_storagePoolDao.listAll();
  for (  StoragePoolVO pool : storagePools) {
    long disk=0l;
    Pair<Long,Long> sizes=_volumeDao.getCountAndTotalByPool(pool.getId());
    disk=sizes.second();
    _storageMgr.createCapacityEntry(pool,disk);
  }
  List<DataCenterVO> datacenters=_dcDao.listAllIncludingRemoved();
  for (  DataCenterVO datacenter : datacenters) {
    long dcId=datacenter.getId();
    int totalPublicIPs=_publicIPAddressDao.countIPsForDashboard(dcId,false);
    int allocatedPublicIPs=_publicIPAddressDao.countIPsForDashboard(dcId,true);
    CapacityVO newPublicIPCapacity=new CapacityVO(null,dcId,null,allocatedPublicIPs,totalPublicIPs,CapacityVO.CAPACITY_TYPE_PUBLIC_IP);
    newCapacities.add(newPublicIPCapacity);
  }
  List<HostPodVO> pods=_podDao.listAllIncludingRemoved();
  for (  HostPodVO pod : pods) {
    long podId=pod.getId();
    long dcId=pod.getDataCenterId();
    int totalPrivateIPs=_privateIPAddressDao.countIPs(podId,dcId,false);
    int allocatedPrivateIPs=_privateIPAddressDao.countIPs(podId,dcId,true);
    CapacityVO newPrivateIPCapacity=new CapacityVO(null,dcId,podId,allocatedPrivateIPs,totalPrivateIPs,CapacityVO.CAPACITY_TYPE_PRIVATE_IP);
    newCapacities.add(newPrivateIPCapacity);
  }
  Transaction txn=Transaction.currentTxn();
  try {
    txn.start();
    if (_useNewNetworking) {
      _capacityDao.clearNonStorageCapacities2();
    }
 else {
      _capacityDao.clearNonStorageCapacities();
    }
    for (    CapacityVO newCapacity : newCapacities) {
      s_logger.trace("Executing capacity update");
      _capacityDao.persist(newCapacity);
      s_logger.trace("Done with capacity update");
    }
    txn.commit();
  }
 catch (  Exception ex) {
    txn.rollback();
    s_logger.error("Unable to start transaction for capacity update");
  }
 finally {
    txn.close();
  }
}

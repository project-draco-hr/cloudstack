{
  final SynchronousListener sl=new SynchronousListener(null);
  final long seq=req.getSequence();
  send(req,sl);
  try {
    for (int i=0; i < 2; i++) {
      Answer[] answers=null;
      try {
        answers=sl.waitFor(wait);
      }
 catch (      final InterruptedException e) {
        s_logger.debug(log(seq,"Interrupted"));
      }
      if (answers != null) {
        if (s_logger.isDebugEnabled()) {
          new Response(req,answers).log(_id,"Received: ");
        }
        return answers;
      }
      answers=sl.getAnswers();
      if (answers != null) {
        if (s_logger.isDebugEnabled()) {
          new Response(req,answers).log(_id,"Received after timeout: ");
        }
        return answers;
      }
      final Long current=_currentSequence;
      if (current != null && seq != current) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug(log(seq,"Waited too long."));
        }
        throw new OperationTimedoutException(req.getCommands(),_id,seq,wait,false);
      }
      if (s_logger.isDebugEnabled()) {
        s_logger.debug(log(seq,"Waiting some more time because this is the current command"));
      }
    }
    throw new OperationTimedoutException(req.getCommands(),_id,seq,wait * 2,true);
  }
 catch (  OperationTimedoutException e) {
    s_logger.warn(log(seq,"Timed out on " + req.toString()));
    cancel(seq);
    throw e;
  }
catch (  Exception e) {
    s_logger.warn(log(seq,"Exception while waiting for answer"),e);
    cancel(seq);
    throw new OperationTimedoutException(req.getCommands(),_id,seq,wait,false);
  }
 finally {
    unregisterListener(seq);
    final Long current=_currentSequence;
    if (req.executeInSequence() && (current != null && current == seq)) {
      sendNext(seq);
    }
  }
}

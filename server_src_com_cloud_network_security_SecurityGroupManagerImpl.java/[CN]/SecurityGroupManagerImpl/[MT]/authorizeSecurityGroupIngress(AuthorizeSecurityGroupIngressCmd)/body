{
  String groupName=cmd.getSecurityGroupName();
  String protocol=cmd.getProtocol();
  Integer startPort=cmd.getStartPort();
  Integer endPort=cmd.getEndPort();
  Integer icmpType=cmd.getIcmpType();
  Integer icmpCode=cmd.getIcmpCode();
  List<String> cidrList=cmd.getCidrList();
  Map groupList=cmd.getUserSecurityGroupList();
  Account account=UserContext.current().getCaller();
  String accountName=cmd.getAccountName();
  Long domainId=cmd.getDomainId();
  Integer startPortOrType=null;
  Integer endPortOrCode=null;
  Long accountId=null;
  if (!_enabled) {
    return null;
  }
  if (protocol == null) {
    protocol="all";
  }
  if (!NetUtils.isValidSecurityGroupProto(protocol)) {
    s_logger.debug("Invalid protocol specified " + protocol);
    throw new InvalidParameterValueException("Invalid protocol " + protocol);
  }
  if ("icmp".equalsIgnoreCase(protocol)) {
    if ((icmpType == null) || (icmpCode == null)) {
      throw new InvalidParameterValueException("Invalid ICMP type/code specified, icmpType = " + icmpType + ", icmpCode = "+ icmpCode);
    }
    if (icmpType == -1 && icmpCode != -1) {
      throw new InvalidParameterValueException("Invalid icmp type range");
    }
    if (icmpCode > 255) {
      throw new InvalidParameterValueException("Invalid icmp code ");
    }
    startPortOrType=icmpType;
    endPortOrCode=icmpCode;
  }
 else   if (protocol.equals("all")) {
    if ((startPort != null) || (endPort != null)) {
      throw new InvalidParameterValueException("Cannot specify startPort or endPort without specifying protocol");
    }
    startPortOrType=0;
    endPortOrCode=0;
  }
 else {
    if ((startPort == null) || (endPort == null)) {
      throw new InvalidParameterValueException("Invalid port range specified, startPort = " + startPort + ", endPort = "+ endPort);
    }
    if (startPort == 0 && endPort == 0) {
      endPort=65535;
    }
    if (startPort > endPort) {
      s_logger.debug("Invalid port range specified: " + startPort + ":"+ endPort);
      throw new InvalidParameterValueException("Invalid port range ");
    }
    if (startPort > 65535 || endPort > 65535 || startPort < -1 || endPort < -1) {
      s_logger.debug("Invalid port numbers specified: " + startPort + ":"+ endPort);
      throw new InvalidParameterValueException("Invalid port numbers ");
    }
    if (startPort < 0 || endPort < 0) {
      throw new InvalidParameterValueException("Invalid port range ");
    }
    startPortOrType=startPort;
    endPortOrCode=endPort;
  }
  protocol=protocol.toLowerCase();
  if ((account == null) || isAdmin(account.getType())) {
    if ((accountName != null) && (domainId != null)) {
      if ((account != null) && !_domainDao.isChildDomain(account.getDomainId(),domainId)) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Unable to find rules for security group id = " + groupName + ", permission denied.");
        }
        throw new PermissionDeniedException("Unable to find rules for security group id = " + groupName + ", permission denied.");
      }
      Account groupOwner=_accountDao.findActiveAccount(accountName,domainId);
      if (groupOwner == null) {
        throw new PermissionDeniedException("Unable to find account " + accountName + " in domain "+ domainId);
      }
      accountId=groupOwner.getId();
    }
 else {
      if (account != null) {
        accountId=account.getId();
        domainId=account.getDomainId();
      }
    }
  }
 else {
    if (account != null) {
      accountId=account.getId();
      domainId=account.getDomainId();
    }
  }
  if (accountId == null) {
    throw new InvalidParameterValueException("Unable to find account for security group " + groupName + "; failed to authorize ingress.");
  }
  if (cidrList == null && groupList == null) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("At least one cidr or at least one security group needs to be specified");
    }
    throw new InvalidParameterValueException("At least one cidr or at least one security group needs to be specified");
  }
  List<SecurityGroupVO> authorizedGroups=new ArrayList<SecurityGroupVO>();
  if (groupList != null) {
    Collection userGroupCollection=groupList.values();
    Iterator iter=userGroupCollection.iterator();
    while (iter.hasNext()) {
      HashMap userGroup=(HashMap)iter.next();
      String group=(String)userGroup.get("group");
      String authorizedAccountName=(String)userGroup.get("account");
      if ((group == null) || (authorizedAccountName == null)) {
        throw new InvalidParameterValueException("Invalid user group specified, fields 'group' and 'account' cannot be null, please specify groups in the form:  userGroupList[0].group=XXX&userGroupList[0].account=YYY");
      }
      Account authorizedAccount=_accountDao.findActiveAccount(authorizedAccountName,domainId);
      if (authorizedAccount == null) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Nonexistent account: " + authorizedAccountName + ", domainid: "+ domainId+ " when trying to authorize ingress for "+ groupName+ ":"+ protocol+ ":"+ startPortOrType+ ":"+ endPortOrCode);
        }
        throw new InvalidParameterValueException("Nonexistent account: " + authorizedAccountName + " when trying to authorize ingress for "+ groupName+ ":"+ protocol+ ":"+ startPortOrType+ ":"+ endPortOrCode);
      }
      SecurityGroupVO groupVO=_securityGroupDao.findByAccountAndName(authorizedAccount.getId(),group);
      if (groupVO == null) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Nonexistent group " + group + " for account "+ authorizedAccountName+ "/"+ domainId);
        }
        throw new InvalidParameterValueException("Invalid group (" + group + ") given, unable to authorize ingress.");
      }
      authorizedGroups.add(groupVO);
    }
  }
  final Transaction txn=Transaction.currentTxn();
  final Set<SecurityGroupVO> authorizedGroups2=new TreeSet<SecurityGroupVO>(new SecurityGroupVOComparator());
  authorizedGroups2.addAll(authorizedGroups);
  txn.start();
  SecurityGroupVO securityGroup=_securityGroupDao.findByAccountAndName(accountId,groupName);
  if (securityGroup == null) {
    s_logger.warn("Security group not found: name= " + groupName);
    return null;
  }
  SecurityGroupVO securityGroupLock=_securityGroupDao.acquireInLockTable(securityGroup.getId());
  if (securityGroupLock == null) {
    s_logger.warn("Could not acquire lock on network security group: name= " + groupName);
    return null;
  }
  List<IngressRuleVO> newRules=new ArrayList<IngressRuleVO>();
  try {
    securityGroup=_securityGroupDao.lockRow(securityGroup.getId(),false);
    if (securityGroup == null) {
      s_logger.warn("Could not acquire lock on network group " + groupName);
      return null;
    }
    for (    final SecurityGroupVO ngVO : authorizedGroups2) {
      final Long ngId=ngVO.getId();
      if (ngVO.getId() != securityGroup.getId()) {
        final SecurityGroupVO tmpGrp=_securityGroupDao.lockRow(ngId,false);
        if (tmpGrp == null) {
          s_logger.warn("Failed to acquire lock on security group: " + ngId);
          txn.rollback();
          return null;
        }
      }
      IngressRuleVO ingressRule=_ingressRuleDao.findByProtoPortsAndAllowedGroupId(securityGroup.getId(),protocol,startPort,endPort,ngVO.getId());
      if (ingressRule != null) {
        continue;
      }
      ingressRule=new IngressRuleVO(securityGroup.getId(),startPort,endPort,protocol,ngVO.getId(),ngVO.getName(),ngVO.getAccountName());
      ingressRule=_ingressRuleDao.persist(ingressRule);
      newRules.add(ingressRule);
    }
    if (cidrList != null) {
      for (      String cidr : cidrList) {
        IngressRuleVO ingressRule=_ingressRuleDao.findByProtoPortsAndCidr(securityGroup.getId(),protocol,startPort,endPort,cidr);
        if (ingressRule != null) {
          continue;
        }
        ingressRule=new IngressRuleVO(securityGroup.getId(),startPort,endPort,protocol,cidr);
        ingressRule=_ingressRuleDao.persist(ingressRule);
        newRules.add(ingressRule);
      }
    }
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Added " + newRules.size() + " rules to security group "+ groupName);
    }
    txn.commit();
    final Set<Long> affectedVms=new HashSet<Long>();
    affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(securityGroup.getId()));
    scheduleRulesetUpdateToHosts(affectedVms,true,null);
    return newRules;
  }
 catch (  Exception e) {
    s_logger.warn("Exception caught when adding ingress rules ",e);
    throw new CloudRuntimeException("Exception caught when adding ingress rules",e);
  }
 finally {
    if (securityGroupLock != null) {
      _securityGroupDao.releaseFromLockTable(securityGroupLock.getId());
    }
  }
}

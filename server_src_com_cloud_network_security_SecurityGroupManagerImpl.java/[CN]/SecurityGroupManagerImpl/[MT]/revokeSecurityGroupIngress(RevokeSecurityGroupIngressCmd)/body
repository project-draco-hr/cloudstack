{
  if (!_enabled) {
    return false;
  }
  Account account=UserContext.current().getCaller();
  Long domainId=cmd.getDomainId();
  String accountName=cmd.getAccountName();
  Long id=cmd.getId();
  Long accountId=null;
  SecurityGroupVO groupHandle=null;
  if ((account == null) || isAdmin(account.getType())) {
    if ((accountName != null) && (domainId != null)) {
      if ((account != null) && !_domainDao.isChildDomain(account.getDomainId(),domainId)) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Unable to revoke ingress rule id = " + id + ", permission denied.");
        }
        throw new PermissionDeniedException("Unable to revoke ingress rule id  = " + id + ", permission denied.");
      }
      Account groupOwner=_accountDao.findActiveAccount(accountName,domainId);
      if (groupOwner == null) {
        throw new InvalidParameterValueException("Unable to find account " + accountName + " in domain "+ domainId);
      }
      accountId=groupOwner.getId();
    }
 else {
      if (account != null) {
        accountId=account.getId();
        domainId=account.getDomainId();
      }
    }
  }
 else {
    if (account != null) {
      accountId=account.getId();
      domainId=account.getDomainId();
    }
  }
  if (accountId == null) {
    throw new InvalidParameterValueException("Unable to find account for ingress rule id:" + id + "; failed to revoke ingress.");
  }
  IngressRuleVO rule=_ingressRuleDao.findById(id);
  if (rule == null) {
    s_logger.debug("Unable to find ingress rule with id " + id);
    throw new InvalidParameterValueException("Unable to find ingress rule with id " + id);
  }
  final Transaction txn=Transaction.currentTxn();
  try {
    txn.start();
    groupHandle=_securityGroupDao.acquireInLockTable(rule.getSecurityGroupId());
    if (groupHandle == null) {
      s_logger.warn("Could not acquire lock on security group id: " + rule.getSecurityGroupId());
      return false;
    }
    _ingressRuleDao.remove(id);
    s_logger.debug("revokeSecurityGroupIngress succeeded for ingress rule id: " + id);
    final Set<Long> affectedVms=new HashSet<Long>();
    affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(groupHandle.getId()));
    scheduleRulesetUpdateToHosts(affectedVms,true,null);
    return true;
  }
 catch (  Exception e) {
    s_logger.warn("Exception caught when deleting ingress rules ",e);
    throw new CloudRuntimeException("Exception caught when deleting ingress rules",e);
  }
 finally {
    if (groupHandle != null) {
      _securityGroupDao.releaseFromLockTable(groupHandle.getId());
    }
    txn.commit();
  }
}

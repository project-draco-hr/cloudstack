{
  AsyncJobVO job=_jobDao.findById(item.getContentId());
  if (job != null) {
    if (logger.isDebugEnabled()) {
      logger.debug("Schedule queued job-" + job.getId());
    }
    job.setSyncSource(item);
    try {
      job.setExecutingMsid(getMsid());
      _jobDao.update(job.getId(),job);
    }
 catch (    Exception e) {
      logger.warn("Unexpected exception while dispatching job-" + item.getContentId(),e);
      try {
        _queueMgr.returnItem(item.getId());
      }
 catch (      Throwable thr) {
        logger.error("Unexpected exception while returning job-" + item.getContentId() + " to queue",thr);
      }
    }
    try {
      scheduleExecution(job);
    }
 catch (    RejectedExecutionException e) {
      logger.warn("Execution for job-" + job.getId() + " is rejected, return it to the queue for next turn");
      try {
        _queueMgr.returnItem(item.getId());
      }
 catch (      Exception e2) {
        logger.error("Unexpected exception while returning job-" + item.getContentId() + " to queue",e2);
      }
      try {
        job.setExecutingMsid(null);
        _jobDao.update(job.getId(),job);
      }
 catch (      Exception e3) {
        logger.warn("Unexpected exception while update job-" + item.getContentId() + " msid for bookkeeping");
      }
    }
  }
 else {
    if (logger.isDebugEnabled()) {
      logger.debug("Unable to find related job for queue item: " + item.toString());
    }
    _queueMgr.purgeItem(item.getId());
  }
}

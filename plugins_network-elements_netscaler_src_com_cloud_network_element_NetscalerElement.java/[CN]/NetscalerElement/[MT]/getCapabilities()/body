{
  Map<Service,Map<Capability,String>> capabilities=new HashMap<Service,Map<Capability,String>>();
  Map<Capability,String> lbCapabilities=new HashMap<Capability,String>();
  lbCapabilities.put(Capability.SupportedLBAlgorithms,"roundrobin,leastconn");
  lbCapabilities.put(Capability.SupportedLBIsolation,"dedicated, shared");
  lbCapabilities.put(Capability.SupportedProtocols,"tcp,udp");
  lbCapabilities.put(Capability.TrafficStatistics,"per public ip");
  lbCapabilities.put(Capability.LoadBalancingSupportedIps,"additional");
  lbCapabilities.put(Capability.LbSchemes,LoadBalancerContainer.Scheme.Public.toString());
  AutoScaleCounter counter;
  List<AutoScaleCounter> counterList=new ArrayList<AutoScaleCounter>();
  counter=new AutoScaleCounter(AutoScaleCounterSnmp);
  counterList.add(counter);
  counter.addParam("snmpcommunity",true,"the community string that has to be used to do a SNMP GET on the AutoScaled Vm",false);
  counter.addParam("snmpport",false,"the port at which SNMP agent is running on the AutoScaled Vm",false);
  counter=new AutoScaleCounter(AutoScaleCounterNetscaler);
  counterList.add(counter);
  Gson gson=new Gson();
  String autoScaleCounterList=gson.toJson(counterList);
  lbCapabilities.put(Capability.AutoScaleCounters,autoScaleCounterList);
  LbStickinessMethod method;
  List<LbStickinessMethod> methodList=new ArrayList<LbStickinessMethod>();
  method=new LbStickinessMethod(StickinessMethodType.LBCookieBased,"This is cookie based sticky method, can be used only for http");
  methodList.add(method);
  method.addParam("holdtime",false,"time period in minutes for which persistence is in effect.",false);
  method=new LbStickinessMethod(StickinessMethodType.AppCookieBased,"This is app session based sticky method, can be used only for http");
  methodList.add(method);
  method.addParam("name",true,"cookie name passed in http header by apllication to the client",false);
  method=new LbStickinessMethod(StickinessMethodType.SourceBased,"This is source based sticky method, can be used for any type of protocol.");
  methodList.add(method);
  method.addParam("holdtime",false,"time period for which persistence is in effect.",false);
  String stickyMethodList=gson.toJson(methodList);
  lbCapabilities.put(Capability.SupportedStickinessMethods,stickyMethodList);
  lbCapabilities.put(Capability.ElasticLb,"true");
  lbCapabilities.put(Capability.HealthCheckPolicy,"true");
  capabilities.put(Service.Lb,lbCapabilities);
  Map<Capability,String> staticNatCapabilities=new HashMap<Capability,String>();
  staticNatCapabilities.put(Capability.ElasticIp,"true");
  capabilities.put(Service.StaticNat,staticNatCapabilities);
  lbCapabilities.put(Capability.SslTermination,"true");
  Map<Capability,String> firewallCapabilities=new HashMap<Capability,String>();
  firewallCapabilities.put(Capability.TrafficStatistics,"per public ip");
  firewallCapabilities.put(Capability.SupportedProtocols,"tcp,udp,icmp");
  firewallCapabilities.put(Capability.MultipleIps,"true");
  capabilities.put(Service.Firewall,firewallCapabilities);
  return capabilities;
}

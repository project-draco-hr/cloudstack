{
  LinkedHashMap<NetworkVO,List<? extends NicProfile>> networkIpMap=new LinkedHashMap<NetworkVO,List<? extends NicProfile>>();
  for (  String uuid : networkNicMap.keySet()) {
    NetworkVO network=_networkDao.findByUuid(uuid);
    if (network != null) {
      networkIpMap.put(network,new ArrayList<NicProfile>(Arrays.asList(networkNicMap.get(uuid))));
    }
  }
  VirtualMachineEntityImpl vmEntity=ComponentContext.inject(VirtualMachineEntityImpl.class);
  vmEntity.init(id,owner,hostName,displayName,cpu,speed,memory,computeTags,rootDiskTags,new ArrayList<String>(networkNicMap.keySet()));
  HypervisorType hypervisorType=HypervisorType.valueOf(hypervisor);
  VMInstanceVO vm=_vmDao.findByUuid(id);
  DiskOfferingInfo rootDiskOfferingInfo=new DiskOfferingInfo();
  List<DiskOfferingInfo> dataDiskOfferings=new ArrayList<DiskOfferingInfo>();
  ServiceOfferingVO computeOffering=_serviceOfferingDao.findById(vm.getId(),vm.getServiceOfferingId());
  rootDiskOfferingInfo.setDiskOffering(computeOffering);
  rootDiskOfferingInfo.setSize(rootDiskSize);
  if (computeOffering.isCustomizedIops() != null && computeOffering.isCustomizedIops()) {
    Map<String,String> userVmDetails=_userVmDetailsDao.listDetailsKeyPairs(vm.getId());
    if (userVmDetails != null) {
      String minIops=userVmDetails.get("minIops");
      String maxIops=userVmDetails.get("maxIops");
      rootDiskOfferingInfo.setMinIops(minIops != null && minIops.trim().length() > 0 ? Long.parseLong(minIops) : null);
      rootDiskOfferingInfo.setMaxIops(maxIops != null && maxIops.trim().length() > 0 ? Long.parseLong(maxIops) : null);
    }
  }
  if (vm.getDiskOfferingId() != null) {
    DiskOfferingVO diskOffering=_diskOfferingDao.findById(vm.getDiskOfferingId());
    if (diskOffering == null) {
      throw new InvalidParameterValueException("Unable to find disk offering " + vm.getDiskOfferingId());
    }
    Long size=null;
    if (diskOffering.getDiskSize() == 0) {
      size=diskSize;
      if (size == null) {
        throw new InvalidParameterValueException("Disk offering " + diskOffering + " requires size parameter.");
      }
      _volumeMgr.validateVolumeSizeRange(size * 1024 * 1024* 1024);
    }
    DiskOfferingInfo dataDiskOfferingInfo=new DiskOfferingInfo();
    dataDiskOfferingInfo.setDiskOffering(diskOffering);
    dataDiskOfferingInfo.setSize(size);
    if (diskOffering.isCustomizedIops() != null && diskOffering.isCustomizedIops()) {
      Map<String,String> userVmDetails=_userVmDetailsDao.listDetailsKeyPairs(vm.getId());
      if (userVmDetails != null) {
        String minIops=userVmDetails.get("minIopsDo");
        String maxIops=userVmDetails.get("maxIopsDo");
        dataDiskOfferingInfo.setMinIops(minIops != null && minIops.trim().length() > 0 ? Long.parseLong(minIops) : null);
        dataDiskOfferingInfo.setMaxIops(maxIops != null && maxIops.trim().length() > 0 ? Long.parseLong(maxIops) : null);
      }
    }
    dataDiskOfferings.add(dataDiskOfferingInfo);
  }
  _itMgr.allocate(vm.getInstanceName(),_templateDao.findById(new Long(templateId)),computeOffering,rootDiskOfferingInfo,dataDiskOfferings,networkIpMap,plan,hypervisorType);
  return vmEntity;
}

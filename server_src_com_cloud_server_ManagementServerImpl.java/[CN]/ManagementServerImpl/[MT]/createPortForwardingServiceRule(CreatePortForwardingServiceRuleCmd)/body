{
  NetworkRuleConfigVO rule=null;
  try {
    Long securityGroupId=cmd.getPortForwardingServiceId();
    String port=cmd.getPublicPort();
    String privatePort=cmd.getPrivatePort();
    String protocol=cmd.getProtocol();
    Long userId=UserContext.current().getUserId();
    if (userId == null) {
      userId=Long.valueOf(User.UID_SYSTEM);
    }
    SecurityGroupVO sg=_securityGroupDao.findById(Long.valueOf(securityGroupId));
    if (sg == null) {
      throw new InvalidParameterValueException("port forwarding service " + securityGroupId + " does not exist");
    }
    if (!NetUtils.isValidPort(port)) {
      throw new InvalidParameterValueException("port is an invalid value");
    }
    if (!NetUtils.isValidPort(privatePort)) {
      throw new InvalidParameterValueException("privatePort is an invalid value");
    }
    if (protocol != null) {
      if (!NetUtils.isValidProto(protocol)) {
        throw new InvalidParameterValueException("Invalid protocol");
      }
    }
 else {
      protocol="TCP";
    }
    Account account=(Account)UserContext.current().getAccountObject();
    if (account != null) {
      if (isAdmin(account.getType())) {
        if (!_domainDao.isChildDomain(account.getDomainId(),sg.getDomainId())) {
          throw new PermissionDeniedException("Unable to find rules for port forwarding service id = " + securityGroupId + ", permission denied.");
        }
      }
 else       if (account.getId().longValue() != sg.getAccountId().longValue()) {
        throw new PermissionDeniedException("Invalid port forwarding service (" + securityGroupId + ") given, unable to create rule.");
      }
    }
    List<NetworkRuleConfigVO> existingRules=_networkRuleConfigDao.listBySecurityGroupId(securityGroupId);
    for (    NetworkRuleConfigVO existingRule : existingRules) {
      if (existingRule.getPublicPort().equals(port) && existingRule.getProtocol().equals(protocol)) {
        throw new NetworkRuleConflictException("port conflict, port forwarding service contains a rule on public port " + port + " for protocol "+ protocol);
      }
    }
    NetworkRuleConfigVO netRule=new NetworkRuleConfigVO(securityGroupId,port,privatePort,protocol);
    netRule.setCreateStatus(AsyncInstanceCreateStatus.Creating);
    rule=_networkRuleConfigDao.persist(netRule);
  }
 catch (  Exception e) {
    if (e instanceof NetworkRuleConflictException) {
      throw (NetworkRuleConflictException)e;
    }
 else     if (e instanceof InvalidParameterValueException) {
      throw (InvalidParameterValueException)e;
    }
 else     if (e instanceof PermissionDeniedException) {
      throw (PermissionDeniedException)e;
    }
 else     if (e instanceof InternalErrorException) {
      throw (InternalErrorException)e;
    }
 else {
      s_logger.error("Unhandled exception creating or updating network rule",e);
      throw new CloudRuntimeException("Unhandled exception creating network rule",e);
    }
  }
  return rule;
}

{
  CertificateVO cert=null;
  Long certVOId=null;
  try {
    Transaction.currentTxn();
    String certificate=cmd.getCertificate();
    cert=_certDao.listAll().get(0);
    cert=_certDao.acquireInLockTable(cert.getId());
    if (cert == null) {
      String msg="Unable to obtain lock on the cert from uploadCertificate()";
      s_logger.error(msg);
      throw new ResourceUnavailableException(msg);
    }
 else {
      if (cert.getUpdated().equalsIgnoreCase("Y")) {
        if (s_logger.isDebugEnabled())         s_logger.debug("A custom certificate already exists in the DB, will replace it with the new one being uploaded");
      }
 else {
        if (s_logger.isDebugEnabled())         s_logger.debug("No custom certificate exists in the DB, will upload a new one");
      }
      InputStream is=new ByteArrayInputStream(certificate.getBytes("UTF-8"));
      BufferedInputStream bis=new BufferedInputStream(is);
      CertificateFactory cf=CertificateFactory.getInstance("X.509");
      while (bis.available() > 1) {
        Certificate localCert=cf.generateCertificate(bis);
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("The custom certificate generated for validation is:" + localCert.toString());
        }
      }
      certVOId=_certDao.persistCustomCertToDb(certificate,cert,this.getId());
      if (s_logger.isDebugEnabled())       s_logger.debug("Custom certificate persisted to the DB");
    }
    if (certVOId != 0) {
      List<ConsoleProxyVO> cpList=_consoleProxyDao.listAll();
      if (cpList.size() == 0) {
        String msg="Unable to find any console proxies in the system for certificate update";
        s_logger.warn(msg);
        throw new ResourceUnavailableException(msg);
      }
      List<HostVO> cpHosts=_hostDao.listByType(com.cloud.host.Host.Type.ConsoleProxy);
      if (cpHosts.size() == 0) {
        String msg="Unable to find any console proxy hosts in the system for certificate update";
        s_logger.warn(msg);
        throw new ResourceUnavailableException(msg);
      }
      Map<String,Long> hostNameToHostIdMap=new HashMap<String,Long>();
      List<Long> updatedCpIdList=new ArrayList<Long>();
      for (      HostVO cpHost : cpHosts) {
        hostNameToHostIdMap.put(cpHost.getName(),cpHost.getId());
      }
      for (      ConsoleProxyVO cp : cpList) {
        Long cpHostId=hostNameToHostIdMap.get(cp.getHostName());
        UpdateCertificateCommand certCmd=new UpdateCertificateCommand(_certDao.findById(certVOId).getCertificate(),false);
        try {
          Answer updateCertAns=_agentMgr.send(cpHostId,certCmd);
          if (updateCertAns.getResult() == true) {
            long eventId=saveScheduledEvent(User.UID_SYSTEM,Account.ACCOUNT_ID_SYSTEM,EventTypes.EVENT_PROXY_REBOOT,"rebooting console proxy with Id: " + cp.getId());
            _consoleProxyMgr.rebootProxy(cp.getId(),eventId);
            if (s_logger.isDebugEnabled())             s_logger.debug("Successfully updated custom certificate on console proxy vm id:" + cp.getId() + " ,console proxy host id:"+ cpHostId);
            updatedCpIdList.add(cp.getId());
          }
        }
 catch (        AgentUnavailableException e) {
          s_logger.warn("Unable to send update certificate command to the console proxy resource as agent is unavailable for console proxy vm id:" + cp.getId() + " ,console proxy host id:"+ cpHostId,e);
        }
catch (        OperationTimedoutException e) {
          s_logger.warn("Unable to send update certificate command to the console proxy resource as there was a timeout for console proxy vm id:" + cp.getId() + " ,console proxy host id:"+ cpHostId,e);
        }
      }
      if (updatedCpIdList.size() == cpList.size()) {
        return ("Updated:" + updatedCpIdList.size() + " out of:"+ cpList.size()+ " console proxies");
      }
 else {
        throw new ManagementServerException("Updated:" + updatedCpIdList.size() + " out of:"+ cpList.size()+ " console proxies with successfully updated console proxy ids being:"+ (updatedCpIdList.size() > 0 ? updatedCpIdList.toString() : ""));
      }
    }
 else {
      throw new ManagementServerException("Unable to persist custom certificate to the cloud db");
    }
  }
 catch (  Exception e) {
    s_logger.warn("Failed to successfully update the cert across console proxies on management server:" + this.getId());
    if (e instanceof ResourceUnavailableException)     throw new ServerApiException(BaseCmd.CUSTOM_CERT_UPDATE_ERROR,e.getMessage());
    if (e instanceof ManagementServerException)     throw new ServerApiException(BaseCmd.CUSTOM_CERT_UPDATE_ERROR,e.getMessage());
    if (e instanceof IndexOutOfBoundsException) {
      String msg="Custom certificate record in the db deleted; this should never happen. Please create a new record in the certificate table";
      s_logger.error(msg,e);
      throw new ServerApiException(BaseCmd.CUSTOM_CERT_UPDATE_ERROR,msg);
    }
    if (e instanceof FileNotFoundException) {
      String msg="Invalid file path for custom cert found during cert validation";
      s_logger.error(msg,e);
      throw new ServerApiException(BaseCmd.CUSTOM_CERT_UPDATE_ERROR,msg);
    }
    if (e instanceof CertificateException) {
      String msg="The file format for custom cert does not conform to the X.509 specification";
      s_logger.error(msg,e);
      throw new ServerApiException(BaseCmd.CUSTOM_CERT_UPDATE_ERROR,msg);
    }
    if (e instanceof UnsupportedEncodingException) {
      String msg="Unable to encode the certificate into UTF-8 input stream for validation";
      s_logger.error(msg,e);
      throw new ServerApiException(BaseCmd.CUSTOM_CERT_UPDATE_ERROR,msg);
    }
    if (e instanceof IOException) {
      String msg="Cannot generate input stream during custom cert validation";
      s_logger.error(msg,e);
      throw new ServerApiException(BaseCmd.CUSTOM_CERT_UPDATE_ERROR,msg);
    }
  }
 finally {
    _certDao.releaseFromLockTable(cert.getId());
  }
  return null;
}

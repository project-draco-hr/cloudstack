{
  Long userId=UserContext.current().getUserId();
  Account account=(Account)UserContext.current().getAccountObject();
  Long securityGroupId=cmd.getId();
  List<Long> sgIdList=cmd.getIds();
  String publicIp=cmd.getPublicIp();
  Long vmId=cmd.getVirtualMachineId();
  if ((securityGroupId == null) && (sgIdList == null)) {
    throw new ServerApiException(BaseCmd.PARAM_ERROR,"No service id (or list of ids) specified.");
  }
  if (userId == null) {
    userId=Long.valueOf(1);
  }
  List<Long> validateSGList=null;
  if (securityGroupId == null) {
    validateSGList=sgIdList;
  }
 else {
    validateSGList=new ArrayList<Long>();
    validateSGList.add(securityGroupId);
  }
  Long validatedAccountId=validateSecurityGroupsAndInstance(validateSGList,vmId);
  if (validatedAccountId == null) {
    throw new ServerApiException(BaseCmd.PARAM_ERROR,"Unable to apply port forwarding services " + StringUtils.join(sgIdList,",") + " to instance "+ vmId+ ".  Invalid list of port forwarding services for the given instance.");
  }
  if (account != null) {
    if (!isAdmin(account.getType()) && (account.getId() != validatedAccountId.longValue())) {
      throw new ServerApiException(BaseCmd.ACCOUNT_ERROR,"Permission denied applying port forwarding services " + StringUtils.join(sgIdList,",") + " to instance "+ vmId+ ".");
    }
 else {
      Account validatedAccount=findAccountById(validatedAccountId);
      if (!isChildDomain(account.getDomainId(),validatedAccount.getDomainId())) {
        throw new ServerApiException(BaseCmd.ACCOUNT_ERROR,"Permission denied applying port forwarding services " + StringUtils.join(sgIdList,",") + " to instance "+ vmId+ ".");
      }
    }
  }
  UserVm userVm=_userVmDao.findById(vmId);
  if (userVm == null) {
    s_logger.warn("Unable to find virtual machine with id " + vmId);
    throw new InvalidParameterValueException("Unable to find virtual machine with id " + vmId);
  }
  long startEventId=EventUtils.saveScheduledEvent(userId,userVm.getAccountId(),EventTypes.EVENT_PORT_FORWARDING_SERVICE_APPLY,"applying port forwarding service for Vm with Id: " + vmId);
  boolean locked=false;
  Transaction txn=Transaction.currentTxn();
  try {
    EventUtils.saveStartedEvent(userId,userVm.getAccountId(),EventTypes.EVENT_PORT_FORWARDING_SERVICE_APPLY,"Applying port forwarding service for Vm with Id: " + vmId,startEventId);
    State vmState=userVm.getState();
switch (vmState) {
case Destroyed:
case Error:
case Expunging:
case Unknown:
      throw new InvalidParameterValueException("Unable to assign port forwarding service(s) '" + ((securityGroupId == null) ? StringUtils.join(sgIdList,",") : securityGroupId) + "' to virtual machine "+ vmId+ " due to virtual machine being in an invalid state for assigning a port forwarding service ("+ vmState+ ")");
  }
  ServiceOfferingVO offering=_offeringsDao.findById(userVm.getServiceOfferingId());
  if ((offering == null) || !NetworkOffering.GuestIpType.Virtualized.equals(offering.getGuestIpType())) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Unable to apply port forwarding service to virtual machine " + userVm.toString() + ", bad network type ("+ ((offering == null) ? "null" : offering.getGuestIpType())+ ")");
    }
    throw new InvalidParameterValueException("Unable to apply port forwarding service to virtual machine " + userVm.toString() + ", bad network type ("+ ((offering == null) ? "null" : offering.getGuestIpType())+ ")");
  }
  DomainRouterVO router=null;
  if (userVm.getDomainRouterId() != null)   router=_routerDao.findById(userVm.getDomainRouterId());
  if (router == null) {
    s_logger.warn("Unable to find router (" + userVm.getDomainRouterId() + ") for virtual machine "+ userVm.toString());
    throw new InvalidParameterValueException("Unable to find router (" + userVm.getDomainRouterId() + ") for virtual machine with id "+ vmId);
  }
  IPAddressVO ipVO=_publicIpAddressDao.acquire(publicIp);
  if (ipVO == null) {
    throw new PermissionDeniedException("User does not own supplied address");
  }
  locked=true;
  if ((ipVO.getAllocated() == null) || (ipVO.getAccountId() == null) || (ipVO.getAccountId().longValue() != userVm.getAccountId())) {
    throw new PermissionDeniedException("User does not own supplied address");
  }
  VlanVO vlan=_vlanDao.findById(ipVO.getVlanDbId());
  if (!VlanType.VirtualNetwork.equals(vlan.getVlanType())) {
    throw new InvalidParameterValueException("Invalid IP address " + publicIp + " for applying port forwarding services, the IP address is not in a 'virtual network' vlan.");
  }
  txn.start();
  if (securityGroupId == null) {
    List<FirewallRuleVO> fwRulesToRemove=_firewallRulesDao.listForwardingByPubAndPrivIp(true,publicIp,userVm.getGuestIpAddress());
{
      String description;
      String type=EventTypes.EVENT_NET_RULE_DELETE;
      String level=EventVO.LEVEL_INFO;
      for (      FirewallRuleVO fwRule : fwRulesToRemove) {
        fwRule.setEnabled(false);
        _firewallRulesDao.remove(fwRule.getId());
        description="deleted ip forwarding rule [" + fwRule.getPublicIpAddress() + ":"+ fwRule.getPublicPort()+ "]->["+ fwRule.getPrivateIpAddress()+ ":"+ fwRule.getPrivatePort()+ "]"+ " "+ fwRule.getProtocol();
        EventUtils.saveEvent(userId,userVm.getAccountId(),level,type,description);
      }
    }
    List<FirewallRuleVO> updatedRules=_networkMgr.updateFirewallRules(null,fwRulesToRemove,router);
    if ((updatedRules != null) && (updatedRules.size() != fwRulesToRemove.size())) {
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Unable to clean up all port forwarding service rules for public IP " + publicIp + " and guest vm "+ userVm.getName()+ " while applying port forwarding service(s) '"+ ((securityGroupId == null) ? StringUtils.join(sgIdList,",") : securityGroupId)+ "'"+ " -- intended to remove "+ fwRulesToRemove.size()+ " rules, removd "+ ((updatedRules == null) ? "null" : updatedRules.size())+ " rules.");
      }
    }
    List<SecurityGroupVMMapVO> sgVmMappings=_securityGroupVMMapDao.listByIpAndInstanceId(publicIp,vmId);
    for (    SecurityGroupVMMapVO sgVmMapping : sgVmMappings) {
      boolean success=_securityGroupVMMapDao.remove(sgVmMapping.getId());
      SecurityGroupVO securityGroup=_securityGroupDao.findById(sgVmMapping.getSecurityGroupId());
      EventVO event=new EventVO();
      event.setUserId(userId);
      event.setAccountId(userVm.getAccountId());
      event.setType(EventTypes.EVENT_PORT_FORWARDING_SERVICE_REMOVE);
      String sgRemoveLevel=EventVO.LEVEL_INFO;
      String sgRemoveDesc="Successfully removed ";
      if (!success) {
        sgRemoveLevel=EventVO.LEVEL_ERROR;
        sgRemoveDesc="Failed to remove ";
      }
      String params="sgId=" + securityGroup.getId() + "\nvmId="+ vmId;
      event.setParameters(params);
      event.setDescription(sgRemoveDesc + "port forwarding service " + securityGroup.getName()+ " from virtual machine "+ userVm.getName());
      event.setLevel(sgRemoveLevel);
      _eventDao.persist(event);
    }
  }
 else {
    List<SecurityGroupVMMapVO> existingVMMaps=_securityGroupVMMapDao.listBySecurityGroup(securityGroupId.longValue());
    if ((existingVMMaps != null) && !existingVMMaps.isEmpty()) {
      for (      SecurityGroupVMMapVO existingVMMap : existingVMMaps) {
        if (existingVMMap.getInstanceId() == userVm.getId()) {
          if (s_logger.isDebugEnabled()) {
            s_logger.debug("port forwarding service " + securityGroupId + " is already applied to virtual machine "+ userVm.toString()+ ", skipping assignment.");
          }
          return;
        }
      }
    }
  }
  List<Long> finalSecurityGroupIdList=new ArrayList<Long>();
  if (securityGroupId != null) {
    finalSecurityGroupIdList.add(securityGroupId);
  }
 else {
    finalSecurityGroupIdList.addAll(sgIdList);
  }
  for (  Long sgId : finalSecurityGroupIdList) {
    if (sgId.longValue() == 0) {
      break;
    }
    SecurityGroupVO securityGroup=_securityGroupDao.findById(Long.valueOf(sgId));
    if (securityGroup == null) {
      s_logger.warn("Unable to find port forwarding service with id " + sgId);
      throw new InvalidParameterValueException("Unable to find port forwarding service with id " + sgId);
    }
    if (!_domainDao.isChildDomain(securityGroup.getDomainId(),userVm.getDomainId())) {
      s_logger.warn("Unable to assign port forwarding service " + sgId + " to user vm "+ vmId+ ", user vm's domain ("+ userVm.getDomainId()+ ") is not in the domain of the port forwarding service ("+ securityGroup.getDomainId()+ ")");
      throw new InvalidParameterValueException("Unable to assign port forwarding service " + sgId + " to user vm "+ vmId+ ", user vm's domain ("+ userVm.getDomainId()+ ") is not in the domain of the port forwarding service ("+ securityGroup.getDomainId()+ ")");
    }
    List<FirewallRuleVO> existingRulesOnPubIp=_firewallRulesDao.listIPForwarding(publicIp);
    Map<String,Pair<String,String>> mappedPublicPorts=new HashMap<String,Pair<String,String>>();
    if (existingRulesOnPubIp != null) {
      for (      FirewallRuleVO fwRule : existingRulesOnPubIp) {
        mappedPublicPorts.put(fwRule.getPublicPort(),new Pair<String,String>(fwRule.getPrivateIpAddress(),fwRule.getPrivatePort()));
      }
    }
    List<LoadBalancerVO> loadBalancers=_loadBalancerDao.listByIpAddress(publicIp);
    if (loadBalancers != null) {
      for (      LoadBalancerVO loadBalancer : loadBalancers) {
        mappedPublicPorts.put(loadBalancer.getPublicPort(),new Pair<String,String>("",""));
      }
    }
    List<FirewallRuleVO> firewallRulesToApply=new ArrayList<FirewallRuleVO>();
    List<NetworkRuleConfigVO> netRules=_networkRuleConfigDao.listBySecurityGroupId(sgId);
    for (    NetworkRuleConfigVO netRule : netRules) {
      Pair<String,String> privateIpPort=mappedPublicPorts.get(netRule.getPublicPort());
      if (privateIpPort != null) {
        if (privateIpPort.first().equals(userVm.getGuestIpAddress()) && privateIpPort.second().equals(netRule.getPrivatePort())) {
          continue;
        }
 else {
          throw new NetworkRuleConflictException("An existing service rule for " + publicIp + ":"+ netRule.getPublicPort()+ " already exists, found while trying to apply service rule "+ netRule.getId()+ " from port forwarding service "+ securityGroup.getName()+ ".");
        }
      }
      FirewallRuleVO newFwRule=new FirewallRuleVO();
      newFwRule.setEnabled(true);
      newFwRule.setForwarding(true);
      newFwRule.setPrivatePort(netRule.getPrivatePort());
      newFwRule.setProtocol(netRule.getProtocol());
      newFwRule.setPublicPort(netRule.getPublicPort());
      newFwRule.setPublicIpAddress(publicIp);
      newFwRule.setPrivateIpAddress(userVm.getGuestIpAddress());
      newFwRule.setGroupId(netRule.getSecurityGroupId());
      firewallRulesToApply.add(newFwRule);
      _firewallRulesDao.persist(newFwRule);
      String description="created new ip forwarding rule [" + newFwRule.getPublicIpAddress() + ":"+ newFwRule.getPublicPort()+ "]->["+ newFwRule.getPrivateIpAddress()+ ":"+ newFwRule.getPrivatePort()+ "]"+ " "+ newFwRule.getProtocol();
      EventUtils.saveEvent(userId,account.getId(),EventVO.LEVEL_INFO,EventTypes.EVENT_NET_RULE_ADD,description);
    }
    SecurityGroupVMMapVO sgVmMap=new SecurityGroupVMMapVO(sgId,publicIp,vmId);
    _securityGroupVMMapDao.persist(sgVmMap);
    EventVO event=new EventVO();
    event.setUserId(userId);
    event.setAccountId(userVm.getAccountId());
    event.setType(EventTypes.EVENT_PORT_FORWARDING_SERVICE_APPLY);
    event.setStartId(startEventId);
    event.setDescription("Successfully applied port forwarding service " + securityGroup.getName() + " to virtual machine "+ userVm.getName());
    String params="sgId=" + securityGroup.getId() + "\nvmId="+ vmId+ "\nnumRules="+ firewallRulesToApply.size()+ "\ndcId="+ userVm.getDataCenterId();
    event.setParameters(params);
    event.setLevel(EventVO.LEVEL_INFO);
    _eventDao.persist(event);
    _networkMgr.updateFirewallRules(publicIp,firewallRulesToApply,router);
  }
  txn.commit();
}
 catch (Throwable e) {
  txn.rollback();
  if (e instanceof NetworkRuleConflictException) {
    throw (NetworkRuleConflictException)e;
  }
 else   if (e instanceof InvalidParameterValueException) {
    throw (InvalidParameterValueException)e;
  }
 else   if (e instanceof PermissionDeniedException) {
    throw (PermissionDeniedException)e;
  }
 else   if (e instanceof InternalErrorException) {
    s_logger.warn("ManagementServer error",e);
    throw (InternalErrorException)e;
  }
  s_logger.warn("ManagementServer error",e);
}
 finally {
  if (locked) {
    _publicIpAddressDao.release(publicIp);
  }
}
}

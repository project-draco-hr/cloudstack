{
  if (!_enabled) {
    return null;
  }
  final Transaction txn=Transaction.currentTxn();
  final Long accountId=account.getId();
  final Set<NetworkGroupVO> authorizedGroups2=new TreeSet<NetworkGroupVO>(new NetworkGroupVOComparator());
  authorizedGroups2.addAll(authorizedGroups);
  txn.start();
  NetworkGroupVO networkGroup=_networkGroupDao.findByAccountAndName(accountId,groupName);
  if (networkGroup == null) {
    s_logger.warn("Network security group not found: name= " + groupName);
    return null;
  }
  NetworkGroupVO networkGroupLock=_networkGroupDao.acquire(networkGroup.getId());
  if (networkGroupLock == null) {
    s_logger.warn("Could not acquire lock on network security group: name= " + groupName);
    return null;
  }
  List<IngressRuleVO> newRules=new ArrayList<IngressRuleVO>();
  try {
    networkGroup=_networkGroupDao.lock(networkGroup.getId(),false);
    if (networkGroup == null) {
      s_logger.warn("Could not acquire lock on network group " + groupName);
      return null;
    }
    for (    final NetworkGroupVO ngVO : authorizedGroups2) {
      final Long ngId=ngVO.getId();
      if (ngVO.getId() != networkGroup.getId()) {
        final NetworkGroupVO tmpGrp=_networkGroupDao.lock(ngId,false);
        if (tmpGrp == null) {
          s_logger.warn("Failed to acquire lock on network group: " + ngId);
          txn.rollback();
          return null;
        }
      }
      IngressRuleVO ingressRule=_ingressRuleDao.findByProtoPortsAndAllowedGroupId(networkGroup.getId(),protocol,startPort,endPort,ngVO.getId());
      if (ingressRule != null) {
        continue;
      }
      ingressRule=new IngressRuleVO(networkGroup.getId(),startPort,endPort,protocol,ngVO.getId(),ngVO.getName(),ngVO.getAccountName());
      ingressRule=_ingressRuleDao.persist(ingressRule);
      newRules.add(ingressRule);
    }
    for (    String cidr : cidrList) {
      IngressRuleVO ingressRule=_ingressRuleDao.findByProtoPortsAndCidr(networkGroup.getId(),protocol,startPort,endPort,cidr);
      if (ingressRule != null) {
        continue;
      }
      ingressRule=new IngressRuleVO(networkGroup.getId(),startPort,endPort,protocol,cidr);
      ingressRule=_ingressRuleDao.persist(ingressRule);
      newRules.add(ingressRule);
    }
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Added " + newRules.size() + " rules to network group "+ groupName);
    }
    txn.commit();
    final Set<Long> affectedVms=new HashSet<Long>();
    affectedVms.addAll(_networkGroupVMMapDao.listVmIdsByNetworkGroup(networkGroup.getId()));
    scheduleRulesetUpdateToHosts(affectedVms,true,null);
    return newRules;
  }
 catch (  Exception e) {
    s_logger.warn("Exception caught when adding ingress rules ",e);
    throw new CloudRuntimeException("Exception caught when adding ingress rules",e);
  }
 finally {
    if (networkGroupLock != null) {
      _networkGroupDao.release(networkGroupLock.getId());
    }
  }
}

{
  Account account=(Account)UserContext.current().getAccountObject();
  Long userId=UserContext.current().getUserId();
  Long domainId=cmd.getDomainId();
  Integer startPort=cmd.getStartPort();
  Integer endPort=cmd.getEndPort();
  Integer icmpType=cmd.getIcmpType();
  Integer icmpCode=cmd.getIcmpCode();
  String protocol=cmd.getProtocol();
  String networkGroup=cmd.getNetworkGroupName();
  String cidrList=cmd.getCidrList();
  Map groupList=cmd.getUserNetworkGroupList();
  String[] cidrs=null;
  Long accountId=null;
  Integer startPortOrType=null;
  Integer endPortOrCode=null;
  if (protocol == null) {
    protocol="all";
  }
  if (!NetUtils.isValidNetworkGroupProto(protocol)) {
    s_logger.debug("Invalid protocol specified " + protocol);
    throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid protocol " + protocol);
  }
  if ("icmp".equalsIgnoreCase(protocol)) {
    if ((icmpType == null) || (icmpCode == null)) {
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid ICMP type/code specified, icmpType = " + icmpType + ", icmpCode = "+ icmpCode);
    }
    if (icmpType == -1 && icmpCode != -1) {
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid icmp type range");
    }
    if (icmpCode > 255) {
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid icmp code ");
    }
    startPortOrType=icmpType;
    endPortOrCode=icmpCode;
  }
 else   if (protocol.equals("all")) {
    if ((startPort != null) || (endPort != null)) {
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Cannot specify startPort or endPort without specifying protocol");
    }
    startPortOrType=0;
    endPortOrCode=0;
  }
 else {
    if ((startPort == null) || (endPort == null)) {
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid port range specified, startPort = " + startPort + ", endPort = "+ endPort);
    }
    if (startPort == 0 && endPort == 0) {
      endPort=65535;
    }
    if (startPort > endPort) {
      s_logger.debug("Invalid port range specified: " + startPort + ":"+ endPort);
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid port range ");
    }
    if (startPort > 65535 || endPort > 65535 || startPort < -1 || endPort < -1) {
      s_logger.debug("Invalid port numbers specified: " + startPort + ":"+ endPort);
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid port numbers ");
    }
    if (startPort < 0 || endPort < 0) {
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid port range ");
    }
    startPortOrType=startPort;
    endPortOrCode=endPort;
  }
  if ((account == null) || isAdmin(account.getType())) {
    if ((account.getAccountName() != null) && (domainId != null)) {
      if ((account != null) && !_domainDao.isChildDomain(account.getDomainId(),domainId)) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Unable to find rules for network security group id = " + networkGroup + ", permission denied.");
        }
        throw new ServerApiException(BaseCmd.ACCOUNT_ERROR,"Unable to find rules for network security group id = " + networkGroup + ", permission denied.");
      }
      Account groupOwner=_accountDao.findActiveAccount(account.getAccountName(),domainId);
      if (groupOwner == null) {
        throw new ServerApiException(BaseCmd.PARAM_ERROR,"Unable to find account " + account.getAccountName() + " in domain "+ domainId);
      }
      accountId=groupOwner.getId();
    }
 else {
      if (account != null) {
        accountId=account.getId();
        domainId=account.getDomainId();
      }
    }
  }
 else {
    if (account != null) {
      accountId=account.getId();
      domainId=account.getDomainId();
    }
  }
  if (accountId == null) {
    throw new ServerApiException(BaseCmd.PARAM_ERROR,"Unable to find account for network security group " + networkGroup + "; failed to revoke ingress.");
  }
  NetworkGroupVO sg=_networkGroupDao.findByAccountAndName(accountId,networkGroup);
  if (sg == null) {
    s_logger.debug("Unable to find network security group with id " + networkGroup);
    throw new ServerApiException(BaseCmd.PARAM_ERROR,"Unable to find network security group with id " + networkGroup);
  }
  if (cidrList == null && groupList == null) {
    s_logger.debug("At least one cidr or at least one security group needs to be specified");
    throw new ServerApiException(BaseCmd.PARAM_ERROR,"At least one cidr or at least one security group needs to be specified");
  }
  List<String> authorizedCidrs=new ArrayList<String>();
  if (cidrList != null) {
    if (protocol.equals("all")) {
      throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Cannot specify cidrs without specifying protocol and ports.");
    }
    cidrs=cidrList.split(",");
    for (    String cidr : cidrs) {
      if (!NetUtils.isValidCIDR(cidr)) {
        s_logger.debug("Invalid cidr (" + cidr + ") given, unable to revoke ingress.");
        throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid cidr (" + cidr + ") given, unable to revoke ingress.");
      }
      authorizedCidrs.add(cidr);
    }
  }
  List<NetworkGroupVO> authorizedGroups=new ArrayList<NetworkGroupVO>();
  if (groupList != null) {
    Collection userGroupCollection=groupList.values();
    Iterator iter=userGroupCollection.iterator();
    while (iter.hasNext()) {
      HashMap userGroup=(HashMap)iter.next();
      String group=(String)userGroup.get("group");
      String authorizedAccountName=(String)userGroup.get("account");
      if ((group == null) || (authorizedAccountName == null)) {
        throw new ServerApiException(BaseCmd.PARAM_ERROR,"Invalid user group specified, fields 'group' and 'account' cannot be null, please specify groups in the form:  userGroupList[0].group=XXX&userGroupList[0].account=YYY");
      }
      Account authorizedAccount=_accountDao.findActiveAccount(authorizedAccountName,domainId);
      if (authorizedAccount == null) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Nonexistent account: " + authorizedAccountName + ", domainid: "+ domainId+ " when trying to revoke ingress for "+ networkGroup+ ":"+ protocol+ ":"+ startPortOrType+ ":"+ endPortOrCode);
        }
        throw new ServerApiException(BaseCmd.PARAM_ERROR,"Nonexistent account: " + authorizedAccountName + " when trying to revoke ingress for "+ networkGroup+ ":"+ protocol+ ":"+ startPortOrType+ ":"+ endPortOrCode);
      }
      NetworkGroupVO groupVO=_networkGroupDao.findByAccountAndName(authorizedAccount.getId(),group);
      if (groupVO == null) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Nonexistent group and/or accountId: " + accountId + ", groupName="+ group);
        }
        throw new ServerApiException(BaseCmd.NET_INVALID_PARAM_ERROR,"Invalid account/group pair  (" + userGroup + ") given, unable to revoke ingress.");
      }
      authorizedGroups.add(groupVO);
    }
  }
  if (userId == null) {
    userId=Long.valueOf(1);
  }
  if (!_enabled) {
    return false;
  }
  int numDeleted=0;
  final int numToDelete=cidrList.length() + authorizedGroups.size();
  final Transaction txn=Transaction.currentTxn();
  NetworkGroupVO networkGroupHandle=_networkGroupDao.findByAccountAndName(accountId,networkGroup);
  if (networkGroupHandle == null) {
    s_logger.warn("Network security group not found: name= " + networkGroup);
    return false;
  }
  try {
    txn.start();
    networkGroupHandle=_networkGroupDao.acquire(networkGroupHandle.getId());
    if (networkGroupHandle == null) {
      s_logger.warn("Could not acquire lock on network security group: name= " + networkGroup);
      return false;
    }
    for (    final NetworkGroupVO ngVO : authorizedGroups) {
      numDeleted+=_ingressRuleDao.deleteByPortProtoAndGroup(networkGroupHandle.getId(),protocol,startPort,endPort,ngVO.getId());
    }
    for (    final String cidr : cidrs) {
      numDeleted+=_ingressRuleDao.deleteByPortProtoAndCidr(networkGroupHandle.getId(),protocol,startPort,endPort,cidr);
    }
    s_logger.debug("revokeNetworkGroupIngress for group: " + networkGroup + ", numToDelete="+ numToDelete+ ", numDeleted="+ numDeleted);
    final Set<Long> affectedVms=new HashSet<Long>();
    affectedVms.addAll(_networkGroupVMMapDao.listVmIdsByNetworkGroup(networkGroupHandle.getId()));
    scheduleRulesetUpdateToHosts(affectedVms,true,null);
    return true;
  }
 catch (  Exception e) {
    s_logger.warn("Exception caught when deleting ingress rules ",e);
    throw new CloudRuntimeException("Exception caught when deleting ingress rules",e);
  }
 finally {
    if (networkGroup != null) {
      _networkGroupDao.release(networkGroupHandle.getId());
    }
    txn.commit();
  }
}

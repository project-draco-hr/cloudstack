{
  if (!_enabled) {
    return false;
  }
  int numDeleted=0;
  final int numToDelete=cidrList.length + authorizedGroups.size();
  final Transaction txn=Transaction.currentTxn();
  final Long accountId=account.getId();
  NetworkGroupVO networkGroup=_networkGroupDao.findByAccountAndName(accountId,groupName);
  if (networkGroup == null) {
    s_logger.warn("Network security group not found: name= " + groupName);
    return false;
  }
  try {
    txn.start();
    networkGroup=_networkGroupDao.acquire(networkGroup.getId());
    if (networkGroup == null) {
      s_logger.warn("Could not acquire lock on network security group: name= " + groupName);
      return false;
    }
    for (    final NetworkGroupVO ngVO : authorizedGroups) {
      numDeleted+=_ingressRuleDao.deleteByPortProtoAndGroup(networkGroup.getId(),protocol,startPort,endPort,ngVO.getId());
    }
    for (    final String cidr : cidrList) {
      numDeleted+=_ingressRuleDao.deleteByPortProtoAndCidr(networkGroup.getId(),protocol,startPort,endPort,cidr);
    }
    s_logger.debug("revokeNetworkGroupIngress for group: " + groupName + ", numToDelete="+ numToDelete+ ", numDeleted="+ numDeleted);
    final Set<Long> affectedVms=new HashSet<Long>();
    affectedVms.addAll(_networkGroupVMMapDao.listVmIdsByNetworkGroup(networkGroup.getId()));
    scheduleRulesetUpdateToHosts(affectedVms,true,null);
    return true;
  }
 catch (  Exception e) {
    s_logger.warn("Exception caught when deleting ingress rules ",e);
    throw new CloudRuntimeException("Exception caught when deleting ingress rules",e);
  }
 finally {
    if (networkGroup != null) {
      _networkGroupDao.release(networkGroup.getId());
    }
    txn.commit();
  }
}

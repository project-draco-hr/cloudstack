{
  int bytesPerRow=(width + 7) / 8;
  int bytesMaskData=bytesPerRow * height;
  int[] softCursorPixels=new int[width * height];
  if (encodingType == rfb.EncodingXCursor) {
    byte[] rgb=new byte[6];
    rfb.readFully(rgb);
    int[] colors={(0xFF000000 | (rgb[3] & 0xFF) << 16 | (rgb[4] & 0xFF) << 8 | (rgb[5] & 0xFF)),(0xFF000000 | (rgb[0] & 0xFF) << 16 | (rgb[1] & 0xFF) << 8 | (rgb[2] & 0xFF))};
    byte[] pixBuf=new byte[bytesMaskData];
    rfb.readFully(pixBuf);
    byte[] maskBuf=new byte[bytesMaskData];
    rfb.readFully(maskBuf);
    byte pixByte, maskByte;
    int x, y, n, result;
    int i=0;
    for (y=0; y < height; y++) {
      for (x=0; x < width / 8; x++) {
        pixByte=pixBuf[y * bytesPerRow + x];
        maskByte=maskBuf[y * bytesPerRow + x];
        for (n=7; n >= 0; n--) {
          if ((maskByte >> n & 1) != 0) {
            result=colors[pixByte >> n & 1];
          }
 else {
            result=0;
          }
          softCursorPixels[i++]=result;
        }
      }
      for (n=7; n >= 8 - width % 8; n--) {
        if ((maskBuf[y * bytesPerRow + x] >> n & 1) != 0) {
          result=colors[pixBuf[y * bytesPerRow + x] >> n & 1];
        }
 else {
          result=0;
        }
        softCursorPixels[i++]=result;
      }
    }
  }
 else {
    byte[] pixBuf=new byte[width * height * bytesPixel];
    rfb.readFully(pixBuf);
    byte[] maskBuf=new byte[bytesMaskData];
    rfb.readFully(maskBuf);
    byte pixByte, maskByte;
    int x, y, n, result;
    int i=0;
    for (y=0; y < height; y++) {
      for (x=0; x < width / 8; x++) {
        maskByte=maskBuf[y * bytesPerRow + x];
        for (n=7; n >= 0; n--) {
          if ((maskByte >> n & 1) != 0) {
            if (bytesPixel == 1) {
              result=cm8.getRGB(pixBuf[i]);
            }
 else {
              result=0xFF000000 | (pixBuf[i * 4 + 2] & 0xFF) << 16 | (pixBuf[i * 4 + 1] & 0xFF) << 8 | (pixBuf[i * 4] & 0xFF);
            }
          }
 else {
            result=0;
          }
          softCursorPixels[i++]=result;
        }
      }
      for (n=7; n >= 8 - width % 8; n--) {
        if ((maskBuf[y * bytesPerRow + x] >> n & 1) != 0) {
          if (bytesPixel == 1) {
            result=cm8.getRGB(pixBuf[i]);
          }
 else {
            result=0xFF000000 | (pixBuf[i * 4 + 2] & 0xFF) << 16 | (pixBuf[i * 4 + 1] & 0xFF) << 8 | (pixBuf[i * 4] & 0xFF);
          }
        }
 else {
          result=0;
        }
        softCursorPixels[i++]=result;
      }
    }
  }
  return new MemoryImageSource(width,height,softCursorPixels,0,width);
}

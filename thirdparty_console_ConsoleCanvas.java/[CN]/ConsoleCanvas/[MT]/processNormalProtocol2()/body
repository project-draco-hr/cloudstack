{
  byte[] bs=rfb.sis.getSplit();
  if (bs != null && viewer.inProxyMode && viewer.clientStream != null) {
    Logger.log(Logger.DEBUG,"getSplit got " + bs.length + " bytes");
    int bytes_sent;
    if (viewer.compressServerMessage && bs.length > 10000) {
      ByteArrayOutputStream bos=new ByteArrayOutputStream(256000);
      GZIPOutputStream gos=new GZIPOutputStream(bos,65536);
      gos.write(bs);
      gos.finish();
      byte[] nbs=bos.toByteArray();
      gos.close();
      int n=nbs.length;
      Logger.log(Logger.DEBUG,"Compressed " + bs.length + "=>"+ n);
      byte[] b=new byte[6];
      b[0]=(byte)250;
      b[1]=2;
      b[2]=(byte)((n >> 24) & 0xff);
      b[3]=(byte)((n >> 16) & 0xff);
      b[4]=(byte)((n >> 8) & 0xff);
      b[5]=(byte)(n & 0xff);
      writeToClientStream(b);
      writeToClientStream(nbs);
      bytes_sent=n;
    }
 else {
      writeToClientStream(bs);
      bytes_sent=bs.length;
    }
  }
  rfb.sis.setSplit();
  int msgType=rfb.readServerMessageType();
  Logger.log(Logger.DEBUG,"S->C RFB msg type=" + msgType);
switch (msgType) {
case 250:
    int b=rfb.is.read();
  if (b == 1) {
    viewer.vc.paintErrorString("Disconnected");
    break;
  }
 else   if (b == 2) {
    int n=rfb.is.readInt();
    Logger.log(Logger.DEBUG,"Reading compressed data size=" + n);
    byte[] buf=new byte[n];
    rfb.is.readFully(buf);
    ByteArrayInputStream bis=new ByteArrayInputStream(buf);
    DataInputStream oldis=rfb.is;
    rfb.is=new DataInputStream(new GZIPInputStream(bis,65536));
    try {
      processNormalProtocol2();
    }
  finally {
      rfb.is=oldis;
    }
    break;
  }
 else   if (b == 3) {
    rfb.writeClientCustomMessage(0);
    break;
  }
throw new Exception("Message type 250 comes with bad submessage type: " + b);
case RfbProto.FramebufferUpdate:
rfb.readFramebufferUpdate();
boolean cursorPosReceived=false;
for (int i=0; i < rfb.updateNRects; i++) {
rfb.readFramebufferUpdateRectHdr();
int rx=rfb.updateRectX, ry=rfb.updateRectY;
int rw=rfb.updateRectW, rh=rfb.updateRectH;
if (rfb.updateRectEncoding == rfb.EncodingLastRect) break;
if (rfb.updateRectEncoding == rfb.EncodingNewFBSize) {
rfb.setFramebufferSize(rw,rh);
updateFramebufferSize();
break;
}
if (rfb.updateRectEncoding == rfb.EncodingXCursor || rfb.updateRectEncoding == rfb.EncodingRichCursor) {
handleCursorShapeUpdate(rfb.updateRectEncoding,rx,ry,rw,rh);
continue;
}
if (rfb.updateRectEncoding == rfb.EncodingPointerPos) {
softCursorMove(rx,ry);
cursorPosReceived=true;
continue;
}
rfb.startTiming();
switch (rfb.updateRectEncoding) {
case RfbProto.EncodingRaw:
handleRawRect(rx,ry,rw,rh);
break;
case RfbProto.EncodingCopyRect:
handleCopyRect(rx,ry,rw,rh);
break;
case RfbProto.EncodingRRE:
handleRRERect(rx,ry,rw,rh);
break;
case RfbProto.EncodingCoRRE:
handleCoRRERect(rx,ry,rw,rh);
break;
case RfbProto.EncodingHextile:
handleHextileRect(rx,ry,rw,rh);
break;
case RfbProto.EncodingZRLE:
handleZRLERect(rx,ry,rw,rh);
break;
case RfbProto.EncodingZlib:
handleZlibRect(rx,ry,rw,rh);
break;
case RfbProto.EncodingTight:
handleTightRect(rx,ry,rw,rh);
break;
default :
throw new Exception("Unknown RFB rectangle encoding " + rfb.updateRectEncoding);
}
rfb.stopTiming();
}
boolean fullUpdateNeeded=false;
if (viewer.checkRecordingStatus()) fullUpdateNeeded=true;
if (viewer.deferUpdateRequests > 0 && rfb.is.available() == 0 && !cursorPosReceived) {
synchronized (rfb) {
try {
rfb.wait(viewer.deferUpdateRequests);
}
 catch (InterruptedException e) {
}
}
}
if (viewer.options.eightBitColors != (bytesPixel == 1)) {
setPixelFormat();
fullUpdateNeeded=true;
}
rfb.writeFramebufferUpdateRequest(0,0,rfb.framebufferWidth,rfb.framebufferHeight,!fullUpdateNeeded);
break;
case RfbProto.SetColourMapEntries:
throw new Exception("Can't handle SetColourMapEntries message");
case RfbProto.Bell:
if (!viewer.inProxyMode) Toolkit.getDefaultToolkit().beep();
break;
case RfbProto.ServerCutText:
String s=rfb.readServerCutText();
break;
default :
throw new Exception("Unknown RFB message type " + msgType);
}
}

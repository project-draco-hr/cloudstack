{
  if (zrleInStream == null)   zrleInStream=new ZlibInStream();
  int nBytes=rfb.is.readInt();
  if (nBytes > 64 * 1024 * 1024)   throw new Exception("ZRLE decoder: illegal compressed data size");
  if (zrleBuf == null || zrleBufLen < nBytes) {
    zrleBufLen=nBytes + 4096;
    zrleBuf=new byte[zrleBufLen];
  }
  rfb.readFully(zrleBuf,0,nBytes);
  if (rfb.rec != null) {
    if (rfb.recordFromBeginning) {
      rfb.rec.writeIntBE(nBytes);
      rfb.rec.write(zrleBuf,0,nBytes);
    }
 else     if (!zrleRecWarningShown) {
      Logger.log(Logger.INFO,"Warning: ZRLE session can be recorded" + " only from the beginning");
      Logger.log(Logger.INFO,"Warning: Recorded file may be corrupted");
      zrleRecWarningShown=true;
    }
  }
  zrleInStream.setUnderlying(new MemInStream(zrleBuf,0,nBytes),nBytes);
  for (int ty=y; ty < y + h; ty+=64) {
    int th=Math.min(y + h - ty,64);
    for (int tx=x; tx < x + w; tx+=64) {
      int tw=Math.min(x + w - tx,64);
      int mode=zrleInStream.readU8();
      boolean rle=(mode & 128) != 0;
      int palSize=mode & 127;
      int[] palette=new int[128];
      readZrlePalette(palette,palSize);
      if (palSize == 1) {
        int pix=palette[0];
        Color c=(bytesPixel == 1) ? colors[pix] : new Color(0xFF000000 | pix);
        memGraphics.setColor(c);
        memGraphics.fillRect(tx,ty,tw,th);
        continue;
      }
      if (!rle) {
        if (palSize == 0) {
          readZrleRawPixels(tw,th);
        }
 else {
          readZrlePackedPixels(tw,th,palette,palSize);
        }
      }
 else {
        if (palSize == 0) {
          readZrlePlainRLEPixels(tw,th);
        }
 else {
          readZrlePackedRLEPixels(tw,th,palette);
        }
      }
      handleUpdatedZrleTile(tx,ty,tw,th);
    }
  }
  zrleInStream.reset();
  scheduleRepaint(x,y,w,h);
}

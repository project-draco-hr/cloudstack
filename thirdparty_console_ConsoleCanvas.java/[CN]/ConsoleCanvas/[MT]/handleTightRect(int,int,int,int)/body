{
  int comp_ctl=rfb.is.readUnsignedByte();
  if (rfb.rec != null) {
    if (rfb.recordFromBeginning || comp_ctl == (rfb.TightFill << 4) || comp_ctl == (rfb.TightJpeg << 4)) {
      rfb.rec.writeByte(comp_ctl);
    }
 else {
      rfb.rec.writeByte(comp_ctl | 0x0F);
    }
  }
  for (int stream_id=0; stream_id < 4; stream_id++) {
    if ((comp_ctl & 1) != 0 && tightInflaters[stream_id] != null) {
      tightInflaters[stream_id]=null;
    }
    comp_ctl>>=1;
  }
  if (comp_ctl > rfb.TightMaxSubencoding) {
    throw new Exception("Incorrect tight subencoding: " + comp_ctl);
  }
  if (comp_ctl == rfb.TightFill) {
    if (bytesPixel == 1) {
      int idx=rfb.is.readUnsignedByte();
      memGraphics.setColor(colors[idx]);
      if (rfb.rec != null) {
        rfb.rec.writeByte(idx);
      }
    }
 else {
      byte[] buf=new byte[3];
      rfb.readFully(buf);
      if (rfb.rec != null) {
        rfb.rec.write(buf);
      }
      Color bg=new Color(0xFF000000 | (buf[0] & 0xFF) << 16 | (buf[1] & 0xFF) << 8 | (buf[2] & 0xFF));
      memGraphics.setColor(bg);
    }
    memGraphics.fillRect(x,y,w,h);
    scheduleRepaint(x,y,w,h);
    return;
  }
  if (comp_ctl == rfb.TightJpeg) {
    byte[] jpegData=new byte[rfb.readCompactLen()];
    rfb.readFully(jpegData);
    if (rfb.rec != null) {
      if (!rfb.recordFromBeginning) {
        rfb.recordCompactLen(jpegData.length);
      }
      rfb.rec.write(jpegData);
    }
    Image jpegImage=Toolkit.getDefaultToolkit().createImage(jpegData);
    jpegRect=new Rectangle(x,y,w,h);
synchronized (jpegRect) {
      Toolkit.getDefaultToolkit().prepareImage(jpegImage,-1,-1,this);
      try {
        jpegRect.wait(3000);
      }
 catch (      InterruptedException e) {
        throw new Exception("Interrupted while decoding JPEG image");
      }
    }
    jpegRect=null;
    return;
  }
  int numColors=0, rowSize=w;
  byte[] palette8=new byte[2];
  int[] palette24=new int[256];
  boolean useGradient=false;
  if ((comp_ctl & rfb.TightExplicitFilter) != 0) {
    int filter_id=rfb.is.readUnsignedByte();
    if (rfb.rec != null) {
      rfb.rec.writeByte(filter_id);
    }
    if (filter_id == rfb.TightFilterPalette) {
      numColors=rfb.is.readUnsignedByte() + 1;
      if (rfb.rec != null) {
        rfb.rec.writeByte(numColors - 1);
      }
      if (bytesPixel == 1) {
        if (numColors != 2) {
          throw new Exception("Incorrect tight palette size: " + numColors);
        }
        rfb.readFully(palette8);
        if (rfb.rec != null) {
          rfb.rec.write(palette8);
        }
      }
 else {
        byte[] buf=new byte[numColors * 3];
        rfb.readFully(buf);
        if (rfb.rec != null) {
          rfb.rec.write(buf);
        }
        for (int i=0; i < numColors; i++) {
          palette24[i]=((buf[i * 3] & 0xFF) << 16 | (buf[i * 3 + 1] & 0xFF) << 8 | (buf[i * 3 + 2] & 0xFF));
        }
      }
      if (numColors == 2)       rowSize=(w + 7) / 8;
    }
 else     if (filter_id == rfb.TightFilterGradient) {
      useGradient=true;
    }
 else     if (filter_id != rfb.TightFilterCopy) {
      throw new Exception("Incorrect tight filter id: " + filter_id);
    }
  }
  if (numColors == 0 && bytesPixel == 4)   rowSize*=3;
  int dataSize=h * rowSize;
  if (dataSize < rfb.TightMinToCompress) {
    if (numColors != 0) {
      byte[] indexedData=new byte[dataSize];
      rfb.readFully(indexedData);
      if (rfb.rec != null) {
        rfb.rec.write(indexedData);
      }
      if (numColors == 2) {
        if (bytesPixel == 1) {
          decodeMonoData(x,y,w,h,indexedData,palette8);
        }
 else {
          decodeMonoData(x,y,w,h,indexedData,palette24);
        }
      }
 else {
        int i=0;
        for (int dy=y; dy < y + h; dy++) {
          for (int dx=x; dx < x + w; dx++) {
            pixels24[dy * rfb.framebufferWidth + dx]=palette24[indexedData[i++] & 0xFF];
          }
        }
      }
    }
 else     if (useGradient) {
      byte[] buf=new byte[w * h * 3];
      rfb.readFully(buf);
      if (rfb.rec != null) {
        rfb.rec.write(buf);
      }
      decodeGradientData(x,y,w,h,buf);
    }
 else {
      if (bytesPixel == 1) {
        for (int dy=y; dy < y + h; dy++) {
          rfb.readFully(pixels8,dy * rfb.framebufferWidth + x,w);
          if (rfb.rec != null) {
            rfb.rec.write(pixels8,dy * rfb.framebufferWidth + x,w);
          }
        }
      }
 else {
        byte[] buf=new byte[w * 3];
        int i, offset;
        for (int dy=y; dy < y + h; dy++) {
          rfb.readFully(buf);
          if (rfb.rec != null) {
            rfb.rec.write(buf);
          }
          offset=dy * rfb.framebufferWidth + x;
          for (i=0; i < w; i++) {
            pixels24[offset + i]=(buf[i * 3] & 0xFF) << 16 | (buf[i * 3 + 1] & 0xFF) << 8 | (buf[i * 3 + 2] & 0xFF);
          }
        }
      }
    }
  }
 else {
    int zlibDataLen=rfb.readCompactLen();
    byte[] zlibData=new byte[zlibDataLen];
    rfb.readFully(zlibData);
    if (rfb.rec != null && rfb.recordFromBeginning) {
      rfb.rec.write(zlibData);
    }
    int stream_id=comp_ctl & 0x03;
    if (tightInflaters[stream_id] == null) {
      tightInflaters[stream_id]=new Inflater();
    }
    Inflater myInflater=tightInflaters[stream_id];
    myInflater.setInput(zlibData);
    byte[] buf=new byte[dataSize];
    myInflater.inflate(buf);
    if (rfb.rec != null && !rfb.recordFromBeginning) {
      rfb.recordCompressedData(buf);
    }
    if (numColors != 0) {
      if (numColors == 2) {
        if (bytesPixel == 1) {
          decodeMonoData(x,y,w,h,buf,palette8);
        }
 else {
          decodeMonoData(x,y,w,h,buf,palette24);
        }
      }
 else {
        int i=0;
        for (int dy=y; dy < y + h; dy++) {
          for (int dx=x; dx < x + w; dx++) {
            pixels24[dy * rfb.framebufferWidth + dx]=palette24[buf[i++] & 0xFF];
          }
        }
      }
    }
 else     if (useGradient) {
      decodeGradientData(x,y,w,h,buf);
    }
 else {
      if (bytesPixel == 1) {
        int destOffset=y * rfb.framebufferWidth + x;
        for (int dy=0; dy < h; dy++) {
          System.arraycopy(buf,dy * w,pixels8,destOffset,w);
          destOffset+=rfb.framebufferWidth;
        }
      }
 else {
        int srcOffset=0;
        int destOffset, i;
        for (int dy=0; dy < h; dy++) {
          myInflater.inflate(buf);
          destOffset=(y + dy) * rfb.framebufferWidth + x;
          for (i=0; i < w; i++) {
            pixels24[destOffset + i]=(buf[srcOffset] & 0xFF) << 16 | (buf[srcOffset + 1] & 0xFF) << 8 | (buf[srcOffset + 2] & 0xFF);
            srcOffset+=3;
          }
        }
      }
    }
  }
  handleUpdatedPixels(x,y,w,h);
  scheduleRepaint(x,y,w,h);
}

{
  standardDispatchChain.dispatch(new DispatchTask(cmd,params));
  final CallContext ctx=CallContext.current();
  ctx.setEventDisplayEnabled(cmd.isDisplayResourceEnabled());
  if (cmd instanceof BaseAsyncCmd) {
    final BaseAsyncCmd asyncCmd=(BaseAsyncCmd)cmd;
    final String startEventId=params.get(ApiConstants.CTX_START_EVENT_ID);
    String uuid=params.get(ApiConstants.UUID);
    ctx.setStartEventId(Long.valueOf(startEventId));
    if (EventTypes.getEntityForEvent(asyncCmd.getEventType()) != null) {
      ctx.putContextParameter(EventTypes.getEntityForEvent(asyncCmd.getEventType()),uuid);
    }
    if (params.get(ApiConstants.VIRTUAL_MACHINE_ID) != null) {
      ctx.putContextParameter(ReflectUtil.getEntityName(VirtualMachine.class),params.get(ApiConstants.VIRTUAL_MACHINE_ID));
    }
    if (asyncCmd.getJob() != null && asyncCmd.getSyncObjId() != null && asyncCmd.getSyncObjType() != null) {
      Long queueSizeLimit=null;
      if (asyncCmd.getSyncObjType() != null && asyncCmd.getSyncObjType().equalsIgnoreCase(BaseAsyncCmd.snapshotHostSyncObject)) {
        queueSizeLimit=_createSnapshotQueueSizeLimit;
      }
 else {
        queueSizeLimit=1L;
      }
      if (queueSizeLimit != null) {
        if (!execute) {
          _asyncMgr.syncAsyncJobExecution((AsyncJob)asyncCmd.getJob(),asyncCmd.getSyncObjType(),asyncCmd.getSyncObjId().longValue(),queueSizeLimit);
          return;
        }
      }
 else {
        s_logger.trace("The queue size is unlimited, skipping the synchronizing");
      }
    }
  }
  if (cmd instanceof BaseAsyncCustomIdCmd) {
    ((BaseAsyncCustomIdCmd)cmd).checkUuid();
  }
 else   if (cmd instanceof BaseCustomIdCmd) {
    ((BaseCustomIdCmd)cmd).checkUuid();
  }
  cmd.execute();
}

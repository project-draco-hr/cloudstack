{
  try {
    field.setAccessible(true);
    CommandType fieldType=annotation.type();
switch (fieldType) {
case BOOLEAN:
      field.set(cmdObj,Boolean.valueOf(paramObj.toString()));
    break;
case DATE:
  DateFormat format=BaseCmd.INPUT_FORMAT;
synchronized (format) {
  field.set(cmdObj,format.parse(paramObj.toString()));
}
break;
case FLOAT:
field.set(cmdObj,Float.valueOf(paramObj.toString()));
break;
case INTEGER:
field.set(cmdObj,Integer.valueOf(paramObj.toString()));
break;
case LIST:
List listParam=new ArrayList();
StringTokenizer st=new StringTokenizer(paramObj.toString(),",");
while (st.hasMoreTokens()) {
String token=st.nextToken();
CommandType listType=annotation.collectionType();
switch (listType) {
case INTEGER:
listParam.add(Integer.valueOf(token));
break;
case LONG:
listParam.add(Long.valueOf(token));
break;
case STRING:
listParam.add(token);
break;
}
}
field.set(cmdObj,listParam);
break;
case LONG:
field.set(cmdObj,Long.valueOf(paramObj.toString()));
break;
case STRING:
field.set(cmdObj,paramObj.toString());
break;
case TZDATE:
field.set(cmdObj,DateUtil.parseTZDateString(paramObj.toString()));
break;
case MAP:
default :
field.set(cmdObj,paramObj);
break;
}
}
 catch (IllegalAccessException ex) {
s_logger.error("Error initializing command " + cmdObj.getName() + ", field "+ field.getName()+ " is not accessible.");
throw new CloudRuntimeException("Internal error initializing parameters for command " + cmdObj.getName() + " [field "+ field.getName()+ " is not accessible]");
}
}

{
  final Connection conn=getConnection();
  final VirtualMachineTO vmSpec=cmd.getVirtualMachine();
  final String vmName=vmSpec.getName();
  VmPowerState state=VmPowerState.HALTED;
  VM vm=null;
  final Map<String,String> iqnToPath=new HashMap<String,String>();
  try {
    final Set<VM> vms=VM.getByNameLabel(conn,vmName);
    if (vms != null) {
      for (      final VM v : vms) {
        final VM.Record vRec=v.getRecord(conn);
        if (vRec.powerState == VmPowerState.HALTED) {
          v.destroy(conn);
        }
 else         if (vRec.powerState == VmPowerState.RUNNING) {
          final String host=vRec.residentOn.getUuid(conn);
          final String msg="VM " + vmName + " is runing on host "+ host;
          s_logger.debug(msg);
          return new StartAnswer(cmd,msg,host);
        }
 else {
          final String msg="There is already a VM having the same name " + vmName + " vm record "+ vRec.toString();
          s_logger.warn(msg);
          return new StartAnswer(cmd,msg);
        }
      }
    }
    s_logger.debug("1. The VM " + vmName + " is in Starting state.");
    final Host host=Host.getByUuid(conn,_host.uuid);
    vm=createVmFromTemplate(conn,vmSpec,host);
    final GPUDeviceTO gpuDevice=vmSpec.getGpuDevice();
    if (gpuDevice != null) {
      s_logger.debug("Creating VGPU for of VGPU type: " + gpuDevice.getVgpuType() + " in GPU group "+ gpuDevice.getGpuGroup()+ " for VM "+ vmName);
      createVGPU(conn,cmd,vm,gpuDevice);
    }
    for (    final DiskTO disk : vmSpec.getDisks()) {
      final VDI newVdi=prepareManagedDisk(conn,disk,vmName);
      if (newVdi != null) {
        final String path=newVdi.getUuid(conn);
        iqnToPath.put(disk.getDetails().get(DiskTO.IQN),path);
      }
      createVbd(conn,disk,vmName,vm,vmSpec.getBootloader(),newVdi);
    }
    if (vmSpec.getType() != VirtualMachine.Type.User) {
      createPatchVbd(conn,vmName,vm);
    }
    for (    final NicTO nic : vmSpec.getNics()) {
      createVif(conn,vmName,vm,vmSpec,nic);
    }
    startVM(conn,host,vm,vmName);
    if (_isOvs) {
      for (      final NicTO nic : vmSpec.getNics()) {
        if (nic.getBroadcastType() == Networks.BroadcastDomainType.Vswitch) {
          final HashMap<String,String> args=parseDefaultOvsRuleComamnd(BroadcastDomainType.getValue(nic.getBroadcastUri()));
          final OvsSetTagAndFlowCommand flowCmd=new OvsSetTagAndFlowCommand(args.get("vmName"),args.get("tag"),args.get("vlans"),args.get("seqno"),Long.parseLong(args.get("vmId")));
          final OvsSetTagAndFlowAnswer r=execute(flowCmd);
          if (!r.getResult()) {
            s_logger.warn("Failed to set flow for VM " + r.getVmId());
          }
 else {
            s_logger.info("Success to set flow for VM " + r.getVmId());
          }
        }
      }
    }
    if (_canBridgeFirewall) {
      String result=null;
      if (vmSpec.getType() != VirtualMachine.Type.User) {
        final NicTO[] nics=vmSpec.getNics();
        boolean secGrpEnabled=false;
        for (        final NicTO nic : nics) {
          if (nic.isSecurityGroupEnabled() || nic.getIsolationUri() != null && nic.getIsolationUri().getScheme().equalsIgnoreCase(IsolationType.Ec2.toString())) {
            secGrpEnabled=true;
            break;
          }
        }
        if (secGrpEnabled) {
          result=callHostPlugin(conn,"vmops","default_network_rules_systemvm","vmName",vmName);
          if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {
            s_logger.warn("Failed to program default network rules for " + vmName);
          }
 else {
            s_logger.info("Programmed default network rules for " + vmName);
          }
        }
      }
 else {
        final NicTO[] nics=vmSpec.getNics();
        for (        final NicTO nic : nics) {
          if (nic.isSecurityGroupEnabled() || nic.getIsolationUri() != null && nic.getIsolationUri().getScheme().equalsIgnoreCase(IsolationType.Ec2.toString())) {
            final List<String> nicSecIps=nic.getNicSecIps();
            String secIpsStr;
            final StringBuilder sb=new StringBuilder();
            if (nicSecIps != null) {
              for (              final String ip : nicSecIps) {
                sb.append(ip).append(":");
              }
              secIpsStr=sb.toString();
            }
 else {
              secIpsStr="0:";
            }
            result=callHostPlugin(conn,"vmops","default_network_rules","vmName",vmName,"vmIP",nic.getIp(),"vmMAC",nic.getMac(),"vmID",Long.toString(vmSpec.getId()),"secIps",secIpsStr);
            if (result == null || result.isEmpty() || !Boolean.parseBoolean(result)) {
              s_logger.warn("Failed to program default network rules for " + vmName + " on nic with ip:"+ nic.getIp()+ " mac:"+ nic.getMac());
            }
 else {
              s_logger.info("Programmed default network rules for " + vmName + " on nic with ip:"+ nic.getIp()+ " mac:"+ nic.getMac());
            }
          }
        }
      }
    }
    state=VmPowerState.RUNNING;
    final StartAnswer startAnswer=new StartAnswer(cmd);
    startAnswer.setIqnToPath(iqnToPath);
    return startAnswer;
  }
 catch (  final Exception e) {
    s_logger.warn("Catch Exception: " + e.getClass().toString() + " due to "+ e.toString(),e);
    final String msg=handleVmStartFailure(conn,vmName,vm,"",e);
    final StartAnswer startAnswer=new StartAnswer(cmd,msg);
    startAnswer.setIqnToPath(iqnToPath);
    return startAnswer;
  }
 finally {
    if (state != VmPowerState.HALTED) {
      s_logger.debug("2. The VM " + vmName + " is in "+ state+ " state.");
    }
 else {
      s_logger.debug("The VM is in stopped state, detected problem during startup : " + vmName);
    }
  }
}

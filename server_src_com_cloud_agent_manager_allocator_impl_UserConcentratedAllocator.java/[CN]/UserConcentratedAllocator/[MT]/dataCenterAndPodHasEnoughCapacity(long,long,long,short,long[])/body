{
  if (m_capacityCheckLock.lock(120)) {
    try {
      SearchCriteria<CapacityVO> sc=_capacityDao.createSearchCriteria();
      sc.addAnd("capacityType",SearchCriteria.Op.EQ,capacityType);
      sc.addAnd("dataCenterId",SearchCriteria.Op.EQ,dataCenterId);
      sc.addAnd("podId",SearchCriteria.Op.EQ,podId);
      List<CapacityVO> capacities=_capacityDao.search(sc,null);
      boolean enoughCapacity=false;
      if (capacities != null) {
        for (        CapacityVO capacity : capacities) {
          if (capacityType == CapacityVO.CAPACITY_TYPE_CPU || capacityType == CapacityVO.CAPACITY_TYPE_MEMORY) {
            if ((capacity.getTotalCapacity() - calcHostAllocatedCpuMemoryCapacity(capacity.getHostOrPoolId(),capacityType)) >= capacityNeeded) {
              hostCandidate[0]=capacity.getHostOrPoolId();
              enoughCapacity=true;
              break;
            }
          }
 else {
            if ((capacity.getTotalCapacity() - capacity.getUsedCapacity()) >= capacityNeeded) {
              hostCandidate[0]=capacity.getHostOrPoolId();
              enoughCapacity=true;
              break;
            }
          }
        }
      }
      return enoughCapacity;
    }
  finally {
      m_capacityCheckLock.unlock();
    }
  }
 else {
    s_logger.error("Unable to acquire synchronization lock for pod allocation");
    return false;
  }
}

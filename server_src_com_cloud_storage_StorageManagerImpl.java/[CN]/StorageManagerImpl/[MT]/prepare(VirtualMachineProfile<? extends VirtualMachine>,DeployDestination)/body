{
  List<VolumeVO> vols=_volsDao.findUsableVolumesForInstance(vm.getId());
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Preparing " + vols.size() + " volumes for "+ vm);
  }
  List<VolumeVO> recreateVols=new ArrayList<VolumeVO>(vols.size());
  for (  VolumeVO vol : vols) {
    Volume.State state=vol.getState();
    if (state == Volume.State.Ready) {
      StoragePoolVO pool=_storagePoolDao.findById(vol.getPoolId());
      if (pool.getRemoved() != null || pool.isInMaintenance()) {
        if (vol.isRecreatable()) {
          if (s_logger.isDebugEnabled()) {
            s_logger.debug("Volume " + vol + " has to be recreated due to storage pool "+ pool+ " is unavailable");
          }
          recreateVols.add(vol);
        }
 else {
          throw new StorageUnavailableException("Volume " + vol + " is not available on the storage pool.",pool.getId());
        }
      }
 else {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Volume " + vol + " is ready.");
        }
        vm.addDisk(new VolumeTO(vol,pool));
      }
    }
 else     if (state == Volume.State.Allocated) {
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Creating volume " + vol + " for the first time.");
      }
      recreateVols.add(vol);
    }
 else     if (state == Volume.State.Creating && vol.isRecreatable()) {
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Re-creating volume " + vol + " as it was left with Creating state");
      }
      recreateVols.add(vol);
    }
 else {
      throw new StorageUnavailableException("Volume " + vol + " can not be used",vol.getPoolId() != null ? vol.getPoolId() : null);
    }
  }
  for (  VolumeVO vol : recreateVols) {
    VolumeVO newVol;
    if (vol.getState() == Volume.State.Allocated) {
      vol.setRecreatable(true);
      newVol=vol;
    }
 else {
      newVol=switchVolume(vol);
      newVol.setRecreatable(true);
      if (dest.getStorageForDisks() != null && dest.getStorageForDisks().containsKey(vol)) {
        StoragePool poolWithOldVol=dest.getStorageForDisks().get(vol);
        dest.getStorageForDisks().put(newVol,poolWithOldVol);
        dest.getStorageForDisks().remove(vol);
      }
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Created new volume " + newVol + " for old volume "+ vol);
      }
    }
    try {
      _volsDao.update(newVol,Volume.Event.Create);
    }
 catch (    ConcurrentOperationException e) {
      throw new StorageUnavailableException("Unable to create " + newVol,newVol.getPoolId());
    }
    Pair<VolumeTO,StoragePool> created=createVolume(newVol,_diskOfferingDao.findById(newVol.getDiskOfferingId()),vm,vols,dest);
    if (created == null) {
      Long poolId=newVol.getPoolId();
      newVol.setPoolId(null);
      try {
        _volsDao.update(newVol,Volume.Event.OperationFailed);
      }
 catch (      ConcurrentOperationException e) {
        throw new CloudRuntimeException("Unable to update the failure on a volume: " + newVol,e);
      }
      throw new StorageUnavailableException("Unable to create " + newVol,poolId == null ? -1L : poolId);
    }
    created.first().setDeviceId(newVol.getDeviceId().intValue());
    newVol.setFolder(created.second().getPath());
    newVol.setPath(created.first().getPath());
    newVol.setSize(created.first().getSize());
    newVol.setPoolType(created.second().getPoolType());
    newVol.setPodId(created.second().getPodId());
    try {
      _volsDao.update(newVol,Volume.Event.OperationSucceeded);
    }
 catch (    ConcurrentOperationException e) {
      throw new CloudRuntimeException("Unable to update an CREATE operation succeeded on volume " + newVol,e);
    }
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Volume " + newVol + " is created on "+ created.second());
    }
    vm.addDisk(created.first());
  }
}

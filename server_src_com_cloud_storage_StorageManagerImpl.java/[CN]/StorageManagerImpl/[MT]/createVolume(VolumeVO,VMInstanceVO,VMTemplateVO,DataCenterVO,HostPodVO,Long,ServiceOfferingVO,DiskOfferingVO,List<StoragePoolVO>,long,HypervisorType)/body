{
  StoragePoolVO pool=null;
  final HashSet<StoragePool> avoidPools=new HashSet<StoragePool>(avoids);
  if (diskOffering != null && diskOffering.isCustomized()) {
    diskOffering.setDiskSize(size);
  }
  DiskProfile dskCh=null;
  if (volume.getVolumeType() == VolumeType.ROOT && Storage.ImageFormat.ISO != template.getFormat()) {
    dskCh=createDiskCharacteristics(volume,template,dc,offering);
  }
 else {
    dskCh=createDiskCharacteristics(volume,template,dc,diskOffering);
  }
  dskCh.setHyperType(hyperType);
  VolumeTO created=null;
  int retry=_retry;
  while (--retry >= 0) {
    created=null;
    long podId=pod.getId();
    pod=_podDao.findById(podId);
    if (pod == null) {
      s_logger.warn("Unable to find pod " + podId + " when create volume "+ volume.getName());
      break;
    }
    pool=findStoragePool(dskCh,dc,pod,clusterId,template,avoidPools);
    if (pool == null) {
      s_logger.warn("Unable to find storage poll when create volume " + volume.getName());
      break;
    }
    avoidPools.add(pool);
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Trying to create " + volume + " on "+ pool);
    }
    CreateCommand cmd=null;
    VMTemplateStoragePoolVO tmpltStoredOn=null;
    for (int i=0; i < 2; i++) {
      if (volume.getVolumeType() == VolumeType.ROOT && Storage.ImageFormat.ISO != template.getFormat()) {
        tmpltStoredOn=_tmpltMgr.prepareTemplateForCreate(template,pool);
        if (tmpltStoredOn == null) {
          continue;
        }
        cmd=new CreateCommand(dskCh,tmpltStoredOn.getLocalDownloadPath(),new StorageFilerTO(pool));
      }
 else {
        cmd=new CreateCommand(dskCh,new StorageFilerTO(pool));
      }
      try {
        Answer answer=sendToPool(pool,cmd);
        if (answer != null && answer.getResult()) {
          created=((CreateAnswer)answer).getVolume();
          break;
        }
        if (tmpltStoredOn != null && answer != null && (answer instanceof CreateAnswer) && ((CreateAnswer)answer).templateReloadRequested()) {
          if (!_tmpltMgr.resetTemplateDownloadStateOnPool(tmpltStoredOn.getId()))           break;
        }
 else {
          break;
        }
      }
 catch (      StorageUnavailableException e) {
        s_logger.debug("Storage unavailable for " + pool.getId());
        break;
      }
    }
    if (created != null)     break;
    s_logger.debug("Retrying the create because it failed on pool " + pool);
  }
  Transaction txn=Transaction.currentTxn();
  txn.start();
  if (created == null) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Unable to create a volume for " + volume);
    }
    volume.setStatus(AsyncInstanceCreateStatus.Failed);
    volume.setState(Volume.State.Destroy);
    _volsDao.persist(volume);
    _volsDao.remove(volume.getId());
    volume=null;
  }
 else {
    volume.setStatus(AsyncInstanceCreateStatus.Created);
    volume.setFolder(pool.getPath());
    volume.setPath(created.getPath());
    volume.setSize(created.getSize());
    volume.setPoolType(pool.getPoolType());
    volume.setPoolId(pool.getId());
    volume.setPodId(pod.getId());
    volume.setState(Volume.State.Ready);
    _volsDao.persist(volume);
  }
  txn.commit();
  return volume;
}

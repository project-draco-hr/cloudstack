{
  List<StoragePoolVO> storagePools=_storagePoolDao.listAllActive();
  for (  StoragePoolVO pool : storagePools) {
    try {
      if (recurring && pool.isLocal()) {
        continue;
      }
      List<VMTemplateStoragePoolVO> unusedTemplatesInPool=_tmpltMgr.getUnusedTemplatesInPool(pool);
      s_logger.debug("Storage pool garbage collector found " + unusedTemplatesInPool.size() + " templates to clean up in storage pool: "+ pool.getName());
      for (      VMTemplateStoragePoolVO templatePoolVO : unusedTemplatesInPool) {
        if (templatePoolVO.getDownloadState() != VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {
          s_logger.debug("Storage pool garbage collector is skipping templatePoolVO with ID: " + templatePoolVO.getId() + " because it is not completely downloaded.");
          continue;
        }
        if (!templatePoolVO.getMarkedForGC()) {
          templatePoolVO.setMarkedForGC(true);
          _vmTemplatePoolDao.update(templatePoolVO.getId(),templatePoolVO);
          s_logger.debug("Storage pool garbage collector has marked templatePoolVO with ID: " + templatePoolVO.getId() + " for garbage collection.");
          continue;
        }
        _tmpltMgr.evictTemplateFromStoragePool(templatePoolVO);
      }
    }
 catch (    Exception e) {
      s_logger.warn("Problem cleaning up primary storage pool " + pool,e);
    }
  }
  List<HostVO> secondaryStorageHosts=_hostDao.listSecondaryStorageHosts();
  for (  HostVO secondaryStorageHost : secondaryStorageHosts) {
    try {
      long hostId=secondaryStorageHost.getId();
      List<VMTemplateHostVO> destroyedTemplateHostVOs=_vmTemplateHostDao.listDestroyed(hostId);
      s_logger.debug("Secondary storage garbage collector found " + destroyedTemplateHostVOs.size() + " templates to cleanup on secondary storage host: "+ secondaryStorageHost.getName());
      for (      VMTemplateHostVO destroyedTemplateHostVO : destroyedTemplateHostVOs) {
        if (!_tmpltMgr.templateIsDeleteable(destroyedTemplateHostVO)) {
          s_logger.debug("Not deleting template at: " + destroyedTemplateHostVO.getInstallPath());
          continue;
        }
        String installPath=destroyedTemplateHostVO.getInstallPath();
        if (installPath != null) {
          Answer answer=_agentMgr.easySend(hostId,new DeleteTemplateCommand(destroyedTemplateHostVO.getInstallPath()));
          if (answer == null || !answer.getResult()) {
            s_logger.debug("Failed to delete template at: " + destroyedTemplateHostVO.getInstallPath());
          }
 else {
            _vmTemplateHostDao.remove(destroyedTemplateHostVO.getId());
            s_logger.debug("Deleted template at: " + destroyedTemplateHostVO.getInstallPath());
          }
        }
 else {
          _vmTemplateHostDao.remove(destroyedTemplateHostVO.getId());
        }
      }
    }
 catch (    Exception e) {
      s_logger.warn("problem cleaning up secondary storage " + secondaryStorageHost,e);
    }
  }
  List<VolumeVO> vols=_volsDao.listRemovedButNotDestroyed();
  for (  VolumeVO vol : vols) {
    try {
      Long poolId=vol.getPoolId();
      Answer answer=null;
      StoragePoolVO pool=_storagePoolDao.findById(poolId);
      final DestroyCommand cmd=new DestroyCommand(pool,vol);
      answer=sendToPool(pool,cmd);
      if (answer != null && answer.getResult()) {
        s_logger.debug("Destroyed " + vol);
        vol.setDestroyed(true);
        _volsDao.update(vol.getId(),vol);
      }
    }
 catch (    Exception e) {
      s_logger.warn("Unable to destroy " + vol.getId(),e);
    }
  }
}

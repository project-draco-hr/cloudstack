{
  GlobalLock scanLock=GlobalLock.getInternLock(this.getClass().getName());
  try {
    if (scanLock.lock(3)) {
      try {
        List<StoragePoolVO> storagePools=_storagePoolDao.listAll();
        for (        StoragePoolVO pool : storagePools) {
          try {
            if (recurring && pool.isLocal()) {
              continue;
            }
            List<VMTemplateStoragePoolVO> unusedTemplatesInPool=_tmpltMgr.getUnusedTemplatesInPool(pool);
            s_logger.debug("Storage pool garbage collector found " + unusedTemplatesInPool.size() + " templates to clean up in storage pool: "+ pool.getName());
            for (            VMTemplateStoragePoolVO templatePoolVO : unusedTemplatesInPool) {
              if (templatePoolVO.getDownloadState() != VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {
                s_logger.debug("Storage pool garbage collector is skipping templatePoolVO with ID: " + templatePoolVO.getId() + " because it is not completely downloaded.");
                continue;
              }
              if (!templatePoolVO.getMarkedForGC()) {
                templatePoolVO.setMarkedForGC(true);
                _vmTemplatePoolDao.update(templatePoolVO.getId(),templatePoolVO);
                s_logger.debug("Storage pool garbage collector has marked templatePoolVO with ID: " + templatePoolVO.getId() + " for garbage collection.");
                continue;
              }
              _tmpltMgr.evictTemplateFromStoragePool(templatePoolVO);
            }
          }
 catch (          Exception e) {
            s_logger.warn("Problem cleaning up primary storage pool " + pool,e);
          }
        }
        List<HostVO> secondaryStorageHosts=_hostDao.listSecondaryStorageHosts();
        for (        HostVO secondaryStorageHost : secondaryStorageHosts) {
          try {
            long hostId=secondaryStorageHost.getId();
            List<VMTemplateHostVO> destroyedTemplateHostVOs=_vmTemplateHostDao.listDestroyed(hostId);
            s_logger.debug("Secondary storage garbage collector found " + destroyedTemplateHostVOs.size() + " templates to cleanup on secondary storage host: "+ secondaryStorageHost.getName());
            for (            VMTemplateHostVO destroyedTemplateHostVO : destroyedTemplateHostVOs) {
              if (!_tmpltMgr.templateIsDeleteable(destroyedTemplateHostVO)) {
                s_logger.debug("Not deleting template at: " + destroyedTemplateHostVO.getInstallPath());
                continue;
              }
              String installPath=destroyedTemplateHostVO.getInstallPath();
              if (installPath != null) {
                Answer answer=_agentMgr.easySend(hostId,new DeleteTemplateCommand(destroyedTemplateHostVO.getInstallPath()));
                if (answer == null || !answer.getResult()) {
                  s_logger.debug("Failed to delete template at: " + destroyedTemplateHostVO.getInstallPath() + " due to "+ ((answer == null) ? "answer is null" : answer.getDetails()));
                }
 else {
                  _vmTemplateHostDao.remove(destroyedTemplateHostVO.getId());
                  s_logger.debug("Deleted template at: " + destroyedTemplateHostVO.getInstallPath());
                }
              }
 else {
                _vmTemplateHostDao.remove(destroyedTemplateHostVO.getId());
              }
            }
          }
 catch (          Exception e) {
            s_logger.warn("problem cleaning up secondary storage " + secondaryStorageHost,e);
          }
        }
        List<VolumeVO> vols=_volsDao.listVolumesToBeDestroyed();
        for (        VolumeVO vol : vols) {
          try {
            expungeVolume(vol);
          }
 catch (          Exception e) {
            s_logger.warn("Unable to destroy " + vol.getId(),e);
          }
        }
      }
  finally {
        scanLock.unlock();
      }
    }
  }
  finally {
    scanLock.releaseRef();
  }
}

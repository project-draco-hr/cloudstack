{
  if (volumes == null || volumes.isEmpty()) {
    return false;
  }
  if (!checkUsagedSpace(pool)) {
    return false;
  }
  StoragePoolVO poolVO=_storagePoolDao.findById(pool.getId());
  long allocatedSizeWithtemplate=_capacityMgr.getAllocatedPoolCapacity(poolVO,null);
  long totalAskingSize=0;
  for (  Volume volume : volumes) {
    if (volume.getTemplateId() != null) {
      VMTemplateVO tmpl=_templateDao.findByIdIncludingRemoved(volume.getTemplateId());
      if (tmpl != null && tmpl.getFormat() != ImageFormat.ISO) {
        allocatedSizeWithtemplate=_capacityMgr.getAllocatedPoolCapacity(poolVO,tmpl);
      }
    }
    if (volume.getState() != Volume.State.Ready) {
      totalAskingSize=totalAskingSize + getVolumeSizeIncludingHypervisorSnapshotReserve(volume,pool);
    }
  }
  long totalOverProvCapacity;
  if (pool.getPoolType() == StoragePoolType.NetworkFilesystem || pool.getPoolType() == StoragePoolType.VMFS || pool.getPoolType() == StoragePoolType.Filesystem) {
    BigDecimal overProvFactor=getStorageOverProvisioningFactor(pool.getId());
    totalOverProvCapacity=overProvFactor.multiply(new BigDecimal(pool.getCapacityBytes())).longValue();
    s_logger.debug("Found storage pool " + poolVO.getName() + " of type "+ pool.getPoolType().toString()+ " with overprovisioning factor "+ overProvFactor.toString());
    s_logger.debug("Total over provisioned capacity calculated is " + overProvFactor + " * "+ pool.getCapacityBytes());
  }
 else {
    totalOverProvCapacity=pool.getCapacityBytes();
    s_logger.debug("Found storage pool " + poolVO.getName() + " of type "+ pool.getPoolType().toString());
  }
  s_logger.debug("Total capacity of the pool " + poolVO.getName() + " id: "+ pool.getId()+ " is "+ totalOverProvCapacity);
  double storageAllocatedThreshold=CapacityManager.StorageAllocatedCapacityDisableThreshold.valueIn(pool.getDataCenterId());
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Checking pool: " + pool.getId() + " for volume allocation "+ volumes.toString()+ ", maxSize : "+ totalOverProvCapacity+ ", totalAllocatedSize : "+ allocatedSizeWithtemplate+ ", askingSize : "+ totalAskingSize+ ", allocated disable threshold: "+ storageAllocatedThreshold);
  }
  double usedPercentage=(allocatedSizeWithtemplate + totalAskingSize) / (double)(totalOverProvCapacity);
  if (usedPercentage > storageAllocatedThreshold) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Insufficient un-allocated capacity on: " + pool.getId() + " for volume allocation: "+ volumes.toString()+ " since its allocated percentage: "+ usedPercentage+ " has crossed the allocated pool.storage.allocated.capacity.disablethreshold: "+ storageAllocatedThreshold+ ", skipping this pool");
    }
    return false;
  }
  if (totalOverProvCapacity < (allocatedSizeWithtemplate + totalAskingSize)) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Insufficient un-allocated capacity on: " + pool.getId() + " for volume allocation: "+ volumes.toString()+ ", not enough storage, maxSize : "+ totalOverProvCapacity+ ", totalAllocatedSize : "+ allocatedSizeWithtemplate+ ", askingSize : "+ totalAskingSize);
    }
    return false;
  }
  return true;
}

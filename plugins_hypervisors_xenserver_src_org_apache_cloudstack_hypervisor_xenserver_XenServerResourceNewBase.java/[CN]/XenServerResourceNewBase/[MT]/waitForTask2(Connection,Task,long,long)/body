{
  final long beginTime=System.currentTimeMillis();
  if (s_logger.isTraceEnabled()) {
    s_logger.trace("Task " + task.getNameLabel(c) + " ("+ task.getType(c)+ ") sent to "+ c.getSessionReference()+ " is pending completion with a "+ timeout+ "ms timeout");
  }
  final Set<String> classes=new HashSet<String>();
  classes.add("Task/" + task.toWireString());
  String token="";
  final Double t=new Double(timeout / 1000);
  while (true) {
    final EventBatch map=Event.from(c,classes,token,t);
    token=map.token;
    @SuppressWarnings("unchecked") final Set<Event.Record> events=map.events;
    if (events.size() == 0) {
      final String msg="No event for task " + task.toWireString();
      s_logger.warn(msg);
      task.cancel(c);
      throw new TimeoutException(msg);
    }
    for (    final Event.Record rec : events) {
      if (!(rec.snapshot instanceof Task.Record)) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Skipping over " + rec);
        }
        continue;
      }
      final Task.Record taskRecord=(Task.Record)rec.snapshot;
      if (taskRecord.status != Types.TaskStatusType.PENDING) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Task, ref:" + task.toWireString() + ", UUID:"+ taskRecord.uuid+ " is done "+ taskRecord.status);
        }
        return;
      }
 else {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Task: ref:" + task.toWireString() + ", UUID:"+ taskRecord.uuid+ " progress: "+ taskRecord.progress);
        }
      }
    }
    if (System.currentTimeMillis() - beginTime > timeout) {
      final String msg="Async " + timeout / 1000 + " seconds timeout for task " + task.toString();
      s_logger.warn(msg);
      task.cancel(c);
      throw new TimeoutException(msg);
    }
  }
}

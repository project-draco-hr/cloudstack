{
  Long volumeId=cmd.getVolumeId();
  VolumeVO volume=_volsDao.findById(cmd.getVolumeId());
  if (volume == null) {
    throw new InvalidParameterValueException("Failed to create snapshot policy, unable to find a volume with id " + volumeId);
  }
  AccountVO owner=_accountDao.findById(volume.getAccountId());
  DomainVO domain=_domainDao.findById(owner.getDomainId());
  checkAccountPermissions(volume.getAccountId(),volume.getDomainId(),"volume",volumeId);
  StoragePoolVO storagePoolVO=_storagePoolDao.findById(volume.getPoolId());
  if (storagePoolVO == null) {
    throw new InvalidParameterValueException("volumeId: " + volumeId + " please attach this volume to a VM before create snapshot policy for it");
  }
  if (storagePoolVO.isLocal()) {
    throw new InvalidParameterValueException("Failed to create snapshot policy, cannot create a snapshot from a volume residing on a local storage pool, poolId: " + volume.getPoolId());
  }
  Long instanceId=volume.getInstanceId();
  if (instanceId != null) {
    if (_vmDao.findById(instanceId) == null) {
      throw new InvalidParameterValueException("Failed to create snapshot policy, snapshots of volumes attached to System or router VM are not allowed");
    }
  }
  IntervalType type=DateUtil.IntervalType.getIntervalType(cmd.getIntervalType());
  if (type == null) {
    throw new InvalidParameterValueException("Unsupported interval type " + cmd.getIntervalType());
  }
  TimeZone timeZone=TimeZone.getTimeZone(cmd.getTimezone());
  String timezoneId=timeZone.getID();
  if (!timezoneId.equals(cmd.getTimezone())) {
    s_logger.warn("Using timezone: " + timezoneId + " for running this snapshot policy as an equivalent of "+ cmd.getTimezone());
  }
  try {
    DateUtil.getNextRunTime(type,cmd.getSchedule(),timezoneId,null);
  }
 catch (  Exception e) {
    throw new InvalidParameterValueException("Invalid schedule: " + cmd.getSchedule() + " for interval type: "+ cmd.getIntervalType());
  }
  int intervalMaxSnaps=type.getMax();
  if (cmd.getMaxSnaps() > intervalMaxSnaps) {
    throw new InvalidParameterValueException("maxSnaps exceeds limit: " + intervalMaxSnaps + " for interval type: "+ cmd.getIntervalType());
  }
  long accountLimit=_accountMgr.findCorrectResourceLimit(owner,ResourceType.snapshot);
  long domainLimit=_accountMgr.findCorrectResourceLimit(domain,ResourceType.snapshot);
  int max=cmd.getMaxSnaps().intValue();
  if (owner.getType() != Account.ACCOUNT_TYPE_ADMIN && ((accountLimit != -1 && max > accountLimit) || (domainLimit != -1 && max > domainLimit))) {
    throw new InvalidParameterValueException("Max number of snapshots shouldn't exceed the domain/account level snapshot limit");
  }
  SnapshotPolicyVO policy=new SnapshotPolicyVO(volumeId,cmd.getSchedule(),timezoneId,(short)type.ordinal(),cmd.getMaxSnaps());
  try {
    policy=_snapshotPolicyDao.persist(policy);
  }
 catch (  EntityExistsException e) {
    policy=_snapshotPolicyDao.findOneByVolume(volumeId);
    try {
      policy=_snapshotPolicyDao.acquireInLockTable(policy.getId());
      policy.setSchedule(cmd.getSchedule());
      policy.setTimezone(timezoneId);
      policy.setInterval((short)type.ordinal());
      policy.setMaxSnaps(cmd.getMaxSnaps());
      policy.setActive(true);
      _snapshotPolicyDao.update(policy.getId(),policy);
    }
  finally {
      if (policy != null) {
        _snapshotPolicyDao.releaseFromLockTable(policy.getId());
      }
    }
  }
  _snapSchedMgr.scheduleNextSnapshotJob(policy);
  return policy;
}

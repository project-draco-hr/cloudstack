{
  long zoneId=network.getDataCenterId();
  DataCenterVO zone=_dcDao.findById(zoneId);
  HealthCheckLBConfigAnswer answer=null;
  List<LoadBalancingRule> loadBalancingRules=new ArrayList<LoadBalancingRule>();
  for (  FirewallRule rule : rules) {
    if (rule.getPurpose().equals(Purpose.LoadBalancing)) {
      loadBalancingRules.add((LoadBalancingRule)rule);
    }
  }
  if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {
    return null;
  }
  ExternalLoadBalancerDeviceVO lbDeviceVO=getExternalLoadBalancerForNetwork(network);
  if (lbDeviceVO == null) {
    s_logger.warn("There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning");
    return null;
  }
  HostVO externalLoadBalancer=_hostDao.findById(lbDeviceVO.getHostId());
  boolean externalLoadBalancerIsInline=_networkMgr.isNetworkInlineMode(network);
  if (network.getState() == Network.State.Allocated) {
    s_logger.debug("External load balancer was asked to apply LB rules for network with ID " + network.getId() + "; this network is not implemented. Skipping backend commands.");
    return null;
  }
  List<LoadBalancerTO> loadBalancersToApply=new ArrayList<LoadBalancerTO>();
  List<MappingState> mappingStates=new ArrayList<MappingState>();
  for (int i=0; i < loadBalancingRules.size(); i++) {
    LoadBalancingRule rule=loadBalancingRules.get(i);
    boolean revoked=(rule.getState().equals(FirewallRule.State.Revoke));
    String protocol=rule.getProtocol();
    String algorithm=rule.getAlgorithm();
    String uuid=rule.getUuid();
    String srcIp=_networkModel.getIp(rule.getSourceIpAddressId()).getAddress().addr();
    int srcPort=rule.getSourcePortStart();
    List<LbDestination> destinations=rule.getDestinations();
    if (externalLoadBalancerIsInline) {
      MappingNic nic=getLoadBalancingIpNic(zone,network,rule.getSourceIpAddressId(),revoked,null);
      mappingStates.add(nic.getState());
      NicVO loadBalancingIpNic=nic.getNic();
      if (loadBalancingIpNic == null) {
        continue;
      }
      srcIp=loadBalancingIpNic.getIp4Address();
    }
    if ((destinations != null && !destinations.isEmpty()) || !rule.isAutoScaleConfig()) {
      boolean inline=_networkMgr.isNetworkInlineMode(network);
      LoadBalancerTO loadBalancer=new LoadBalancerTO(uuid,srcIp,srcPort,protocol,algorithm,revoked,false,inline,destinations,rule.getStickinessPolicies(),rule.getHealthCheckPolicies());
      loadBalancersToApply.add(loadBalancer);
    }
  }
  try {
    if (loadBalancersToApply.size() > 0) {
      int numLoadBalancersForCommand=loadBalancersToApply.size();
      LoadBalancerTO[] loadBalancersForCommand=loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);
      HealthCheckLBConfigCommand cmd=new HealthCheckLBConfigCommand(loadBalancersForCommand);
      long guestVlanTag=Integer.parseInt(network.getBroadcastUri().getHost());
      cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG,String.valueOf(guestVlanTag));
      answer=(HealthCheckLBConfigAnswer)_agentMgr.easySend(externalLoadBalancer.getId(),cmd);
    }
  }
 catch (  Exception ex) {
    s_logger.error("Exception Occured ",ex);
  }
  return answer.getLoadBalancers();
}

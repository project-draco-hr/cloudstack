{
synchronized (coordinator.peers) {
    long worstdownload=Long.MAX_VALUE;
    Peer worstDownloader=null;
    int peers=0;
    int uploaders=0;
    int downloaders=0;
    int interested=0;
    int interesting=0;
    int choking=0;
    int choked=0;
    long uploaded=0;
    long downloaded=0;
    List<Peer> removed=new ArrayList<Peer>();
    Iterator it=coordinator.peers.iterator();
    while (it.hasNext()) {
      Peer peer=(Peer)it.next();
      if (!peer.isConnected()) {
        it.remove();
        continue;
      }
      peers++;
      if (!peer.isChoking()) {
        uploaders++;
      }
      if (!peer.isChoked() && peer.isInteresting()) {
        downloaders++;
      }
      if (peer.isInterested()) {
        interested++;
      }
      if (peer.isInteresting()) {
        interesting++;
      }
      if (peer.isChoking()) {
        choking++;
      }
      if (peer.isChoked()) {
        choked++;
      }
      long upload=peer.getUploaded();
      uploaded+=upload;
      long download=peer.getDownloaded();
      downloaded+=download;
      peer.resetCounters();
      log.log(Level.FINEST,peer + ":" + " ul: "+ upload / KILOPERSECOND + " dl: " + download / KILOPERSECOND + " i: " + peer.isInterested() + " I: " + peer.isInteresting() + " c: " + peer.isChoking() + " C: " + peer.isChoked());
      if (coordinator.uploaders >= PeerCoordinator.MAX_UPLOADERS && interested > PeerCoordinator.MAX_UPLOADERS && !peer.isChoking()) {
        if (!peer.isInterested()) {
          log.log(Level.FINER,"Choke uninterested peer: " + peer);
          peer.setChoking(true);
          uploaders--;
          coordinator.uploaders--;
          it.remove();
          removed.add(peer);
        }
 else         if (peer.isChoked()) {
          log.log(Level.FINEST,"Choke choking peer: " + peer);
          peer.setChoking(true);
          uploaders--;
          coordinator.uploaders--;
          it.remove();
          removed.add(peer);
        }
 else         if (peer.isInteresting() && !peer.isChoked() && download == 0) {
          log.log(Level.FINEST,"Choke downloader that doesn't deliver:" + peer);
          peer.setChoking(true);
          uploaders--;
          coordinator.uploaders--;
          it.remove();
          removed.add(peer);
        }
 else         if (!peer.isChoking() && download < worstdownload) {
          worstdownload=download;
          worstDownloader=peer;
        }
      }
    }
    coordinator.uploaders=uploaders;
    if (uploaders >= PeerCoordinator.MAX_UPLOADERS && interested > PeerCoordinator.MAX_UPLOADERS && worstDownloader != null) {
      log.log(Level.FINEST,"Choke worst downloader: " + worstDownloader);
      worstDownloader.setChoking(true);
      coordinator.uploaders--;
      coordinator.peers.remove(worstDownloader);
      removed.add(worstDownloader);
    }
    coordinator.unchokePeer();
    coordinator.peers.addAll(removed);
  }
}

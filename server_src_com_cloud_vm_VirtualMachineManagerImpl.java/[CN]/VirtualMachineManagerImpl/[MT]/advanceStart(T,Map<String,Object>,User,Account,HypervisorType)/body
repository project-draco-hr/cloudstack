{
  State state=vm.getState();
  if (state == State.Running) {
    s_logger.debug("VM is already started: " + vm);
    return vm;
  }
  if (state == State.Starting) {
  }
  if (state != State.Stopped) {
    s_logger.debug("VM " + vm + " is not in a state to be started: "+ state);
    return null;
  }
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Creating actual resources for VM " + vm);
  }
  Journal journal=new Journal.LogJournal("Creating " + vm,s_logger);
  ItWorkVO work=new ItWorkVO(UUID.randomUUID().toString(),_nodeId,ItWorkVO.Type.Start,vm.getId());
  work=_workDao.persist(work);
  ReservationContextImpl context=new ReservationContextImpl(work.getId(),journal,caller,account);
  ServiceOfferingVO offering=_offeringDao.findById(vm.getServiceOfferingId());
  VMTemplateVO template=_templateDao.findById(vm.getTemplateId());
  DataCenterDeployment plan=new DataCenterDeployment(vm.getDataCenterId(),vm.getPodId(),null,null);
  HypervisorGuru hvGuru;
  if (hyperType != null && !hyperType.equals(HypervisorType.None)) {
    hvGuru=_hvGurus.get(hyperType);
  }
 else {
    hvGuru=_hvGurus.get(template.getHypervisorType());
  }
  @SuppressWarnings("unchecked") VirtualMachineGuru<T> vmGuru=(VirtualMachineGuru<T>)_vmGurus.get(vm.getType());
  vm.setReservationId(work.getId());
  ExcludeList avoids=new ExcludeList();
  int retry=_retry;
  DeployDestination dest=null;
  while (retry-- != 0) {
    VirtualMachineProfileImpl<T> vmProfile=new VirtualMachineProfileImpl<T>(vm,template,offering,null,params,hyperType);
    for (    DeploymentPlanner planner : _planners) {
      dest=planner.plan(vmProfile,plan,avoids);
      if (dest != null) {
        avoids.addHost(dest.getHost().getId());
        journal.record("Deployment found ",vmProfile,dest);
        break;
      }
    }
    if (dest == null) {
      if (retry != (_retry - 1)) {
        stateTransitTo(vm,Event.OperationFailed,null);
      }
      throw new InsufficientServerCapacityException("Unable to create a deployment for " + vmProfile,DataCenter.class,plan.getDataCenterId());
    }
    if (retry == (_retry - 1)) {
      if (!stateTransitTo(vm,Event.StartRequested,dest.getHost().getId())) {
        throw new ConcurrentOperationException("Unable to start vm " + vm + " due to concurrent operations");
      }
    }
 else {
      stateTransitTo(vm,Event.OperationRetry,dest.getHost().getId());
    }
    vm.setDataCenterId(dest.getDataCenter().getId());
    vm.setPodId(dest.getPod().getId());
    try {
      _storageMgr.prepare(vmProfile,dest);
      _networkMgr.prepare(vmProfile,dest,context);
    }
 catch (    ConcurrentOperationException e) {
      stateTransitTo(vm,Event.OperationFailed,null);
      throw e;
    }
catch (    ResourceUnavailableException e) {
      s_logger.warn("Unable to contact storage.",e);
      avoids.addCluster(dest.getCluster().getId());
      continue;
    }
catch (    InsufficientCapacityException e) {
      s_logger.warn("Insufficient capacity ",e);
      avoids.add(e);
      continue;
    }
catch (    RuntimeException e) {
      s_logger.warn("Failed to start instance " + vm,e);
      stateTransitTo(vm,Event.OperationFailed,null);
      return null;
    }
    vmGuru.finalizeVirtualMachineProfile(vmProfile,dest,context);
    VirtualMachineTO vmTO=hvGuru.implement(vmProfile);
    Commands cmds=new Commands(OnError.Revert);
    cmds.addCommand(new StartCommand(vmTO));
    vmGuru.finalizeDeployment(cmds,vmProfile,dest,context);
    try {
      Answer[] answers=_agentMgr.send(dest.getHost().getId(),cmds);
      if (getStartAnswer(answers).getResult() && vmGuru.finalizeStart(cmds,vmProfile,dest,context)) {
        if (!stateTransitTo(vm,Event.OperationSucceeded,dest.getHost().getId())) {
          throw new CloudRuntimeException("Unable to transition to a new state.");
        }
        if (vm instanceof UserVm) {
          UsageEventVO usageEvent=new UsageEventVO(EventTypes.EVENT_VM_START,vm.getAccountId(),vm.getDataCenterId(),vm.getId(),vm.getName(),vm.getServiceOfferingId(),vm.getTemplateId(),null);
          _usageEventDao.persist(usageEvent);
        }
        return vm;
      }
      s_logger.info("Unable to start VM on " + dest.getHost() + " due to "+ answers[0].getDetails());
    }
 catch (    AgentUnavailableException e) {
      s_logger.debug("Unable to send the start command to host " + dest.getHost());
      continue;
    }
catch (    OperationTimedoutException e) {
      s_logger.debug("Unable to send the start command to host " + dest.getHost());
      continue;
    }
  }
  stateTransitTo(vm,Event.OperationFailed,null);
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Creation complete for VM " + vm);
  }
  return null;
}

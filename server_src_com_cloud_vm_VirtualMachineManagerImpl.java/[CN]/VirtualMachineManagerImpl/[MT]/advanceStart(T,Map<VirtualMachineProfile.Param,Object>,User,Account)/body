{
  long vmId=vm.getId();
  VirtualMachineGuru<T> vmGuru=getVmGuru(vm);
  vm=vmGuru.findById(vm.getId());
  Ternary<T,ReservationContext,ItWorkVO> start=changeToStartState(vmGuru,vm,caller,account);
  if (start == null) {
    return vmGuru.findById(vmId);
  }
  vm=start.first();
  ReservationContext ctx=start.second();
  ItWorkVO work=start.third();
  T startedVm=null;
  ServiceOfferingVO offering=_offeringDao.findById(vm.getServiceOfferingId());
  VMTemplateVO template=_templateDao.findById(vm.getTemplateId());
  DataCenterDeployment plan=new DataCenterDeployment(vm.getDataCenterId(),vm.getPodId(),null,null);
  HypervisorGuru hvGuru=_hvGurus.get(vm.getHypervisorType());
  try {
    Journal journal=start.second().getJournal();
    ExcludeList avoids=new ExcludeList();
    int retry=_retry;
    while (retry-- != 0) {
      VirtualMachineProfileImpl<T> vmProfile=new VirtualMachineProfileImpl<T>(vm,template,offering,null,params);
      DeployDestination dest=null;
      for (      DeploymentPlanner planner : _planners) {
        dest=planner.plan(vmProfile,plan,avoids);
        if (dest != null) {
          avoids.addHost(dest.getHost().getId());
          journal.record("Deployment found ",vmProfile,dest);
          break;
        }
      }
      if (dest == null) {
        throw new InsufficientServerCapacityException("Unable to create a deployment for " + vmProfile,DataCenter.class,plan.getDataCenterId());
      }
      long destHostId=dest.getHost().getId();
      if (!changeState(vm,Event.OperationRetry,destHostId,work,Step.Prepare)) {
        throw new ConcurrentOperationException("Unable to update the state of the Virtual Machine");
      }
      try {
        _storageMgr.prepare(vmProfile,dest);
        _networkMgr.prepare(vmProfile,dest,ctx);
        vmGuru.finalizeVirtualMachineProfile(vmProfile,dest,ctx);
        VirtualMachineTO vmTO=hvGuru.implement(vmProfile);
        Commands cmds=new Commands(OnError.Revert);
        cmds.addCommand(new StartCommand(vmTO));
        vmGuru.finalizeDeployment(cmds,vmProfile,dest,ctx);
        vm.setPodId(dest.getPod().getId());
        work=_workDao.findById(work.getId());
        if (work == null || work.getStep() != Step.Prepare) {
          throw new ConcurrentOperationException("Work steps have been changed: " + work);
        }
        _workDao.updateStep(work,Step.Start);
        _agentMgr.send(destHostId,cmds);
        _workDao.updateStep(work,Step.Started);
        Answer startAnswer=cmds.getAnswer(StartAnswer.class);
        if (startAnswer != null && startAnswer.getResult()) {
          if (vmGuru.finalizeStart(vmProfile,destHostId,cmds,ctx)) {
            if (!changeState(vm,Event.OperationSucceeded,destHostId,work,Step.Done)) {
              throw new ConcurrentOperationException("Unable to transition to a new state.");
            }
            startedVm=vm;
            if (s_logger.isDebugEnabled()) {
              s_logger.debug("Creation complete for VM " + vm);
            }
            return startedVm;
          }
        }
        s_logger.info("Unable to start VM on " + dest.getHost() + " due to "+ (startAnswer == null ? " no start answer" : startAnswer.getDetails()));
      }
 catch (      OperationTimedoutException e) {
        s_logger.debug("Unable to send the start command to host " + dest.getHost());
        if (e.isActive()) {
        }
        avoids.addHost(destHostId);
        continue;
      }
catch (      ResourceUnavailableException e) {
        if (!avoids.add(e)) {
          if (e.getScope() == Volume.class || e.getScope() == Nic.class) {
            throw e;
          }
 else {
            throw new CloudRuntimeException("Resource is not available to start the VM.",e);
          }
        }
        s_logger.info("Unable to contact resource.",e);
        continue;
      }
catch (      InsufficientCapacityException e) {
        if (!avoids.add(e)) {
          if (e.getScope() == Volume.class || e.getScope() == Nic.class) {
            throw e;
          }
 else {
            throw new CloudRuntimeException("Insufficient capacity to start the VM.",e);
          }
        }
        s_logger.info("Insufficient capacity ",e);
        continue;
      }
catch (      RuntimeException e) {
        s_logger.warn("Failed to start instance " + vm,e);
        throw e;
      }
 finally {
        if (startedVm == null) {
          _workDao.updateStep(work,Step.Release);
          cleanup(vmGuru,vmProfile,work,Event.OperationFailed,false,caller,account);
        }
      }
    }
  }
  finally {
    if (startedVm == null) {
      changeState(vm,Event.OperationFailed,null,work,Step.Done);
    }
  }
  return startedVm;
}

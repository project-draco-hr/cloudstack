@attr(tags=['advanced', 'dvs'], required_hardware='true')
def test_01_list_ipaddresses_pagination(self):
    '\n        @summary: Test List IP Addresses pagination\n        @Steps:\n        Step1: Creating a network for the user\n        Step2: Listing all the IP Addresses for a user\n        Step3: Verifying that no IP Addresses are listed\n        Step4: Associating (pagesize + 1) number of IP Addresses\n        Step5: Listing all the IP Addresses again\n        Step6: Verifying the length of the IP Addresses is (page size + 1)\n        Step7: Listing all the IP Addresses in page1\n        Step8: Verifying that the length of the IP Addresses in page 1 is\n               (page size)\n        Step9: Listing all the IP Addresses in page2\n        Step10: Verifying that the length of the IP Addresses in page 2 is 1\n        Step11: Dis-Associating the IP Addresses present in page 2\n        Step12: Listing for the IP Addresses on page 2\n        Step13: Verifying that no IP Addresses are listed\n        '
    networks_list_before = Network.list(self.userapiclient, forvpc='false', domainid=self.domain.id, account=self.account.name, type='Isolated')
    self.assertIsNone(networks_list_before, 'Networks listed for newly created user')
    network_offerings_list = NetworkOffering.list(self.apiClient, forvpc='false', guestiptype='Isolated', state='Enabled', supportedservices='SourceNat', zoneid=self.zone.id)
    status = validateList(network_offerings_list)
    self.assertEquals(PASS, status[0], 'Isolated Network Offerings with sourceNat enabled are not found')
    network = Network.create(self.userapiclient, self.services['network'], accountid=self.account.name, domainid=self.domain.id, networkofferingid=network_offerings_list[0].id, zoneid=self.zone.id)
    self.assertIsNotNone(network, 'Network creation failed')
    self.cleanup.append(network)
    networks_list_after = Network.list(self.userapiclient, forvpc='false', domainid=self.domain.id, account=self.account.name, type='Isolated')
    status = validateList(networks_list_after)
    self.assertEquals(PASS, status[0], 'Network Creation Failed')
    self.assertEquals(1, len(networks_list_after), 'Network creation failed')
    list_ipaddresses_before = PublicIPAddress.list(self.userapiclient, listall=self.services['listall'])
    self.assertIsNone(list_ipaddresses_before, 'IP Addresses listed for newly created user')
    for i in range(0, (self.services['pagesize'] + 1)):
        ipaddress = PublicIPAddress.create(self.userapiclient, services=self.services['network'], networkid=network.id)
        self.assertIsNotNone(ipaddress, 'Failed to Associate IP Address')
    list_ipaddresses_after = PublicIPAddress.list(self.userapiclient, listall=self.services['listall'])
    status = validateList(list_ipaddresses_after)
    self.assertEquals(PASS, status[0], 'IP Addresses Association Failed')
    self.assertEqual((self.services['pagesize'] + 1), len(list_ipaddresses_after), 'Number of IP Addresses associated are not matching expected')
    list_ipaddress_page1 = PublicIPAddress.list(self.userapiclient, listall=self.services['listall'], page=1, pagesize=self.services['pagesize'])
    status = validateList(list_ipaddress_page1)
    self.assertEquals(PASS, status[0], 'Failed to list IP Addresses in page1')
    self.assertEquals(self.services['pagesize'], len(list_ipaddress_page1), 'Failed to list pagesize number of IP Addresses in page1')
    list_ipaddress_page2 = PublicIPAddress.list(self.userapiclient, listall=self.services['listall'], page=2, pagesize=self.services['pagesize'])
    status = validateList(list_ipaddress_page2)
    self.assertEquals(PASS, status[0], 'Failed to list IP Addresses in page2')
    self.assertEquals(1, len(list_ipaddress_page2), 'Failed to list IP Addresses in page2')
    ipaddress.delete(self.userapiclient)
    list_ipaddress_page2 = PublicIPAddress.list(self.userapiclient, listall=self.services['listall'], page=2, pagesize=self.services['pagesize'])
    self.assertIsNone(list_ipaddress_page2, 'Disassociation of IP Address Failed')
    self.cleanup.append(self.account)
    return

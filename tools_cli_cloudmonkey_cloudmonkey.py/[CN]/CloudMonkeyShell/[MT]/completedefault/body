def completedefault(self, text, line, begidx, endidx):
    partitions = line.partition(' ')
    verb = partitions[0].strip()
    rline = partitions[2].lstrip().partition(' ')
    subject = rline[0]
    separator = rline[1]
    params = rline[2].lstrip()
    if (verb not in self.verbs):
        return []
    autocompletions = []
    search_string = ''
    if (separator != ' '):
        autocompletions = self.apicache[verb].keys()
        search_string = subject
    else:
        autocompletions = map((lambda x: (x + '=')), map((lambda x: x['name']), self.apicache[verb][subject]['params']))
        search_string = text
        if (self.paramcompletion == 'true'):
            param = line.split(' ')[(-1)]
            idx = param.find('=')
            value = param[(idx + 1):]
            param = param[:idx]
            if ((len(value) < 36) and (idx != (-1))):
                params = self.apicache[verb][subject]['params']
                related = filter((lambda x: (x['name'] == param)), params)[0]['related']
                api = min(filter((lambda x: ('list' in x)), related), key=len)
                response = self.make_request(api, args={'listall': 'true', })
                responsekey = filter((lambda x: ('response' in x)), response.keys())[0]
                result = response[responsekey]
                uuids = []
                for key in result.keys():
                    if isinstance(result[key], list):
                        for element in result[key]:
                            if ('id' in element.keys()):
                                uuids.append(element['id'])
                autocompletions = uuids
                search_string = value
    if ((subject != '') and ((self.display == 'tabularize') or (self.display == 'json') or (self.tabularize == 'true'))):
        autocompletions.append('filter=')
    return [s for s in autocompletions if s.startswith(search_string)]

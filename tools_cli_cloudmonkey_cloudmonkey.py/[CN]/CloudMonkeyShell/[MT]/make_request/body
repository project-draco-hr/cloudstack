def make_request(self, command, requests={}, isAsync=False):
    conn = cloudConnection(self.host, port=int(self.port), apiKey=self.apikey, securityKey=self.secretkey, asyncTimeout=self.timeout, logging=logger, protocol=self.protocol, path=self.path)
    response = None
    logger.debug('====START Request====')
    logger.debug(('Requesting command=%s, args=%s' % (command, requests)))
    try:
        response = conn.make_request_with_auth(command, requests)
    except cloudstackAPIException as e:
        self.print_shell('API Error:', e)
    except HTTPError as e:
        self.print_shell(e)
    except (URLError, BadStatusLine) as e:
        self.print_shell('Connection Error:', e)
    logger.debug('====END Request====\n')

    def process_json(response):
        try:
            response = json.loads(str(response))
        except ValueError as e:
            pass
        return response
    response = process_json(response)
    if (response is None):
        return
    isAsync = (isAsync and (self.asyncblock == 'true'))
    responsekey = filter((lambda x: ('response' in x)), response.keys())[0]
    if (isAsync and ('jobid' in response[responsekey])):
        jobId = response[responsekey]['jobid']
        command = 'queryAsyncJobResult'
        requests = {'jobid': jobId, }
        timeout = int(self.timeout)
        pollperiod = 3
        progress = 1
        while (timeout > 0):
            print ('\r' + ('.' * progress)),
            sys.stdout.flush()
            response = process_json(conn.make_request_with_auth(command, requests))
            responsekeys = filter((lambda x: ('response' in x)), response.keys())
            if (len(responsekeys) < 1):
                continue
            result = response[responsekeys[0]]
            jobstatus = result['jobstatus']
            if (jobstatus == 2):
                jobresult = result['jobresult']
                self.print_shell('\rAsync query failed for jobid', jobId, '\nError', jobresult['errorcode'], jobresult['errortext'])
                return
            elif (jobstatus == 1):
                print '\r',
                return response
            time.sleep(pollperiod)
            timeout = (timeout - pollperiod)
            progress += 1
            logger.debug(('job: %s to timeout in %ds' % (jobId, timeout)))
        self.print_shell('Error:', 'Async query timeout for jobid', jobId)
    return response

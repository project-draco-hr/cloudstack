{
  AsyncCallFuture<VolumeApiResult> future=new AsyncCallFuture<VolumeApiResult>();
  VolumeApiResult result=new VolumeApiResult(volume);
  if (volume.getDataStore() == null) {
    volDao.remove(volume.getId());
    future.complete(result);
    return future;
  }
  String vmName=null;
  VolumeVO vol=volDao.findById(volume.getId());
  if (vol.getVolumeType() == Type.ROOT && vol.getInstanceId() != null) {
    VirtualMachine vm=vmDao.findByIdIncludingRemoved(vol.getInstanceId());
    if (vm != null) {
      vmName=vm.getInstanceName();
    }
  }
  String volumePath=vol.getPath();
  Long poolId=vol.getPoolId();
  if (poolId == null || volumePath == null || volumePath.trim().isEmpty()) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Marking volume that was never created as destroyed: " + vol);
    }
    volDao.remove(vol.getId());
    future.complete(result);
    return future;
  }
  VolumeObject vo=(VolumeObject)volume;
  volume.processEvent(Event.ExpungeRequested);
  DeleteVolumeContext<VolumeApiResult> context=new DeleteVolumeContext<VolumeApiResult>(null,vo,future);
  AsyncCallbackDispatcher<VolumeServiceImpl,CommandResult> caller=AsyncCallbackDispatcher.create(this);
  caller.setCallback(caller.getTarget().deleteVolumeCallback(null,null)).setContext(context);
  volume.getDataStore().getDriver().deleteAsync(volume,caller);
  return future;
}

{
  VolumeInfo srcVolume=context.srcVolume;
  VolumeInfo destVolume=context.destVolume;
  CopyCommandResult result=callback.getResult();
  AsyncCallFuture<VolumeApiResult> future=context.future;
  VolumeApiResult res=new VolumeApiResult(destVolume);
  try {
    if (result.isFailed()) {
      res.setResult(result.getResult());
      destVolume.processEvent(Event.MigrationCopyFailed);
      srcVolume.processEvent(Event.OperationFailed);
      destroyVolume(destVolume.getId());
      destVolume=volFactory.getVolume(destVolume.getId());
      AsyncCallFuture<VolumeApiResult> destroyFuture=expungeVolumeAsync(destVolume);
      destroyFuture.get();
      future.complete(res);
      return null;
    }
    srcVolume.processEvent(Event.OperationSuccessed);
    destVolume.processEvent(Event.MigrationCopySucceeded,result.getAnswer());
    _volumeDao.updateUuid(srcVolume.getId(),destVolume.getId());
    try {
      destroyVolume(srcVolume.getId());
      srcVolume=volFactory.getVolume(srcVolume.getId());
      AsyncCallFuture<VolumeApiResult> destroyFuture=expungeVolumeAsync(srcVolume);
      if (destroyFuture.get().isFailed()) {
        Thread.sleep(5 * 1000);
        destroyFuture=expungeVolumeAsync(srcVolume);
        destroyFuture.get();
      }
      future.complete(res);
    }
 catch (    Exception e) {
      s_logger.debug("failed to clean up volume on storage",e);
    }
    return null;
  }
 catch (  Exception e) {
    s_logger.debug("Failed to process copy volume callback",e);
    res.setResult(e.toString());
    future.complete(res);
  }
  return null;
}

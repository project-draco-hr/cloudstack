{
  if (store == null) {
    s_logger.warn("Huh? ssHost is null");
    return;
  }
  long storeId=store.getId();
  Long zoneId=store.getScope().getScopeId();
  Map<Long,TemplateProp> volumeInfos=listVolume(store);
  if (volumeInfos == null) {
    return;
  }
  List<VolumeDataStoreVO> dbVolumes=_volumeStoreDao.listByStoreId(storeId);
  List<VolumeDataStoreVO> toBeDownloaded=new ArrayList<VolumeDataStoreVO>(dbVolumes);
  for (  VolumeDataStoreVO volumeStore : dbVolumes) {
    VolumeVO volume=_volumeDao.findById(volumeStore.getVolumeId());
    if (volumeInfos.containsKey(volume.getId())) {
      TemplateProp volInfo=volumeInfos.remove(volume.getId());
      toBeDownloaded.remove(volumeStore);
      s_logger.info("Volume Sync found " + volume.getUuid() + " already in the volume image store table");
      if (volumeStore.getDownloadState() != Status.DOWNLOADED) {
        volumeStore.setErrorString("");
      }
      if (volInfo.isCorrupted()) {
        volumeStore.setDownloadState(Status.DOWNLOAD_ERROR);
        String msg="Volume " + volume.getUuid() + " is corrupted on image store ";
        volumeStore.setErrorString(msg);
        s_logger.info("msg");
        if (volumeStore.getDownloadUrl() == null) {
          msg="Volume (" + volume.getUuid() + ") with install path "+ volInfo.getInstallPath()+ "is corrupted, please check in image store: "+ volumeStore.getDataStoreId();
          s_logger.warn(msg);
        }
 else {
          toBeDownloaded.add(volumeStore);
        }
      }
 else {
        volumeStore.setDownloadPercent(100);
        volumeStore.setDownloadState(Status.DOWNLOADED);
        volumeStore.setInstallPath(volInfo.getInstallPath());
        volumeStore.setSize(volInfo.getSize());
        volumeStore.setPhysicalSize(volInfo.getPhysicalSize());
        volumeStore.setLastUpdated(new Date());
        _volumeStoreDao.update(volumeStore.getId(),volumeStore);
        if (volume.getSize() == 0) {
          volume.setSize(volInfo.getSize());
          _volumeDao.update(volumeStore.getVolumeId(),volume);
        }
        if (volInfo.getSize() > 0) {
          try {
            String url=_volumeStoreDao.findByVolume(volume.getId()).getDownloadUrl();
            _resourceLimitMgr.checkResourceLimit(_accountMgr.getAccount(volume.getAccountId()),com.cloud.configuration.Resource.ResourceType.secondary_storage,volInfo.getSize() - UriUtils.getRemoteSize(url));
          }
 catch (          ResourceAllocationException e) {
            s_logger.warn(e.getMessage());
            _alertMgr.sendAlert(_alertMgr.ALERT_TYPE_RESOURCE_LIMIT_EXCEEDED,volume.getDataCenterId(),volume.getPodId(),e.getMessage(),e.getMessage());
          }
 finally {
            _resourceLimitMgr.recalculateResourceCount(volume.getAccountId(),volume.getDomainId(),com.cloud.configuration.Resource.ResourceType.secondary_storage.getOrdinal());
          }
        }
      }
      continue;
    }
    if (volumeStore.getDownloadState() != Status.DOWNLOADED) {
      s_logger.info("Volume Sync did not find " + volume.getName() + " ready on image store "+ storeId+ ", will request download to start/resume shortly");
      toBeDownloaded.add(volumeStore);
    }
  }
  if (toBeDownloaded.size() > 0) {
    for (    VolumeDataStoreVO volumeHost : toBeDownloaded) {
      if (volumeHost.getDownloadUrl() == null) {
        continue;
      }
      s_logger.debug("Volume " + volumeHost.getVolumeId() + " needs to be downloaded to "+ store.getName());
      _dlMonitor.downloadVolumeToStorage(_volumeDao.findById(volumeHost.getVolumeId()),store,volumeHost.getDownloadUrl(),volumeHost.getChecksum(),volumeHost.getFormat(),null);
    }
  }
  for (  Long uniqueName : volumeInfos.keySet()) {
    TemplateProp vInfo=volumeInfos.get(uniqueName);
    DeleteVolumeCommand dtCommand=new DeleteVolumeCommand(store.getUri(),vInfo.getInstallPath());
    try {
      _agentMgr.sendToSecStorage(store,dtCommand,null);
    }
 catch (    AgentUnavailableException e) {
      String err="Failed to delete " + vInfo.getTemplateName() + " on image store "+ storeId+ " which isn't in the database";
      s_logger.error(err);
      return;
    }
    String description="Deleted volume " + vInfo.getTemplateName() + " on image store "+ storeId+ " since it isn't in the database";
    s_logger.info(description);
  }
}

{
  if (store == null) {
    s_logger.warn("Huh? ssHost is null");
    return;
  }
  long storeId=store.getId();
  Map<Long,TemplateProp> volumeInfos=listVolume(store);
  if (volumeInfos == null) {
    return;
  }
  List<VolumeDataStoreVO> dbVolumes=_volumeStoreDao.listByStoreId(storeId);
  List<VolumeDataStoreVO> toBeDownloaded=new ArrayList<VolumeDataStoreVO>(dbVolumes);
  for (  VolumeDataStoreVO volumeStore : dbVolumes) {
    VolumeVO volume=_volumeDao.findById(volumeStore.getVolumeId());
    if (volumeInfos.containsKey(volume.getId())) {
      TemplateProp volInfo=volumeInfos.remove(volume.getId());
      toBeDownloaded.remove(volumeStore);
      s_logger.info("Volume Sync found " + volume.getUuid() + " already in the volume image store table");
      if (volumeStore.getDownloadState() != Status.DOWNLOADED) {
        volumeStore.setErrorString("");
      }
      if (volInfo.isCorrupted()) {
        volumeStore.setDownloadState(Status.DOWNLOAD_ERROR);
        String msg="Volume " + volume.getUuid() + " is corrupted on image store ";
        volumeStore.setErrorString(msg);
        s_logger.info("msg");
        if (volumeStore.getDownloadUrl() == null) {
          msg="Volume (" + volume.getUuid() + ") with install path "+ volInfo.getInstallPath()+ "is corrupted, please check in image store: "+ volumeStore.getDataStoreId();
          s_logger.warn(msg);
        }
 else {
          toBeDownloaded.add(volumeStore);
        }
      }
 else {
        volumeStore.setDownloadPercent(100);
        volumeStore.setDownloadState(Status.DOWNLOADED);
        volumeStore.setInstallPath(volInfo.getInstallPath());
        volumeStore.setSize(volInfo.getSize());
        volumeStore.setPhysicalSize(volInfo.getPhysicalSize());
        volumeStore.setLastUpdated(new Date());
        _volumeStoreDao.update(volumeStore.getId(),volumeStore);
        if (volume.getSize() == 0) {
          volume.setSize(volInfo.getSize());
          _volumeDao.update(volumeStore.getVolumeId(),volume);
        }
        if (volInfo.getSize() > 0) {
          try {
            _resourceLimitMgr.checkResourceLimit(_accountMgr.getAccount(volume.getAccountId()),com.cloud.configuration.Resource.ResourceType.secondary_storage,volInfo.getSize() - volInfo.getPhysicalSize());
          }
 catch (          ResourceAllocationException e) {
            s_logger.warn(e.getMessage());
            _alertMgr.sendAlert(AlertManager.ALERT_TYPE_RESOURCE_LIMIT_EXCEEDED,volume.getDataCenterId(),volume.getPodId(),e.getMessage(),e.getMessage());
          }
 finally {
            _resourceLimitMgr.recalculateResourceCount(volume.getAccountId(),volume.getDomainId(),com.cloud.configuration.Resource.ResourceType.secondary_storage.getOrdinal());
          }
        }
      }
      continue;
    }
    if (volumeStore.getDownloadState() != Status.DOWNLOADED) {
      s_logger.info("Volume Sync did not find " + volume.getName() + " ready on image store "+ storeId+ ", will request download to start/resume shortly");
      toBeDownloaded.add(volumeStore);
    }
  }
  if (toBeDownloaded.size() > 0) {
    for (    VolumeDataStoreVO volumeHost : toBeDownloaded) {
      if (volumeHost.getDownloadUrl() == null) {
        continue;
      }
      s_logger.debug("Volume " + volumeHost.getVolumeId() + " needs to be downloaded to "+ store.getName());
      VolumeInfo vol=volFactory.getVolume(volumeHost.getVolumeId());
      createVolumeAsync(vol,store);
    }
  }
  for (  Long uniqueName : volumeInfos.keySet()) {
    TemplateProp tInfo=volumeInfos.get(uniqueName);
    VolumeObjectTO tmplTO=new VolumeObjectTO();
    tmplTO.setDataStore(store.getTO());
    tmplTO.setPath(tInfo.getInstallPath());
    tmplTO.setId(tInfo.getId());
    DeleteCommand dtCommand=new DeleteCommand(tmplTO);
    EndPoint ep=_epSelector.select(store);
    Answer answer=ep.sendMessage(dtCommand);
    if (answer == null || !answer.getResult()) {
      s_logger.info("Failed to deleted volume at store: " + store.getName());
    }
 else {
      String description="Deleted volume " + tInfo.getTemplateName() + " on secondary storage "+ storeId;
      s_logger.info(description);
    }
  }
}

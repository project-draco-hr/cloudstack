{
  long accountId=account.getId();
  boolean accountCleanupNeeded=false;
  try {
    List<InstanceGroupVO> groups=_vmGroupDao.listByAccountId(accountId);
    for (    InstanceGroupVO group : groups) {
      if (!_vmMgr.deleteVmGroup(group.getId())) {
        s_logger.error("Unable to delete group: " + group.getId());
        accountCleanupNeeded=true;
      }
    }
    boolean success=_snapMgr.deleteSnapshotDirsForAccount(accountId);
    if (success) {
      s_logger.debug("Successfully deleted snapshots directories for all volumes under account " + accountId + " across all zones");
    }
    List<VMTemplateVO> userTemplates=_templateDao.listByAccountId(accountId);
    boolean allTemplatesDeleted=true;
    for (    VMTemplateVO template : userTemplates) {
      try {
        allTemplatesDeleted=_tmpltMgr.delete(callerUserId,template.getId(),null);
      }
 catch (      Exception e) {
        s_logger.warn("Failed to delete template while removing account: " + template.getName() + " due to: "+ e.getMessage());
        allTemplatesDeleted=false;
      }
    }
    if (!allTemplatesDeleted) {
      s_logger.warn("Failed to delete templates while removing account id=" + accountId);
      accountCleanupNeeded=true;
    }
    List<UserVmVO> vms=_userVmDao.listByAccountId(accountId);
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Destroying # of vms (accountId=" + accountId + "): "+ vms.size());
    }
    for (    UserVmVO vm : vms) {
      if (!_vmMgr.expunge(vm,callerUserId,caller)) {
        s_logger.error("Unable to destroy vm: " + vm.getId());
        accountCleanupNeeded=true;
      }
      UsageEventVO usageEvent=new UsageEventVO(EventTypes.EVENT_VM_DESTROY,vm.getAccountId(),vm.getDataCenterId(),vm.getId(),vm.getName(),vm.getServiceOfferingId(),vm.getTemplateId(),null);
      _usageEventDao.persist(usageEvent);
    }
    List<VolumeVO> volumes=_volumeDao.findDetachedByAccount(accountId);
    for (    VolumeVO volume : volumes) {
      if (!volume.getState().equals(Volume.State.Destroy)) {
        _storageMgr.destroyVolume(volume);
        if (volume.getPoolId() != null) {
          UsageEventVO usageEvent=new UsageEventVO(EventTypes.EVENT_VOLUME_DELETE,volume.getAccountId(),volume.getDataCenterId(),volume.getId(),volume.getName(),null,null,null);
          _usageEventDao.persist(usageEvent);
        }
      }
    }
    int numRemoved=_securityGroupDao.removeByAccountId(accountId);
    s_logger.info("deleteAccount: Deleted " + numRemoved + " network groups for account "+ accountId);
    boolean networksDeleted=true;
    s_logger.debug("Deleting networks for account " + account.getId());
    List<NetworkVO> networks=_networkDao.listByOwner(accountId);
    if (networks != null) {
      for (      NetworkVO network : networks) {
        if (!_networkMgr.deleteNetworkInternal(network.getId(),callerUserId)) {
          s_logger.warn("Unable to destroy network " + network + " as a part of account id="+ accountId+ " cleanup.");
          accountCleanupNeeded=true;
          networksDeleted=false;
        }
 else {
          s_logger.debug("Network " + network.getId() + " successfully deleted as a part of account id="+ accountId+ " cleanup.");
        }
      }
    }
    if (networksDeleted) {
      if (!_configMgr.deleteAccountSpecificVirtualRanges(accountId)) {
        accountCleanupNeeded=true;
      }
 else {
        s_logger.debug("Account specific Virtual IP ranges " + " are successfully deleted as a part of account id=" + accountId + " cleanup.");
      }
    }
    return true;
  }
  finally {
    s_logger.info("Cleanup for account " + account.getId() + (accountCleanupNeeded ? " is needed." : " is not needed."));
    if (accountCleanupNeeded) {
      _accountDao.markForCleanup(accountId);
    }
  }
}

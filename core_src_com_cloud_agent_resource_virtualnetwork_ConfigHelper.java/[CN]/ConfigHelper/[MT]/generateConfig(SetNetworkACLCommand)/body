{
  LinkedList<ConfigItem> cfg=new LinkedList<>();
  String privateGw=cmd.getAccessDetail(NetworkElementCommand.VPC_PRIVATE_GATEWAY);
  String[][] rules=cmd.generateFwRules();
  String[] aclRules=rules[0];
  NicTO nic=cmd.getNic();
  String dev="eth" + nic.getDeviceId();
  String netmask=Long.toString(NetUtils.getCidrSize(nic.getNetmask()));
  StringBuilder sb=new StringBuilder();
  List<AclRule> ingressRules=new ArrayList<AclRule>();
  List<AclRule> egressRules=new ArrayList<AclRule>();
  for (int i=0; i < aclRules.length; i++) {
    AclRule aclRule;
    String[] ruleParts=aclRules[i].split(":");
switch (ruleParts[1].toLowerCase()) {
case "icmp":
      aclRule=new IcmpAclRule(ruleParts[4],"ACCEPT".equals(ruleParts[5]),Integer.parseInt(ruleParts[2]),Integer.parseInt(ruleParts[3]));
    break;
case "tcp":
  aclRule=new TcpAclRule(ruleParts[4],"ACCEPT".equals(ruleParts[5]),Integer.parseInt(ruleParts[2]),Integer.parseInt(ruleParts[3]));
break;
case "udp":
aclRule=new UdpAclRule(ruleParts[4],"ACCEPT".equals(ruleParts[5]),Integer.parseInt(ruleParts[2]),Integer.parseInt(ruleParts[3]));
break;
case "all":
aclRule=new AllAclRule(ruleParts[4],"ACCEPT".equals(ruleParts[5]));
break;
default :
aclRule=new ProtocolAclRule(ruleParts[4],"ACCEPT".equals(ruleParts[5]),Integer.parseInt(ruleParts[1]));
}
if ("Ingress".equals(ruleParts[0])) {
ingressRules.add(aclRule);
}
 else {
egressRules.add(aclRule);
}
}
sb.toString();
NetworkACL networkACL=new NetworkACL(dev,nic.getMac(),privateGw != null,nic.getIp(),netmask,ingressRules.toArray(new AclRule[ingressRules.size()]),egressRules.toArray(new AclRule[egressRules.size()]));
ConfigItem networkAclFile=new FileConfigItem(VRScripts.CONFIG_PERSIST_LOCATION,VRScripts.NETWORK_ACL_CONFIG,gson.toJson(networkACL));
cfg.add(networkAclFile);
ConfigItem updateNetworkACL=new ScriptConfigItem(VRScripts.UPDATE_CONFIG,VRScripts.NETWORK_ACL_CONFIG);
cfg.add(updateNetworkACL);
return cfg;
}

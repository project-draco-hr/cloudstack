{
  Long loadBalancerId=cmd.getLoadBalancerId();
  Long instanceIdParam=cmd.getVirtualMachineId();
  List<Long> instanceIds=cmd.getVirtualMachineIds();
  if ((instanceIdParam == null) && (instanceIds == null)) {
    throw new InvalidParameterValueException("Unable to assign to load balancer " + loadBalancerId + ", no instance id is specified.");
  }
  if ((instanceIds == null) && (instanceIdParam != null)) {
    instanceIds=new ArrayList<Long>();
    instanceIds.add(instanceIdParam);
  }
  LoadBalancerVO loadBalancer=_loadBalancerDao.findById(loadBalancerId);
  if (loadBalancer == null) {
    throw new InvalidParameterValueException("Failed to assign to load balancer " + loadBalancerId + ", the load balancer was not found.");
  }
  Account account=UserContext.current().getAccount();
  if (account != null) {
    if (account.getType() == Account.ACCOUNT_TYPE_DOMAIN_ADMIN) {
      if (!_domainDao.isChildDomain(account.getDomainId(),loadBalancer.getDomainId())) {
        throw new PermissionDeniedException("Failed to assign to load balancer " + loadBalancerId + ", permission denied.");
      }
    }
 else     if (account.getType() != Account.ACCOUNT_TYPE_ADMIN && account.getId() != loadBalancer.getAccountId()) {
      throw new PermissionDeniedException("Failed to assign to load balancer " + loadBalancerId + ", permission denied.");
    }
  }
  Transaction txn=Transaction.currentTxn();
  List<FirewallRuleVO> firewallRulesToApply=new ArrayList<FirewallRuleVO>();
  long accountId=0;
  DomainRouterVO router=null;
  List<LoadBalancerVMMapVO> mappedInstances=_loadBalancerVMMapDao.listByLoadBalancerId(loadBalancerId,false);
  Set<Long> mappedInstanceIds=new HashSet<Long>();
  if (mappedInstances != null) {
    for (    LoadBalancerVMMapVO mappedInstance : mappedInstances) {
      mappedInstanceIds.add(Long.valueOf(mappedInstance.getInstanceId()));
    }
  }
  List<Long> finalInstanceIds=new ArrayList<Long>();
  for (  Long instanceId : instanceIds) {
    if (mappedInstanceIds.contains(instanceId)) {
      continue;
    }
 else {
      finalInstanceIds.add(instanceId);
    }
    UserVmVO userVm=_vmDao.findById(instanceId);
    if (userVm == null) {
      s_logger.warn("Unable to find virtual machine with id " + instanceId);
      throw new InvalidParameterValueException("Unable to find virtual machine with id " + instanceId);
    }
 else {
      ServiceOfferingVO offering=_serviceOfferingDao.findById(userVm.getServiceOfferingId());
      if ((offering == null) || !GuestIpType.Virtualized.equals(offering.getGuestIpType())) {
        _loadBalancerVMMapDao.remove(loadBalancerId,instanceIds,Boolean.TRUE);
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Unable to add virtual machine " + userVm.toString() + " to load balancer "+ loadBalancerId+ ", bad network type ("+ ((offering == null) ? "null" : offering.getGuestIpType())+ ")");
        }
        throw new InvalidParameterValueException("Unable to add virtual machine " + userVm.toString() + " to load balancer "+ loadBalancerId+ ", bad network type ("+ ((offering == null) ? "null" : offering.getGuestIpType())+ ")");
      }
    }
    if (accountId == 0) {
      accountId=userVm.getAccountId();
    }
 else     if (accountId != userVm.getAccountId()) {
      s_logger.warn("guest vm " + userVm.getHostName() + " (id:"+ userVm.getId()+ ") belongs to account "+ userVm.getAccountId()+ ", previous vm in list belongs to account "+ accountId);
      throw new InvalidParameterValueException("guest vm " + userVm.getHostName() + " (id:"+ userVm.getId()+ ") belongs to account "+ userVm.getAccountId()+ ", previous vm in list belongs to account "+ accountId);
    }
    DomainRouterVO nextRouter=null;
    if (userVm.getDomainRouterId() != null) {
      nextRouter=_routerMgr.getRouter(userVm.getDomainRouterId());
    }
    if (nextRouter == null) {
      s_logger.warn("Unable to find router (" + userVm.getDomainRouterId() + ") for virtual machine with id "+ instanceId);
      throw new InvalidParameterValueException("Unable to find router (" + userVm.getDomainRouterId() + ") for virtual machine with id "+ instanceId);
    }
    if (router == null) {
      router=nextRouter;
      if (router.getAccountId() != loadBalancer.getAccountId()) {
        throw new InvalidParameterValueException("guest vm " + userVm.getHostName() + " (id:"+ userVm.getId()+ ") does not belong to the owner of load balancer "+ loadBalancer.getName()+ " (owner is account id "+ loadBalancer.getAccountId()+ ")");
      }
    }
 else     if (router.getId() != nextRouter.getId()) {
      throw new InvalidParameterValueException("guest vm " + userVm.getHostName() + " (id:"+ userVm.getId()+ ") belongs to router "+ nextRouter.getHostName()+ ", previous vm in list belongs to router "+ router.getHostName());
    }
    String ipAddress=loadBalancer.getIpAddress();
    String privateIpAddress=userVm.getGuestIpAddress();
    List<FirewallRuleVO> existingRulesOnPubIp=_rulesDao.listIPForwarding(ipAddress);
    if (existingRulesOnPubIp != null) {
      for (      FirewallRuleVO fwRule : existingRulesOnPubIp) {
        if (!((fwRule.isForwarding() == false) && (fwRule.getGroupId() != null) && (fwRule.getGroupId() == loadBalancer.getId()))) {
          if (fwRule.getPublicPort().equals(loadBalancer.getPublicPort())) {
            throw new NetworkRuleConflictException("An existing port forwarding service rule for " + ipAddress + ":"+ loadBalancer.getPublicPort()+ " exists, found while trying to apply load balancer "+ loadBalancer.getName()+ " (id:"+ loadBalancer.getId()+ ") to instance "+ userVm.getHostName()+ ".");
          }
        }
 else         if (fwRule.getPrivateIpAddress().equals(privateIpAddress) && fwRule.getPrivatePort().equals(loadBalancer.getPrivatePort()) && fwRule.isEnabled()) {
          continue;
        }
      }
    }
    FirewallRuleVO newFwRule=new FirewallRuleVO();
    newFwRule.setAlgorithm(loadBalancer.getAlgorithm());
    newFwRule.setEnabled(true);
    newFwRule.setForwarding(false);
    newFwRule.setPrivatePort(loadBalancer.getPrivatePort());
    newFwRule.setPublicPort(loadBalancer.getPublicPort());
    newFwRule.setPublicIpAddress(loadBalancer.getIpAddress());
    newFwRule.setPrivateIpAddress(userVm.getGuestIpAddress());
    newFwRule.setGroupId(loadBalancer.getId());
    firewallRulesToApply.add(newFwRule);
  }
  if (firewallRulesToApply.isEmpty()) {
    return true;
  }
  if (router == null) {
    throw new InvalidParameterValueException("Failed to assign to load balancer " + loadBalancerId + ", the domain router was not found at "+ loadBalancer.getIpAddress());
  }
 else {
    cmd.synchronizeCommand("Router",router.getId());
  }
  IPAddressVO ipAddr=_ipAddressDao.findById(loadBalancer.getIpAddress());
  List<IPAddressVO> ipAddrs=listPublicIpAddressesInVirtualNetwork(accountId,ipAddr.getDataCenterId(),null);
  for (  IPAddressVO ipv : ipAddrs) {
    List<FirewallRuleVO> rules=_rulesDao.listIpForwardingRulesForLoadBalancers(ipv.getAddress());
    firewallRulesToApply.addAll(rules);
  }
  txn.start();
  List<FirewallRuleVO> updatedRules=null;
  if (router.getState().equals(State.Starting)) {
    updatedRules=firewallRulesToApply;
  }
 else {
    updatedRules=updateFirewallRules(loadBalancer.getIpAddress(),firewallRulesToApply,router);
  }
  String description;
  String type=EventTypes.EVENT_NET_RULE_ADD;
  String ruleName="load balancer";
  String level=EventVO.LEVEL_INFO;
  LoadBalancerVO loadBalancerLock=null;
  try {
    loadBalancerLock=_loadBalancerDao.acquireInLockTable(loadBalancerId);
    if (loadBalancerLock == null) {
      s_logger.warn("assignToLoadBalancer: Failed to lock load balancer " + loadBalancerId + ", proceeding with updating loadBalancerVMMappings...");
    }
    if ((updatedRules != null) && (updatedRules.size() == firewallRulesToApply.size())) {
      for (      Long addedInstanceId : finalInstanceIds) {
        LoadBalancerVMMapVO mappedVM=new LoadBalancerVMMapVO(loadBalancerId,addedInstanceId);
        _loadBalancerVMMapDao.persist(mappedVM);
      }
      for (      FirewallRuleVO updatedRule : updatedRules) {
        _rulesDao.persist(updatedRule);
        description="created new " + ruleName + " rule ["+ updatedRule.getPublicIpAddress()+ ":"+ updatedRule.getPublicPort()+ "]->["+ updatedRule.getPrivateIpAddress()+ ":"+ updatedRule.getPrivatePort()+ "]"+ " "+ updatedRule.getProtocol();
        EventUtils.saveEvent(UserContext.current().getUserId(),loadBalancer.getAccountId(),level,type,description);
      }
      txn.commit();
      return true;
    }
 else {
      _loadBalancerVMMapDao.remove(loadBalancerId,instanceIds,null);
      txn.commit();
      s_logger.warn("Failed to apply load balancer " + loadBalancer.getName() + " (id:"+ loadBalancerId+ ") to guest virtual machines "+ StringUtils.join(instanceIds,","));
      throw new CloudRuntimeException("Failed to apply load balancer " + loadBalancer.getName() + " (id:"+ loadBalancerId+ ") to guest virtual machine "+ StringUtils.join(instanceIds,","));
    }
  }
  finally {
    if (loadBalancerLock != null) {
      _loadBalancerDao.releaseFromLockTable(loadBalancerId);
    }
  }
}

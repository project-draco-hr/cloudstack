{
  Long loadBalancerId=cmd.getLoadBalancerId();
  Long instanceIdParam=cmd.getVirtualMachineId();
  List<Long> instanceIds=cmd.getVirtualMachineIds();
  if ((instanceIdParam == null) && (instanceIds == null)) {
    throw new InvalidParameterValueException("Unable to assign to load balancer " + loadBalancerId + ", no instance id is specified.");
  }
  if ((instanceIds == null) && (instanceIdParam != null)) {
    instanceIds=new ArrayList<Long>();
    instanceIds.add(instanceIdParam);
  }
  LoadBalancerVO loadBalancer=_loadBalancerDao.findById(loadBalancerId);
  if (loadBalancer == null) {
    throw new InvalidParameterValueException("Failed to assign to load balancer " + loadBalancerId + ", the load balancer was not found.");
  }
  DomainRouterVO syncObject=_routerDao.findByPublicIpAddress(loadBalancer.getIpAddress());
  cmd.synchronizeCommand("Router",syncObject.getId());
  Account account=(Account)UserContext.current().getAccountObject();
  if (account != null) {
    if ((account.getType() == Account.ACCOUNT_TYPE_DOMAIN_ADMIN) || (account.getType() == Account.ACCOUNT_TYPE_READ_ONLY_ADMIN)) {
      if (!_domainDao.isChildDomain(account.getDomainId(),loadBalancer.getDomainId())) {
        throw new PermissionDeniedException("Failed to assign to load balancer " + loadBalancerId + ", permission denied.");
      }
    }
 else     if (account.getId() != loadBalancer.getAccountId()) {
      throw new PermissionDeniedException("Failed to assign to load balancer " + loadBalancerId + ", permission denied.");
    }
  }
  Transaction txn=Transaction.currentTxn();
  try {
    List<FirewallRuleVO> firewallRulesToApply=new ArrayList<FirewallRuleVO>();
    long accountId=0;
    DomainRouterVO router=null;
    List<LoadBalancerVMMapVO> mappedInstances=_loadBalancerVMMapDao.listByLoadBalancerId(loadBalancerId,false);
    Set<Long> mappedInstanceIds=new HashSet<Long>();
    if (mappedInstances != null) {
      for (      LoadBalancerVMMapVO mappedInstance : mappedInstances) {
        mappedInstanceIds.add(Long.valueOf(mappedInstance.getInstanceId()));
      }
    }
    for (    Long instanceId : instanceIds) {
      if (mappedInstanceIds.contains(instanceId)) {
        continue;
      }
      UserVmVO userVm=_vmDao.findById(instanceId);
      if (userVm == null) {
        s_logger.warn("Unable to find virtual machine with id " + instanceId);
        throw new InvalidParameterValueException("Unable to find virtual machine with id " + instanceId);
      }
 else {
        ServiceOfferingVO offering=_serviceOfferingDao.findById(userVm.getServiceOfferingId());
        if ((offering == null) || !GuestIpType.Virtualized.equals(offering.getGuestIpType())) {
          _loadBalancerVMMapDao.remove(loadBalancerId,instanceIds,Boolean.TRUE);
          if (s_logger.isDebugEnabled()) {
            s_logger.debug("Unable to add virtual machine " + userVm.toString() + " to load balancer "+ loadBalancerId+ ", bad network type ("+ ((offering == null) ? "null" : offering.getGuestIpType())+ ")");
          }
          throw new InvalidParameterValueException("Unable to add virtual machine " + userVm.toString() + " to load balancer "+ loadBalancerId+ ", bad network type ("+ ((offering == null) ? "null" : offering.getGuestIpType())+ ")");
        }
      }
      if (accountId == 0) {
        accountId=userVm.getAccountId();
      }
 else       if (accountId != userVm.getAccountId()) {
        s_logger.warn("guest vm " + userVm.getName() + " (id:"+ userVm.getId()+ ") belongs to account "+ userVm.getAccountId()+ ", previous vm in list belongs to account "+ accountId);
        throw new InvalidParameterValueException("guest vm " + userVm.getName() + " (id:"+ userVm.getId()+ ") belongs to account "+ userVm.getAccountId()+ ", previous vm in list belongs to account "+ accountId);
      }
      DomainRouterVO nextRouter=null;
      if (userVm.getDomainRouterId() != null)       nextRouter=_routerDao.findById(userVm.getDomainRouterId());
      if (nextRouter == null) {
        s_logger.warn("Unable to find router (" + userVm.getDomainRouterId() + ") for virtual machine with id "+ instanceId);
        throw new InvalidParameterValueException("Unable to find router (" + userVm.getDomainRouterId() + ") for virtual machine with id "+ instanceId);
      }
      if (router == null) {
        router=nextRouter;
        if (router.getAccountId() != loadBalancer.getAccountId()) {
          throw new InvalidParameterValueException("guest vm " + userVm.getName() + " (id:"+ userVm.getId()+ ") does not belong to the owner of load balancer "+ loadBalancer.getName()+ " (owner is account id "+ loadBalancer.getAccountId()+ ")");
        }
      }
 else       if (router.getId() != nextRouter.getId()) {
        throw new InvalidParameterValueException("guest vm " + userVm.getName() + " (id:"+ userVm.getId()+ ") belongs to router "+ nextRouter.getName()+ ", previous vm in list belongs to router "+ router.getName());
      }
      String ipAddress=loadBalancer.getIpAddress();
      String privateIpAddress=userVm.getGuestIpAddress();
      List<FirewallRuleVO> existingRulesOnPubIp=_rulesDao.listIPForwarding(ipAddress);
      if (existingRulesOnPubIp != null) {
        for (        FirewallRuleVO fwRule : existingRulesOnPubIp) {
          if (!((fwRule.isForwarding() == false) && (fwRule.getGroupId() != null) && (fwRule.getGroupId() == loadBalancer.getId().longValue()))) {
            if (fwRule.getPublicPort().equals(loadBalancer.getPublicPort())) {
              throw new NetworkRuleConflictException("An existing port forwarding service rule for " + ipAddress + ":"+ loadBalancer.getPublicPort()+ " exists, found while trying to apply load balancer "+ loadBalancer.getName()+ " (id:"+ loadBalancer.getId()+ ") to instance "+ userVm.getName()+ ".");
            }
          }
 else           if (fwRule.getPrivateIpAddress().equals(privateIpAddress) && fwRule.getPrivatePort().equals(loadBalancer.getPrivatePort()) && fwRule.isEnabled()) {
            continue;
          }
        }
      }
      FirewallRuleVO newFwRule=new FirewallRuleVO();
      newFwRule.setAlgorithm(loadBalancer.getAlgorithm());
      newFwRule.setEnabled(true);
      newFwRule.setForwarding(false);
      newFwRule.setPrivatePort(loadBalancer.getPrivatePort());
      newFwRule.setPublicPort(loadBalancer.getPublicPort());
      newFwRule.setPublicIpAddress(loadBalancer.getIpAddress());
      newFwRule.setPrivateIpAddress(userVm.getGuestIpAddress());
      newFwRule.setGroupId(loadBalancer.getId());
      firewallRulesToApply.add(newFwRule);
    }
    if (firewallRulesToApply.isEmpty()) {
      return;
    }
    IPAddressVO ipAddr=_ipAddressDao.findById(loadBalancer.getIpAddress());
    List<IPAddressVO> ipAddrs=listPublicIpAddressesInVirtualNetwork(accountId,ipAddr.getDataCenterId(),null);
    for (    IPAddressVO ipv : ipAddrs) {
      List<FirewallRuleVO> rules=_rulesDao.listIPForwarding(ipv.getAddress(),false);
      firewallRulesToApply.addAll(rules);
    }
    txn.start();
    List<FirewallRuleVO> updatedRules=null;
    if (router.getState().equals(State.Starting)) {
      updatedRules=firewallRulesToApply;
    }
 else {
      updatedRules=updateFirewallRules(loadBalancer.getIpAddress(),firewallRulesToApply,router);
    }
    String description;
    String type=EventTypes.EVENT_NET_RULE_ADD;
    String ruleName="load balancer";
    String level=EventVO.LEVEL_INFO;
    LoadBalancerVO loadBalancerLock=null;
    try {
      loadBalancerLock=_loadBalancerDao.acquire(loadBalancerId);
      if (loadBalancerLock == null) {
        s_logger.warn("assignToLoadBalancer: Failed to lock load balancer " + loadBalancerId + ", proceeding with updating loadBalancerVMMappings...");
      }
      if ((updatedRules != null) && (updatedRules.size() == firewallRulesToApply.size())) {
        List<LoadBalancerVMMapVO> pendingMappedVMs=_loadBalancerVMMapDao.listByLoadBalancerId(loadBalancerId,true);
        for (        LoadBalancerVMMapVO pendingMappedVM : pendingMappedVMs) {
          if (instanceIds.contains(pendingMappedVM.getInstanceId())) {
            LoadBalancerVMMapVO pendingMappedVMForUpdate=_loadBalancerVMMapDao.createForUpdate();
            pendingMappedVMForUpdate.setPending(false);
            _loadBalancerVMMapDao.update(pendingMappedVM.getId(),pendingMappedVMForUpdate);
          }
        }
        for (        FirewallRuleVO updatedRule : updatedRules) {
          if (updatedRule.getId() == null) {
            _rulesDao.persist(updatedRule);
            description="created new " + ruleName + " rule ["+ updatedRule.getPublicIpAddress()+ ":"+ updatedRule.getPublicPort()+ "]->["+ updatedRule.getPrivateIpAddress()+ ":"+ updatedRule.getPrivatePort()+ "]"+ " "+ updatedRule.getProtocol();
            EventUtils.saveEvent(UserContext.current().getUserId(),loadBalancer.getAccountId(),level,type,description);
          }
        }
      }
 else {
        _loadBalancerVMMapDao.remove(loadBalancerId,instanceIds,null);
        txn.commit();
        s_logger.warn("Failed to apply load balancer " + loadBalancer.getName() + " (id:"+ loadBalancerId+ ") to guest virtual machines "+ StringUtils.join(instanceIds,","));
        throw new InternalErrorException("Failed to apply load balancer " + loadBalancer.getName() + " (id:"+ loadBalancerId+ ") to guest virtual machine "+ StringUtils.join(instanceIds,","));
      }
    }
  finally {
      if (loadBalancerLock != null) {
        _loadBalancerDao.release(loadBalancerId);
      }
    }
    txn.commit();
  }
 catch (  Throwable e) {
    txn.rollback();
    if (e instanceof NetworkRuleConflictException) {
      throw (NetworkRuleConflictException)e;
    }
 else     if (e instanceof InvalidParameterValueException) {
      throw (InvalidParameterValueException)e;
    }
 else     if (e instanceof PermissionDeniedException) {
      throw (PermissionDeniedException)e;
    }
 else     if (e instanceof InternalErrorException) {
      s_logger.warn("ManagementServer error",e);
      throw (InternalErrorException)e;
    }
    s_logger.warn("ManagementServer error",e);
  }
}

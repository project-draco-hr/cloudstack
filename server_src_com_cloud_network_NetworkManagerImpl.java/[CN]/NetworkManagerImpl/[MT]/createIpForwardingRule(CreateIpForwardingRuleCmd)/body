{
  Transaction txn=Transaction.currentTxn();
  txn.start();
  UserVmVO userVM=null;
  FirewallRuleVO newFwRule=null;
  boolean locked=false;
  try {
    IPAddressVO ipAddress=_ipAddressDao.findById(cmd.getIpAddress());
    if (ipAddress == null) {
      throw new InvalidParameterValueException("Unable to create ip forwarding rule on address " + ipAddress + ", invalid IP address specified.");
    }
    userVM=_vmDao.findById(cmd.getVirtualMachineId());
    if (userVM == null) {
      throw new InvalidParameterValueException("Unable to create ip forwarding rule on address " + ipAddress + ", invalid virtual machine id specified ("+ cmd.getVirtualMachineId()+ ").");
    }
    userVM=_vmDao.acquireInLockTable(userVM.getId());
    if (userVM == null) {
      s_logger.warn("Unable to acquire lock on user vm for creating 1-1 NAT rule");
      return newFwRule;
    }
 else {
      locked=true;
    }
    if ((ipAddress.getAccountId() == null) || (ipAddress.getAccountId().longValue() != userVM.getAccountId())) {
      throw new InvalidParameterValueException("Unable to create ip forwarding rule, IP address " + ipAddress + " owner is not the same as owner of virtual machine "+ userVM.toString());
    }
    if (ipAddress.getDataCenterId() != userVM.getDataCenterId()) {
      throw new InvalidParameterValueException("Unable to create ip forwarding rule, IP address " + ipAddress + " is not in the same availability zone as virtual machine "+ userVM.toString());
    }
    Account account=UserContext.current().getAccount();
    if (account != null) {
      if ((account.getType() == Account.ACCOUNT_TYPE_ADMIN) || (account.getType() == Account.ACCOUNT_TYPE_DOMAIN_ADMIN)) {
        if (!_domainDao.isChildDomain(account.getDomainId(),userVM.getDomainId())) {
          throw new PermissionDeniedException("Unable to create ip forwarding rule, IP address " + ipAddress + " to virtual machine "+ cmd.getVirtualMachineId()+ ", permission denied.");
        }
      }
 else       if (account.getId() != userVM.getAccountId()) {
        throw new PermissionDeniedException("Unable to create ip forwarding rule, IP address " + ipAddress + " to virtual machine "+ cmd.getVirtualMachineId()+ ", permission denied.");
      }
    }
    List<FirewallRuleVO> existingNatRules=_rulesDao.findByPublicIpPrivateIpForNatRule(cmd.getIpAddress(),userVM.getGuestIpAddress());
    if (existingNatRules.size() > 0) {
      throw new NetworkRuleConflictException("The specified rule for public ip:" + cmd.getIpAddress() + " vm id:"+ cmd.getVirtualMachineId()+ " already exists");
    }
    newFwRule=new FirewallRuleVO();
    newFwRule.setEnabled(true);
    newFwRule.setForwarding(true);
    newFwRule.setPrivatePort(null);
    newFwRule.setProtocol("NAT");
    newFwRule.setPublicPort(null);
    newFwRule.setPublicIpAddress(ipAddress.getAddress());
    newFwRule.setPrivateIpAddress(userVM.getGuestIpAddress());
    newFwRule.setGroupId(null);
    _rulesDao.persist(newFwRule);
    String description;
    String ruleName="ip forwarding";
    String level=EventVO.LEVEL_INFO;
    description="created new " + ruleName + " rule ["+ newFwRule.getPublicIpAddress()+ ":"+ newFwRule.getPublicPort()+ "]->["+ newFwRule.getPrivateIpAddress()+ ":"+ newFwRule.getPrivatePort()+ "]"+ " "+ newFwRule.getProtocol();
    EventUtils.saveEvent(UserContext.current().getUserId(),userVM.getAccountId(),level,EventTypes.EVENT_NET_RULE_ADD,description);
    txn.commit();
  }
 catch (  Exception e) {
    s_logger.warn("Unable to create new firewall rule for 1:1 NAT");
    txn.rollback();
  }
 finally {
    if (locked)     _vmDao.releaseFromLockTable(userVM.getId());
  }
  return newFwRule;
}

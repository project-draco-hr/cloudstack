{
  if (serviceOffering.getGuestIpType() == GuestIpType.DirectDual || serviceOffering.getGuestIpType() == GuestIpType.DirectSingle) {
    return null;
  }
  final long dcId=dc.getId();
  String sourceNat=null;
  final long accountId=account.getId();
  Transaction txn=Transaction.currentTxn();
  try {
    final EventVO event=new EventVO();
    event.setUserId(1L);
    event.setAccountId(account.getId());
    event.setType(EventTypes.EVENT_NET_IP_ASSIGN);
    txn.start();
    account=_accountDao.acquire(accountId);
    if (account == null) {
      s_logger.warn("Unable to lock account " + accountId);
      return null;
    }
    if (s_logger.isDebugEnabled())     s_logger.debug("lock account " + accountId + " is acquired");
    boolean isAccountIP=false;
    List<IPAddressVO> addrs=listPublicIpAddressesInVirtualNetwork(account.getId(),dcId,true);
    if (addrs.size() == 0) {
      if (_accountMgr.resourceLimitExceeded(account,ResourceType.public_ip)) {
        ResourceAllocationException rae=new ResourceAllocationException("Maximum number of public IP addresses for account: " + account.getAccountName() + " has been exceeded.");
        rae.setResourceType("ip");
        throw rae;
      }
      addrs=listPublicIpAddressesInVirtualNetwork(account.getId(),dcId,null);
      if (addrs.size() == 0) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("assigning a new ip address");
        }
        Pair<String,VlanVO> ipAndVlan=_vlanDao.assignIpAddress(dc.getId(),accountId,account.getDomainId(),VlanType.VirtualNetwork,true);
        if (ipAndVlan != null) {
          sourceNat=ipAndVlan.first();
          _accountMgr.incrementResourceCount(accountId,ResourceType.public_ip);
          event.setParameters("address=" + sourceNat + "\nsourceNat=true\ndcId="+ dcId);
          event.setDescription("Acquired a public ip: " + sourceNat);
          _eventDao.persist(event);
        }
      }
 else {
        isAccountIP=true;
        sourceNat=addrs.get(0).getAddress();
        _ipAddressDao.setIpAsSourceNat(sourceNat);
        s_logger.debug("assigning a new ip address " + sourceNat);
        _accountMgr.incrementResourceCount(accountId,ResourceType.public_ip);
        event.setParameters("address=" + sourceNat + "\nsourceNat=true\ndcId="+ dcId);
        event.setDescription("Acquired a public ip: " + sourceNat);
        _eventDao.persist(event);
      }
    }
 else {
      sourceNat=addrs.get(0).getAddress();
    }
    if (sourceNat == null) {
      txn.rollback();
      event.setLevel(EventVO.LEVEL_ERROR);
      event.setParameters("dcId=" + dcId);
      event.setDescription("Failed to acquire a public ip.");
      _eventDao.persist(event);
      s_logger.error("Unable to get source nat ip address for account " + account.getId());
      return null;
    }
    UserStatisticsVO stats=_userStatsDao.findBy(account.getId(),dcId);
    if (stats == null) {
      stats=new UserStatisticsVO(account.getId(),dcId);
      _userStatsDao.persist(stats);
    }
    txn.commit();
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Source Nat is " + sourceNat);
    }
    DomainRouterVO router=null;
    try {
      router=createRouter(account.getId(),sourceNat,dcId,domain,serviceOffering,startEventId);
    }
 catch (    final Exception e) {
      s_logger.error("Unable to create router for " + account.getAccountName(),e);
    }
    if (router != null) {
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Router is " + router.getName());
      }
      return sourceNat;
    }
    s_logger.warn("releasing the source nat because router was not created: " + sourceNat);
    txn.start();
    if (isAccountIP) {
      _ipAddressDao.unassignIpAsSourceNat(sourceNat);
    }
 else {
      _ipAddressDao.unassignIpAddress(sourceNat);
    }
    _accountMgr.decrementResourceCount(accountId,ResourceType.public_ip);
    EventVO event2=new EventVO();
    event2.setUserId(1L);
    event2.setAccountId(account.getId());
    event2.setType(EventTypes.EVENT_NET_IP_RELEASE);
    event2.setParameters("address=" + sourceNat + "\nsourceNat=true");
    event2.setDescription("released source nat ip " + sourceNat + " since router could not be started");
    _eventDao.persist(event2);
    txn.commit();
    return null;
  }
  finally {
    if (account != null) {
      if (s_logger.isDebugEnabled())       s_logger.debug("Releasing lock account " + accountId);
      _accountDao.release(accountId);
    }
  }
}

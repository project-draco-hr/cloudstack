{
  IPAddressVO ip=null;
  try {
    ip=_ipAddressDao.acquire(ipAddress);
    if (ip == null) {
      s_logger.warn("Unable to find allocated ip: " + ipAddress);
      return false;
    }
    if (s_logger.isDebugEnabled())     s_logger.debug("lock on ip " + ipAddress + " is acquired");
    if (ip.getAllocated() == null) {
      s_logger.warn("ip: " + ipAddress + " is already released");
      return false;
    }
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Releasing ip " + ipAddress + "; sourceNat = "+ ip.isSourceNat());
    }
    final List<String> ipAddrs=new ArrayList<String>();
    ipAddrs.add(ip.getAddress());
    final List<FirewallRuleVO> firewallRules=_rulesDao.listIPForwardingForUpdate(ipAddress);
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Found firewall rules: " + firewallRules.size());
    }
    for (    final FirewallRuleVO fw : firewallRules) {
      fw.setEnabled(false);
    }
    DomainRouterVO router=null;
    if (ip.isSourceNat()) {
      router=_routerDao.findByPublicIpAddress(ipAddress);
      if (router != null) {
        if (router.getPublicIpAddress() != null) {
          return false;
        }
      }
    }
 else {
      router=_routerDao.findBy(ip.getAccountId(),ip.getDataCenterId());
    }
    updateFirewallRules(ipAddress,firewallRules,router);
    for (    final FirewallRuleVO rule : firewallRules) {
      _rulesDao.remove(rule.getId());
      String ruleName=(rule.isForwarding() ? "ip forwarding" : "load balancer");
      String description="deleted " + ruleName + " rule ["+ rule.getPublicIpAddress()+ ":"+ rule.getPublicPort()+ "]->["+ rule.getPrivateIpAddress()+ ":"+ rule.getPrivatePort()+ "]"+ " "+ rule.getProtocol();
      EventVO event=new EventVO();
      event.setUserId(userId);
      event.setAccountId(ip.getAccountId());
      event.setType(EventTypes.EVENT_NET_RULE_DELETE);
      event.setDescription(description);
      event.setLevel(EventVO.LEVEL_INFO);
      _eventDao.persist(event);
    }
    List<SecurityGroupVMMapVO> securityGroupMappings=_securityGroupVMMapDao.listByIp(ipAddress);
    for (    SecurityGroupVMMapVO securityGroupMapping : securityGroupMappings) {
      _securityGroupVMMapDao.remove(securityGroupMapping.getId());
      EventVO event=new EventVO();
      event.setUserId(userId);
      event.setAccountId(ip.getAccountId());
      event.setType(EventTypes.EVENT_PORT_FORWARDING_SERVICE_REMOVE);
      String params="sgId=" + securityGroupMapping.getId() + "\nvmId="+ securityGroupMapping.getInstanceId();
      event.setParameters(params);
      event.setDescription("Successfully removed security group " + Long.valueOf(securityGroupMapping.getSecurityGroupId()).toString() + " from virtual machine "+ Long.valueOf(securityGroupMapping.getInstanceId()).toString());
      event.setLevel(EventVO.LEVEL_INFO);
      _eventDao.persist(event);
    }
    List<LoadBalancerVO> loadBalancers=_loadBalancerDao.listByIpAddress(ipAddress);
    for (    LoadBalancerVO loadBalancer : loadBalancers) {
      _loadBalancerDao.remove(loadBalancer.getId());
      EventVO event=new EventVO();
      event.setUserId(userId);
      event.setAccountId(ip.getAccountId());
      event.setType(EventTypes.EVENT_LOAD_BALANCER_DELETE);
      String params="id=" + loadBalancer.getId();
      event.setParameters(params);
      event.setDescription("Successfully deleted load balancer " + loadBalancer.getId().toString());
      event.setLevel(EventVO.LEVEL_INFO);
      _eventDao.persist(event);
    }
    if ((router != null) && (router.getState() == State.Running)) {
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Disassociate ip " + router.getName());
      }
      if (associateIP(router,ipAddrs,false,0)) {
        _ipAddressDao.unassignIpAddress(ipAddress);
      }
 else {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Unable to dissociate IP : " + ipAddress + " due to failing to dissociate with router: "+ router.getName());
        }
        final EventVO event=new EventVO();
        event.setUserId(userId);
        event.setAccountId(ip.getAccountId());
        event.setType(EventTypes.EVENT_NET_IP_RELEASE);
        event.setLevel(EventVO.LEVEL_ERROR);
        event.setParameters("address=" + ipAddress + "\nsourceNat="+ ip.isSourceNat());
        event.setDescription("failed to released a public ip: " + ipAddress + " due to failure to disassociate with router "+ router.getName());
        _eventDao.persist(event);
        return false;
      }
    }
 else {
      _ipAddressDao.unassignIpAddress(ipAddress);
    }
    s_logger.debug("released a public ip: " + ipAddress);
    final EventVO event=new EventVO();
    event.setUserId(userId);
    event.setAccountId(ip.getAccountId());
    event.setType(EventTypes.EVENT_NET_IP_RELEASE);
    event.setParameters("address=" + ipAddress + "\nsourceNat="+ ip.isSourceNat());
    event.setDescription("released a public ip: " + ipAddress);
    _eventDao.persist(event);
    return true;
  }
 catch (  final Throwable e) {
    s_logger.warn("ManagementServer error",e);
    return false;
  }
 finally {
    if (ip != null) {
      if (s_logger.isDebugEnabled())       s_logger.debug("Releasing lock on ip " + ipAddress);
      _ipAddressDao.release(ipAddress);
    }
  }
}

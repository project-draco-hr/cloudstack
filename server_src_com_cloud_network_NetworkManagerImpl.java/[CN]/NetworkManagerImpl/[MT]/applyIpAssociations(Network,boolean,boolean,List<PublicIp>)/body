{
  boolean success=true;
  Map<PublicIp,Set<Service>> ipToServices=getIpToServices(network,publicIps,rulesRevoked);
  Map<Provider,ArrayList<PublicIp>> providerToIpList=getProviderToIpList(network,ipToServices);
  for (  Provider provider : providerToIpList.keySet()) {
    try {
      ArrayList<PublicIp> ips=providerToIpList.get(provider);
      if (ips == null || ips.isEmpty()) {
        continue;
      }
      IpDeployer deployer=null;
      NetworkElement element=getElementImplementingProvider(provider.getName());
      if (element instanceof SourceNatServiceProvider) {
        deployer=((SourceNatServiceProvider)element).getIpDeployer(network);
      }
 else       if (element instanceof StaticNatServiceProvider) {
        deployer=((StaticNatServiceProvider)element).getIpDeployer(network);
      }
 else       if (element instanceof LoadBalancingServiceProvider) {
        deployer=((LoadBalancingServiceProvider)element).getIpDeployer(network);
      }
 else       if (element instanceof PortForwardingServiceProvider) {
        deployer=((PortForwardingServiceProvider)element).getIpDeployer(network);
      }
 else       if (element instanceof RemoteAccessVPNServiceProvider) {
        deployer=((RemoteAccessVPNServiceProvider)element).getIpDeployer(network);
      }
 else {
        throw new CloudRuntimeException("Fail to get ip deployer for element: " + element);
      }
      Set<Service> services=new HashSet<Service>();
      for (      PublicIp ip : ips) {
        if (!ipToServices.containsKey(ip)) {
          continue;
        }
        services.addAll(ipToServices.get(ip));
      }
      deployer.applyIps(network,ips,services);
    }
 catch (    ResourceUnavailableException e) {
      success=false;
      if (!continueOnError) {
        throw e;
      }
 else {
        s_logger.debug("Resource is not available: " + provider.getName(),e);
      }
    }
  }
  return success;
}

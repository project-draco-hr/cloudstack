{
  boolean success=true;
  List<PublicIp> publicIps=new ArrayList<PublicIp>();
  for (  FirewallRule rule : rules) {
    IPAddressVO lbIp=_ipAddressDao.findById(rule.getSourceIpAddressId());
    PublicIp publicIp=new PublicIp(lbIp,_vlanDao.findById(lbIp.getVlanId()),NetUtils.createSequenceBasedMacAddress(lbIp.getMacAddress()));
    publicIps.add(publicIp);
  }
  for (  NetworkElement ne : _networkElements) {
    try {
      boolean handled;
switch (purpose) {
case LoadBalancing:
        if (!(ne instanceof LoadBalancingServiceProvider)) {
          continue;
        }
      LoadBalancingServiceProvider lbProvider=(LoadBalancingServiceProvider)ne;
    s_logger.trace("Asking " + ne + " to apply ip associations for "+ purpose.toString()+ " purpose");
  handled=lbProvider.applyLoadBalancerIp(network,publicIps);
break;
case PortForwarding:
if (!(ne instanceof PortForwardingServiceProvider)) {
continue;
}
PortForwardingServiceProvider pfProvider=(PortForwardingServiceProvider)ne;
s_logger.trace("Asking " + ne + " to apply ip associations for "+ purpose.toString()+ " purpose");
handled=pfProvider.applyIps(network,publicIps);
break;
case StaticNat:
case Firewall:
if (!(ne instanceof FirewallServiceProvider)) {
continue;
}
s_logger.trace("Asking " + ne + " to apply ip associations for "+ purpose.toString()+ " purpose");
FirewallServiceProvider fwProvider=(FirewallServiceProvider)ne;
handled=fwProvider.applyIps(network,publicIps);
break;
default :
s_logger.debug("Unable to handle IP association for purpose: " + purpose.toString());
handled=false;
}
s_logger.debug("Network Rules for network " + network.getId() + " were "+ (handled ? "" : " not")+ " handled by "+ ne.getName());
}
 catch (ResourceUnavailableException e) {
success=false;
if (!continueOnError) {
throw e;
}
 else {
s_logger.debug("Resource is not available: " + ne.getName(),e);
}
}
}
return success;
}

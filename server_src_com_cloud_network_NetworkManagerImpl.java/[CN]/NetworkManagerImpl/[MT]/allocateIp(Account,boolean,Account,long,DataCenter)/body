{
  VlanType vlanType=VlanType.VirtualNetwork;
  boolean assign=false;
  boolean allocateFromDedicatedRange=false;
  List<Long> dedicatedVlanDbIds=new ArrayList<Long>();
  List<Long> nonDedicatedVlanDbIds=new ArrayList<Long>();
  if (Grouping.AllocationState.Disabled == zone.getAllocationState() && !_accountMgr.isRootAdmin(caller.getType())) {
    PermissionDeniedException ex=new PermissionDeniedException("Cannot perform this operation, " + "Zone is currently disabled");
    ex.addProxyObject("data_center",zone.getId(),"zoneId");
    throw ex;
  }
  PublicIp ip=null;
  Transaction txn=Transaction.currentTxn();
  Account accountToLock=null;
  try {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Associate IP address called by the user " + callerUserId + " account "+ ipOwner.getId());
    }
    accountToLock=_accountDao.acquireInLockTable(ipOwner.getId());
    if (accountToLock == null) {
      s_logger.warn("Unable to lock account: " + ipOwner.getId());
      throw new ConcurrentOperationException("Unable to acquire account lock");
    }
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Associate IP address lock acquired");
    }
    _resourceLimitMgr.checkResourceLimit(accountToLock,ResourceType.public_ip);
    txn.start();
    List<AccountVlanMapVO> maps=_accountVlanMapDao.listAccountVlanMapsByAccount(ipOwner.getId());
    for (    AccountVlanMapVO map : maps) {
      dedicatedVlanDbIds.add(map.getVlanDbId());
    }
    if (dedicatedVlanDbIds != null && !dedicatedVlanDbIds.isEmpty()) {
      allocateFromDedicatedRange=true;
    }
    try {
      if (allocateFromDedicatedRange) {
        ip=fetchNewPublicIp(zone.getId(),null,dedicatedVlanDbIds,ipOwner,vlanType,null,false,assign,null,isSystem,null);
      }
    }
 catch (    InsufficientAddressCapacityException e) {
      s_logger.warn("All IPs dedicated to account " + ipOwner.getId() + " has been acquired."+ " Now acquiring from the system pool");
      txn.close();
      allocateFromDedicatedRange=false;
    }
    if (!allocateFromDedicatedRange) {
      List<VlanVO> nonDedicatedVlans=_vlanDao.listZoneWideNonDedicatedVlans(zone.getId());
      for (      VlanVO nonDedicatedVlan : nonDedicatedVlans) {
        nonDedicatedVlanDbIds.add(nonDedicatedVlan.getId());
      }
      ip=fetchNewPublicIp(zone.getId(),null,nonDedicatedVlanDbIds,ipOwner,vlanType,null,false,assign,null,isSystem,null);
    }
    if (ip == null) {
      InsufficientAddressCapacityException ex=new InsufficientAddressCapacityException("Unable to find available public IP addresses",DataCenter.class,zone.getId());
      ex.addProxyObject(ApiDBUtils.findZoneById(zone.getId()).getUuid());
      throw ex;
    }
    UserContext.current().setEventDetails("Ip Id: " + ip.getId());
    Ip ipAddress=ip.getAddress();
    s_logger.debug("Got " + ipAddress + " to assign for account "+ ipOwner.getId()+ " in zone "+ zone.getId());
    txn.commit();
  }
  finally {
    if (accountToLock != null) {
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Releasing lock account " + ipOwner);
      }
      _accountDao.releaseFromLockTable(ipOwner.getId());
      s_logger.debug("Associate IP address lock released");
    }
  }
  return ip;
}

{
  VolumeVO newVol;
  boolean recreate=_recreateSystemVmEnabled;
  DataStore destPool=null;
  if (recreate && (dest.getStorageForDisks() == null || dest.getStorageForDisks().get(vol) == null)) {
    destPool=dataStoreMgr.getDataStore(vol.getPoolId(),DataStoreRole.Primary);
    s_logger.debug("existing pool: " + destPool.getId());
  }
 else {
    StoragePool pool=dest.getStorageForDisks().get(vol);
    destPool=dataStoreMgr.getDataStore(pool.getId(),DataStoreRole.Primary);
  }
  if (vol.getState() == Volume.State.Allocated || vol.getState() == Volume.State.Creating) {
    newVol=vol;
  }
 else {
    newVol=switchVolume(vol,vm);
    if (dest.getStorageForDisks() != null && dest.getStorageForDisks().containsKey(vol)) {
      StoragePool poolWithOldVol=dest.getStorageForDisks().get(vol);
      dest.getStorageForDisks().put(newVol,poolWithOldVol);
      dest.getStorageForDisks().remove(vol);
    }
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Created new volume " + newVol + " for old volume "+ vol);
    }
  }
  VolumeInfo volume=volFactory.getVolume(newVol.getId(),destPool);
  Long templateId=newVol.getTemplateId();
  for (int i=0; i < 2; i++) {
    AsyncCallFuture<VolumeApiResult> future=null;
    if (templateId == null) {
      future=volService.createVolumeAsync(volume,destPool);
    }
 else {
      TemplateInfo templ=tmplFactory.getTemplate(templateId,DataStoreRole.Image);
      future=volService.createVolumeFromTemplateAsync(volume,destPool.getId(),templ);
    }
    VolumeApiResult result=null;
    try {
      result=future.get();
      if (result.isFailed()) {
        if (result.getResult().contains("request template reload") && (i == 0)) {
          s_logger.debug("Retry template re-deploy for vmware");
          continue;
        }
 else {
          s_logger.debug("Unable to create " + newVol + ":"+ result.getResult());
          throw new StorageUnavailableException("Unable to create " + newVol + ":"+ result.getResult(),destPool.getId());
        }
      }
      newVol=_volsDao.findById(newVol.getId());
      break;
    }
 catch (    InterruptedException e) {
      s_logger.error("Unable to create " + newVol,e);
      throw new StorageUnavailableException("Unable to create " + newVol + ":"+ e.toString(),destPool.getId());
    }
catch (    ExecutionException e) {
      s_logger.error("Unable to create " + newVol,e);
      throw new StorageUnavailableException("Unable to create " + newVol + ":"+ e.toString(),destPool.getId());
    }
  }
  return new Pair<VolumeVO,DataStore>(newVol,destPool);
}

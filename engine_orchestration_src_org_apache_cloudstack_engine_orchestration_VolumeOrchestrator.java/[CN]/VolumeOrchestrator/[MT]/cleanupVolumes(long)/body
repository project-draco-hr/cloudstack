{
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Cleaning storage for vm: " + vmId);
  }
  final List<VolumeVO> volumesForVm=_volsDao.findByInstance(vmId);
  final List<VolumeVO> toBeExpunged=new ArrayList<VolumeVO>();
  Transaction.execute(new TransactionCallbackNoReturn(){
    @Override public void doInTransactionWithoutResult(    TransactionStatus status){
      for (      VolumeVO vol : volumesForVm) {
        if (vol.getVolumeType().equals(Type.ROOT)) {
          boolean volumeAlreadyDestroyed=(vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged || vol.getState() == Volume.State.Expunging);
          if (!volumeAlreadyDestroyed) {
            volService.destroyVolume(vol.getId());
          }
 else {
            s_logger.debug("Skipping destroy for the volume " + vol + " as its in state "+ vol.getState().toString());
          }
          toBeExpunged.add(vol);
        }
 else {
          if (s_logger.isDebugEnabled()) {
            s_logger.debug("Detaching " + vol);
          }
          _volsDao.detachVolume(vol.getId());
        }
      }
    }
  }
);
  AsyncCallFuture<VolumeApiResult> future=null;
  for (  VolumeVO expunge : toBeExpunged) {
    future=volService.expungeVolumeAsync(volFactory.getVolume(expunge.getId()));
    try {
      future.get();
    }
 catch (    InterruptedException e) {
      s_logger.debug("failed expunge volume" + expunge.getId(),e);
    }
catch (    ExecutionException e) {
      s_logger.debug("failed expunge volume" + expunge.getId(),e);
    }
  }
}

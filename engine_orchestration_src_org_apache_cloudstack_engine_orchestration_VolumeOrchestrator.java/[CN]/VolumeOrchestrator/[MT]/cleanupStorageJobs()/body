{
  List<AsyncJobVO> jobs=_jobMgr.findFailureAsyncJobs(VmWorkAttachVolume.class.getName(),VmWorkMigrateVolume.class.getName(),VmWorkTakeVolumeSnapshot.class.getName());
  for (  AsyncJobVO job : jobs) {
    try {
      if (job.getCmd().equalsIgnoreCase(VmWorkAttachVolume.class.getName())) {
        VmWorkAttachVolume work=VmWorkSerializer.deserialize(VmWorkAttachVolume.class,job.getCmdInfo());
        cleanupVolumeDuringAttachFailure(work.getVolumeId());
      }
 else       if (job.getCmd().equalsIgnoreCase(VmWorkMigrateVolume.class.getName())) {
        VmWorkMigrateVolume work=VmWorkSerializer.deserialize(VmWorkMigrateVolume.class,job.getCmdInfo());
        cleanupVolumeDuringMigrationFailure(work.getVolumeId(),work.getDestPoolId());
      }
 else       if (job.getCmd().equalsIgnoreCase(VmWorkTakeVolumeSnapshot.class.getName())) {
        VmWorkTakeVolumeSnapshot work=VmWorkSerializer.deserialize(VmWorkTakeVolumeSnapshot.class,job.getCmdInfo());
        cleanupVolumeDuringSnapshotFailure(work.getVolumeId(),work.getSnapshotId());
      }
    }
 catch (    Exception e) {
      logger.debug("clean up job failure, will continue",e);
    }
  }
}

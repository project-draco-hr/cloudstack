{
  UserVmVO vm=_vmDao.findById(param.getVmId());
  State state=vm.getState();
  OperationResponse response;
  String resultDescription="Success";
  if (vm == null || state == State.Destroyed || state == State.Expunging || vm.getRemoved() != null) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Unable to find vm or vm is destroyed: " + param.getVmId());
    }
    resultDescription="VM does not exist or already in destroyed state";
    response=new OperationResponse(OperationResponse.STATUS_FAILED,resultDescription);
    executor.getAsyncJobMgr().completeAsyncJob(executor.getJob().getId(),AsyncJobResult.STATUS_FAILED,0,resultDescription);
    return response;
  }
  if (state == State.Stopping) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("VM is being stopped: " + param.getVmId());
    }
    resultDescription="VM is being stopped, please re-try later";
    response=new OperationResponse(OperationResponse.STATUS_FAILED,resultDescription);
    executor.getAsyncJobMgr().completeAsyncJob(executor.getJob().getId(),AsyncJobResult.STATUS_FAILED,0,resultDescription);
    return response;
  }
  if (state == State.Running) {
    if (vm.getHostId() == null) {
      resultDescription="VM host is null (invalid VM)";
      response=new OperationResponse(OperationResponse.STATUS_FAILED,resultDescription);
      executor.getAsyncJobMgr().completeAsyncJob(executor.getJob().getId(),AsyncJobResult.STATUS_FAILED,0,resultDescription);
      if (s_logger.isDebugEnabled())       s_logger.debug("Execute asynchronize destroy VM command: " + resultDescription);
      return response;
    }
    if (!_vmDao.updateIf(vm,Event.StopRequested,vm.getHostId())) {
      resultDescription="Failed to issue stop command, please re-try later";
      response=new OperationResponse(OperationResponse.STATUS_FAILED,resultDescription);
      executor.getAsyncJobMgr().completeAsyncJob(executor.getJob().getId(),AsyncJobResult.STATUS_FAILED,0,resultDescription);
      if (s_logger.isDebugEnabled())       s_logger.debug("Execute asynchronize destroy VM command:" + resultDescription);
      return response;
    }
    long childEventId=executor.getAsyncJobMgr().getExecutorContext().getManagementServer().saveStartedEvent(param.getUserId(),param.getAccountId(),EventTypes.EVENT_VM_STOP,"stopping vm " + vm.getName(),0);
    param.setChildEventId(childEventId);
    StopCommand cmd=new StopCommand(vm,vm.getInstanceName(),vm.getVnet());
    try {
      long seq=_agentMgr.send(vm.getHostId(),new Command[]{cmd},true,new VMOperationListener(executor,param,vm,0));
      resultDescription="Execute asynchronize destroy VM command: sending stop command to agent, seq - " + seq;
      if (s_logger.isDebugEnabled())       s_logger.debug(resultDescription);
      response=new OperationResponse(OperationResponse.STATUS_IN_PROGRESS,resultDescription);
      return response;
    }
 catch (    AgentUnavailableException e) {
      resultDescription="Agent is not available";
      response=new OperationResponse(OperationResponse.STATUS_FAILED,resultDescription);
      executor.getAsyncJobMgr().completeAsyncJob(executor.getJob().getId(),AsyncJobResult.STATUS_FAILED,0,resultDescription);
      return response;
    }
  }
  Transaction txn=Transaction.currentTxn();
  txn.start();
  _accountMgr.decrementResourceCount(vm.getAccountId(),ResourceType.user_vm);
  if (!_vmDao.updateIf(vm,VirtualMachine.Event.DestroyRequested,vm.getHostId())) {
    resultDescription="Unable to destroy the vm because it is not in the correct state";
    s_logger.debug(resultDescription + vm.toString());
    txn.rollback();
    response=new OperationResponse(OperationResponse.STATUS_FAILED,resultDescription);
    executor.getAsyncJobMgr().completeAsyncJob(executor.getJob().getId(),AsyncJobResult.STATUS_FAILED,0,resultDescription);
    return response;
  }
  cleanNetworkRules(param.getUserId(),vm.getId());
  List<VolumeVO> volumes=_volsDao.findByInstanceAndType(vm.getId(),VolumeType.ROOT);
  for (  VolumeVO volume : volumes) {
    _storageMgr.destroyVolume(volume);
  }
  volumes=_volsDao.findByInstanceAndType(vm.getId(),VolumeType.DATADISK);
  for (  VolumeVO volume : volumes) {
    _volsDao.detachVolume(volume.getId());
  }
  txn.commit();
  response=new OperationResponse(OperationResponse.STATUS_SUCCEEDED,resultDescription);
  executor.getAsyncJobMgr().completeAsyncJob(executor.getJob().getId(),AsyncJobResult.STATUS_SUCCEEDED,0,"success");
  return response;
}

{
  Account caller=CallContext.current().getCallingAccount();
  VMInstanceVO vmInstance=_vmInstanceDao.findById(vmId);
  if (vmInstance.getState().equals(State.Stopped)) {
    upgradeStoppedVirtualMachine(vmId,newServiceOfferingId);
    return true;
  }
  if (vmInstance.getHypervisorType() != HypervisorType.XenServer && vmInstance.getHypervisorType() != HypervisorType.VMware) {
    throw new InvalidParameterValueException("This operation not permitted for this hypervisor of the vm");
  }
  _accountMgr.checkAccess(caller,null,true,vmInstance);
  _itMgr.checkIfCanUpgrade(vmInstance,newServiceOfferingId);
  ServiceOffering newServiceOffering=_configMgr.getServiceOffering(newServiceOfferingId);
  ServiceOffering currentServiceOffering=_configMgr.getServiceOffering(vmInstance.getServiceOfferingId());
  int newCpu=newServiceOffering.getCpu();
  int newMemory=newServiceOffering.getRamSize();
  int newSpeed=newServiceOffering.getSpeed();
  int currentCpu=currentServiceOffering.getCpu();
  int currentMemory=currentServiceOffering.getRamSize();
  int currentSpeed=currentServiceOffering.getSpeed();
  if ((newSpeed < currentSpeed || newMemory < currentMemory || newCpu < currentCpu) || (newSpeed == currentSpeed && newMemory == currentMemory && newCpu == currentCpu)) {
    throw new InvalidParameterValueException("Only scaling up the vm is supported, new service offering should have both cpu and memory greater than the old values");
  }
  if (newCpu > currentCpu) {
    _resourceLimitMgr.checkResourceLimit(caller,ResourceType.cpu,newCpu - currentCpu);
  }
  if (newMemory > currentMemory) {
    _resourceLimitMgr.checkResourceLimit(caller,ResourceType.memory,newMemory - currentMemory);
  }
  boolean success=false;
  if (vmInstance.getState().equals(State.Running)) {
    int retry=_scaleRetry;
    ExcludeList excludes=new ExcludeList();
    boolean enableDynamicallyScaleVm=Boolean.parseBoolean(_configServer.getConfigValue(Config.EnableDynamicallyScaleVm.key(),Config.ConfigurationParameterScope.zone.toString(),vmInstance.getDataCenterId()));
    if (!enableDynamicallyScaleVm) {
      throw new PermissionDeniedException("Dynamically scaling virtual machines is disabled for this zone, please contact your admin");
    }
    while (retry-- != 0) {
      try {
        boolean existingHostHasCapacity=false;
        if (newCpu > currentCpu) {
          _resourceLimitMgr.incrementResourceCount(caller.getAccountId(),ResourceType.cpu,new Long(newCpu - currentCpu));
        }
        if (newMemory > currentMemory) {
          _resourceLimitMgr.incrementResourceCount(caller.getAccountId(),ResourceType.memory,new Long(newMemory - currentMemory));
        }
        if (!excludes.shouldAvoid(ApiDBUtils.findHostById(vmInstance.getHostId()))) {
          existingHostHasCapacity=_capacityMgr.checkIfHostHasCapacity(vmInstance.getHostId(),newServiceOffering.getSpeed() - currentServiceOffering.getSpeed(),(newServiceOffering.getRamSize() - currentServiceOffering.getRamSize()) * 1024L * 1024L,false,ApiDBUtils.getCpuOverprovisioningFactor(),1f,false);
          excludes.addHost(vmInstance.getHostId());
        }
        if (!existingHostHasCapacity) {
          _itMgr.findHostAndMigrate(vmInstance.getUuid(),newServiceOfferingId,excludes);
        }
        _itMgr.upgradeVmDb(vmId,newServiceOfferingId);
        vmInstance=_vmInstanceDao.findById(vmId);
        vmInstance=_itMgr.reConfigureVm(vmInstance,currentServiceOffering,existingHostHasCapacity);
        success=true;
        return success;
      }
 catch (      InsufficientCapacityException e) {
        s_logger.warn("Received exception while scaling ",e);
      }
catch (      ResourceUnavailableException e) {
        s_logger.warn("Received exception while scaling ",e);
      }
catch (      ConcurrentOperationException e) {
        s_logger.warn("Received exception while scaling ",e);
      }
catch (      Exception e) {
        s_logger.warn("Received exception while scaling ",e);
      }
 finally {
        if (!success) {
          _itMgr.upgradeVmDb(vmId,currentServiceOffering.getId());
          if (newCpu > currentCpu) {
            _resourceLimitMgr.decrementResourceCount(caller.getAccountId(),ResourceType.cpu,new Long(newCpu - currentCpu));
          }
          if (newMemory > currentMemory) {
            _resourceLimitMgr.decrementResourceCount(caller.getAccountId(),ResourceType.memory,new Long(newMemory - currentMemory));
          }
        }
      }
    }
  }
  return success;
}

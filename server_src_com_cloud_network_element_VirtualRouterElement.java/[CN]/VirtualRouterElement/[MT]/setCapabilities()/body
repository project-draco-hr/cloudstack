{
  final Map<Service,Map<Capability,String>> capabilities=new HashMap<Service,Map<Capability,String>>();
  final Map<Capability,String> lbCapabilities=new HashMap<Capability,String>();
  lbCapabilities.put(Capability.SupportedLBAlgorithms,"roundrobin,leastconn,source");
  lbCapabilities.put(Capability.SupportedLBIsolation,"dedicated");
  lbCapabilities.put(Capability.SupportedProtocols,"tcp, udp");
  lbCapabilities.put(Capability.SupportedStickinessMethods,getHAProxyStickinessCapability());
  lbCapabilities.put(Capability.LbSchemes,LoadBalancerContainer.Scheme.Public.toString());
  AutoScaleCounter counter;
  final List<AutoScaleCounter> counterList=new ArrayList<AutoScaleCounter>();
  counter=new AutoScaleCounter(AutoScaleCounterCpu);
  counterList.add(counter);
  counter=new AutoScaleCounter(AutoScaleCounterMemory);
  counterList.add(counter);
  final Gson gson=new Gson();
  final String autoScaleCounterList=gson.toJson(counterList);
  lbCapabilities.put(Capability.AutoScaleCounters,autoScaleCounterList);
  capabilities.put(Service.Lb,lbCapabilities);
  final Map<Capability,String> firewallCapabilities=new HashMap<Capability,String>();
  firewallCapabilities.put(Capability.TrafficStatistics,"per public ip");
  firewallCapabilities.put(Capability.SupportedProtocols,"tcp,udp,icmp");
  firewallCapabilities.put(Capability.SupportedEgressProtocols,"tcp,udp,icmp, all");
  firewallCapabilities.put(Capability.SupportedTrafficDirection,"ingress, egress");
  firewallCapabilities.put(Capability.MultipleIps,"true");
  capabilities.put(Service.Firewall,firewallCapabilities);
  final Map<Capability,String> vpnCapabilities=new HashMap<Capability,String>();
  vpnCapabilities.put(Capability.SupportedVpnProtocols,"pptp,l2tp,ipsec");
  vpnCapabilities.put(Capability.VpnTypes,"removeaccessvpn");
  capabilities.put(Service.Vpn,vpnCapabilities);
  final Map<Capability,String> dnsCapabilities=new HashMap<Capability,String>();
  dnsCapabilities.put(Capability.AllowDnsSuffixModification,"true");
  capabilities.put(Service.Dns,dnsCapabilities);
  capabilities.put(Service.UserData,null);
  final Map<Capability,String> dhcpCapabilities=new HashMap<Capability,String>();
  dhcpCapabilities.put(Capability.DhcpAccrossMultipleSubnets,"true");
  capabilities.put(Service.Dhcp,dhcpCapabilities);
  capabilities.put(Service.Gateway,null);
  final Map<Capability,String> sourceNatCapabilities=new HashMap<Capability,String>();
  sourceNatCapabilities.put(Capability.SupportedSourceNatTypes,"peraccount");
  sourceNatCapabilities.put(Capability.RedundantRouter,"true");
  capabilities.put(Service.SourceNat,sourceNatCapabilities);
  capabilities.put(Service.StaticNat,null);
  capabilities.put(Service.PortForwarding,null);
  return capabilities;
}

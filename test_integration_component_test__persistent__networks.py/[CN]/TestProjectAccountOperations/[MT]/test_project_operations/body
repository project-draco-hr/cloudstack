@attr(tags=['advanced'])
def test_project_operations(self):
    account = Account.create(self.apiclient, self.services['account'], domainid=self.domain.id)
    self.cleanup.append(account)
    project = Project.create(self.apiclient, self.services['project'])
    self.cleanup.append(project)
    network = Network.create(self.api_client, self.services['isolated_network'], networkofferingid=self.isolated_persistent_network_offering.id, accountid=account.name, domainid=self.domain.id, zoneid=self.zone.id)
    project.addAccount(self.apiclient, account=account.name)
    projectAccounts = Project.listAccounts(self.apiclient, projectid=project.id)
    self.assertEqual(validateList(projectAccounts)[0], PASS, ('project accounts list validation failed, list is %s' % projectAccounts))
    accountNames = [projectAccount.account for projectAccount in projectAccounts]
    self.assertTrue((account.name in accountNames), ('account %s is not present in account list %s of project %s' % (account.name, accountNames, project.id)))
    project.suspend(self.apiclient)
    projects = Project.list(self.apiclient, id=project.id)
    self.assertEqual(validateList(projects)[0], PASS, ('projects list validation failed, list is %s' % projects))
    self.assertEqual(str(projects[0].state).lower(), 'suspended', ('project state should be suspended, it is %s' % projects[0].state))
    wait_for_cleanup(self.api_client, ['network.gc.interval', 'network.gc.wait'])
    response = verifyNetworkState(self.apiclient, network.id, 'implemented')
    exceptionOccured = response[0]
    isNetworkInDesiredState = response[1]
    exceptionMessage = response[2]
    if (exceptionOccured or (not isNetworkInDesiredState)):
        self.fail(exceptionMessage)
    return

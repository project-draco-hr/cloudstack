{
  List<VolumeVO> volumesTobeCreated=_volsDao.findUsableVolumesForInstance(vmProfile.getId());
  Map<Volume,List<StoragePool>> suitableVolumeStoragePools=new HashMap<Volume,List<StoragePool>>();
  List<Volume> readyAndReusedVolumes=new ArrayList<Volume>();
  if (volumesTobeCreated.isEmpty()) {
    throw new CloudRuntimeException("Unable to create deployment, no usable volumes found for the VM");
  }
  Set<Long> originalAvoidPoolSet=avoid.getPoolsToAvoid();
  if (originalAvoidPoolSet == null) {
    originalAvoidPoolSet=new HashSet<Long>();
  }
  Set<Long> poolsToAvoidOutput=new HashSet<Long>(originalAvoidPoolSet);
  for (  VolumeVO toBeCreated : volumesTobeCreated) {
    s_logger.debug("Checking suitable pools for volume (Id, Type): (" + toBeCreated.getId() + ","+ toBeCreated.getVolumeType().name()+ ")");
    if (plan.getPoolId() != null) {
      s_logger.debug("Volume has pool already allocated, checking if pool can be reused, poolId: " + toBeCreated.getPoolId());
      List<StoragePool> suitablePools=new ArrayList<StoragePool>();
      StoragePool pool=null;
      if (toBeCreated.getPoolId() != null) {
        pool=(StoragePool)dataStoreMgr.getPrimaryDataStore(toBeCreated.getPoolId());
      }
 else {
        pool=(StoragePool)dataStoreMgr.getPrimaryDataStore(plan.getPoolId());
      }
      if (!pool.isInMaintenance()) {
        if (!avoid.shouldAvoid(pool)) {
          long exstPoolDcId=pool.getDataCenterId();
          long exstPoolPodId=pool.getPodId() != null ? pool.getPodId() : -1;
          long exstPoolClusterId=pool.getClusterId() != null ? pool.getClusterId() : -1;
          boolean canReusePool=false;
          if (plan.getDataCenterId() == exstPoolDcId && plan.getPodId() == exstPoolPodId && plan.getClusterId() == exstPoolClusterId) {
            canReusePool=true;
          }
 else           if (plan.getDataCenterId() == exstPoolDcId) {
            DataStore dataStore=dataStoreMgr.getPrimaryDataStore(pool.getId());
            if (dataStore != null && dataStore.getScope() != null && dataStore.getScope().getScopeType() == ScopeType.ZONE) {
              canReusePool=true;
            }
          }
 else {
            s_logger.debug("Pool of the volume does not fit the specified plan, need to reallocate a pool for this volume");
            canReusePool=false;
          }
          if (canReusePool) {
            s_logger.debug("Planner need not allocate a pool for this volume since its READY");
            suitablePools.add(pool);
            suitableVolumeStoragePools.put(toBeCreated,suitablePools);
            if (!(toBeCreated.getState() == Volume.State.Allocated || toBeCreated.getState() == Volume.State.Creating)) {
              readyAndReusedVolumes.add(toBeCreated);
            }
            continue;
          }
        }
 else {
          s_logger.debug("Pool of the volume is in avoid set, need to reallocate a pool for this volume");
        }
      }
 else {
        s_logger.debug("Pool of the volume is in maintenance, need to reallocate a pool for this volume");
      }
    }
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("We need to allocate new storagepool for this volume");
    }
    if (!isRootAdmin(plan.getReservationContext())) {
      if (!isEnabledForAllocation(plan.getDataCenterId(),plan.getPodId(),plan.getClusterId())) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Cannot allocate new storagepool for this volume in this cluster, allocation state is disabled");
          s_logger.debug("Cannot deploy to this specified plan, allocation state is disabled, returning.");
        }
        suitableVolumeStoragePools.clear();
        break;
      }
    }
    s_logger.debug("Calling StoragePoolAllocators to find suitable pools");
    DiskOfferingVO diskOffering=_diskOfferingDao.findById(toBeCreated.getDiskOfferingId());
    if (vmProfile.getTemplate().getFormat() == Storage.ImageFormat.ISO && vmProfile.getServiceOffering().getTagsArray().length != 0) {
      diskOffering.setTagsArray(Arrays.asList(vmProfile.getServiceOffering().getTagsArray()));
    }
    DiskProfile diskProfile=new DiskProfile(toBeCreated,diskOffering,vmProfile.getHypervisorType());
    boolean useLocalStorage=false;
    if (vmProfile.getType() != VirtualMachine.Type.User) {
      String ssvmUseLocalStorage=_configDao.getValue(Config.SystemVMUseLocalStorage.key());
      if (ssvmUseLocalStorage.equalsIgnoreCase("true")) {
        useLocalStorage=true;
      }
    }
 else {
      useLocalStorage=diskOffering.getUseLocalStorage();
      if (!useLocalStorage && vmProfile.getServiceOffering().getUseLocalStorage()) {
        if (toBeCreated.getVolumeType() == Volume.Type.ROOT)         useLocalStorage=true;
      }
    }
    diskProfile.setUseLocalStorage(useLocalStorage);
    boolean foundPotentialPools=false;
    for (    StoragePoolAllocator allocator : _storagePoolAllocators) {
      final List<StoragePool> suitablePools=allocator.allocateToPool(diskProfile,vmProfile,plan,avoid,returnUpTo);
      if (suitablePools != null && !suitablePools.isEmpty()) {
        suitableVolumeStoragePools.put(toBeCreated,suitablePools);
        foundPotentialPools=true;
        break;
      }
    }
    if (avoid.getPoolsToAvoid() != null) {
      poolsToAvoidOutput.addAll(avoid.getPoolsToAvoid());
      avoid.getPoolsToAvoid().retainAll(originalAvoidPoolSet);
    }
    if (!foundPotentialPools) {
      s_logger.debug("No suitable pools found for volume: " + toBeCreated + " under cluster: "+ plan.getClusterId());
      suitableVolumeStoragePools.clear();
      break;
    }
  }
  HashSet<Long> toRemove=new HashSet<Long>();
  for (  List<StoragePool> lsp : suitableVolumeStoragePools.values()) {
    for (    StoragePool sp : lsp) {
      toRemove.add(sp.getId());
    }
  }
  poolsToAvoidOutput.removeAll(toRemove);
  if (avoid.getPoolsToAvoid() != null) {
    avoid.getPoolsToAvoid().addAll(poolsToAvoidOutput);
  }
  if (suitableVolumeStoragePools.isEmpty()) {
    s_logger.debug("No suitable pools found");
  }
  return new Pair<Map<Volume,List<StoragePool>>,List<Volume>>(suitableVolumeStoragePools,readyAndReusedVolumes);
}

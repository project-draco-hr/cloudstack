{
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Allocating entries for VM: " + vm);
  }
  VirtualMachineProfile vmProfile=new VirtualMachineProfile(vm,serviceOffering);
  Transaction txn=Transaction.currentTxn();
  txn.start();
  List<NicProfile> nics=_networkMgr.allocate(vm,networks);
  vmProfile.setNics(nics);
  List<DiskProfile> disks=new ArrayList<DiskProfile>(dataDiskOfferings.size() + 1);
  VolumeVO volume=_storageMgr.allocate(VolumeType.ROOT,rootDiskOffering.first(),"ROOT-" + vm.getId(),rootDiskOffering.second(),template.getFormat() != ImageFormat.ISO ? template : null,vm,owner);
  for (  Pair<DiskOfferingVO,Long> offering : dataDiskOfferings) {
    volume=_storageMgr.allocate(VolumeType.DATADISK,offering.first(),"DATA-" + vm.getId(),offering.second(),null,vm,owner);
  }
  txn.commit();
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Allocation completed for VM: " + vm);
  }
  boolean created=false;
  try {
    vmProfile=create(vmProfile,plan);
    created=vmProfile != null;
  }
 catch (  InsufficientCapacityException e) {
    throw e;
  }
 finally {
    if (!created) {
    }
  }
  return vmProfile;
}

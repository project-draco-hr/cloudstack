import cloud_utils
from cloud_utils import Command
import logging
import sys
import os
import xml.dom.minidom
from optparse import OptionParser, OptionGroup, OptParseError, BadOptionError, OptionError, OptionConflictError, OptionValueError
iptables = Command('iptables')
bash = Command('/bin/bash')
virsh = Command('virsh')
ebtablessave = Command('ebtables-save')
ebtables = Command('ebtables')
augtool = Command('augtool')
'\ndef ipset(ipsetname, proto, start, end, ips):\n    try:\n        check_call([\'ipset\', \'-N\', ipsetname, \'iptreemap\'])\n    except:\n        logging.debug("ipset chain already exists" + ipsetname)\n\n    result = True\n    ipsettmp = \'\'.join(\'\'.join(ipsetname.split(\'-\')).split(\'_\')) + str(int(time.time()) % 1000)\n\n    try: \n        check_call([\'ipset\', \'-N\', ipsettmp, \'iptreemap\']) \n        for ip in ips:\n            try:\n                check_call([\'ipset\', \'-A\', ipsettmp, ip])\n            except CommandException, cex:\n                if cex.reason.rfind(\'already in set\') == -1:\n                   raise\n        check_call([\'ipset\', \'-W\', ipsettmp, ipsetname]) \n        check_call([\'ipset\', \'-X\', ipsettmp]) \n    except:\n        logging.debug("Failed to program ipset " + ipsetname)\n        result = False\n\n    return result\n'
'  \ndef network_rules_for_rebooted_vm(vmName):\n    vm_name = vmName\n    vifs = getVifs(vmName) \n    logging.debug("Found a rebooted VM -- reprogramming rules for  " + vmName)\n    \n    delete_rules_for_vm_in_bridge_firewall_chain(vmName)\n    if 1 in [ vm_name.startswith(c) for c in [\'r-\', \'s-\', \'v-\'] ]:\n        default_network_rules_systemvm(session, {"vmName":vmName})\n        return True\n    \n    vmchain = \'-\'.join(vm_name.split(\'-\')[:-1])\n    vmchain_default = \'-\'.join(vm_name.split(\'-\')[:-2]) + "-def"\n\n    for v in vifs:\n        iptables(\'-A\', \'BRIDGE-FIREWALL\', \'-m\', \'physdev\', \'--physdev-is-bridged\', \'--physdev-out\', v, \'-j\', vmchain_default)\n        iptables(\'-A\', \'BRIDGE-FIREWALL\', \'-m\', \'physdev\', \'--physdev-is-bridged\', \'--physdev-in\', v, \'-j\', vmchain_default)\n\n    #change antispoof rule in vmchain\n    try:\n        delcmd = "iptables -S " +  vmchain_default + " | grep  physdev-in | sed \'s/-A/-D/\'"\n        inscmd = "iptables -S " +  vmchain_default + " | grep  physdev-in | grep vif | sed -r \'s/vif[0-9]+.0/" + vif + "/\' | sed \'s/-A/-I/\'"\n        inscmd2 = "iptables -S " +  vmchain_default + " | grep  physdev-in | grep tap | sed -r \'s/tap[0-9]+.0/" + tap + "/\' | sed \'s/-A/-I/\'"\n        \n        ipts = []\n        for cmd in [delcmd, inscmd, inscmd2]:\n            cmds = bash(\'-c\', cmd.split(\' \')).split(\'\n\')\n            cmds.pop()\n            for c in cmds:\n                    ipt = c.split(\' \')\n                    ipt.pop()\n                    ipts.append(ipt)\n        \n        for ipt in ipts:\n            try:\n                iptables(ipt)\n            except:\n                logging.debug("Failed to rewrite antispoofing rules for vm " + vmName)\n    except:\n        logging.debug("No rules found for vm " + vmchain)\n\n\n    rewrite_rule_log_for_vm(vmName, curr_domid)\n    return True\n'
if (__name__ == '__main__'):
    logging.basicConfig(filename='/var/log/cloud/security_group.log', format='%(asctime)s - %(message)s', level=logging.DEBUG)
    parser = OptionParser()
    parser.add_option('--vmname', dest='vmName')
    parser.add_option('--vmip', dest='vmIP')
    parser.add_option('--vmid', dest='vmID')
    parser.add_option('--vmmac', dest='vmMAC')
    parser.add_option('--vif', dest='vif')
    parser.add_option('--sig', dest='sig')
    parser.add_option('--seq', dest='seq')
    parser.add_option('--rules', dest='rules')
    (option, args) = parser.parse_args()
    cmd = args[0]
    if (cmd == 'can_bridge_firewall'):
        can_bridge_firewall(args[1])
    elif (cmd == 'default_network_rules'):
        default_network_rules(option.vmName, option.vmIP, option.vmID, option.vmMAC)
    elif (cmd == 'destroy_network_rules_for_vm'):
        destroy_network_rules_for_vm(option.vmName)
    elif (cmd == 'default_network_rules_systemvm'):
        default_network_rules_systemvm(option.vmName)
    elif (cmd == 'get_rule_logs_for_vms'):
        get_rule_logs_for_vms()
    elif (cmd == 'add_network_rules'):
        add_network_rules(option.vmName, option.vmID, option.vmIP, option.sig, option.seq, option.vmMAC, option.rules)

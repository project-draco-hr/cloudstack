{
  UserContext caller=UserContext.current();
  Ip srcIp=lb.getSourceIpAddress();
  IPAddressVO ipAddr=_ipAddressDao.findById(srcIp.addr());
  if (ipAddr == null || !ipAddr.readyToUse()) {
    throw new InvalidParameterValueException("Unable to create load balancer rule, invalid IP address " + srcIp);
  }
  int srcPortStart=lb.getSourcePortStart();
  int srcPortEnd=lb.getSourcePortEnd();
  int defPortStart=lb.getDefaultPortStart();
  int defPortEnd=lb.getDefaultPortEnd();
  if (!NetUtils.isValidPort(srcPortStart)) {
    throw new InvalidParameterValueException("publicPort is an invalid value: " + srcPortStart);
  }
  if (!NetUtils.isValidPort(srcPortEnd)) {
    throw new InvalidParameterValueException("Public port range is an invalid value: " + srcPortEnd);
  }
  if (srcPortStart > srcPortEnd) {
    throw new InvalidParameterValueException("Public port range is an invalid value: " + srcPortStart + "-"+ srcPortEnd);
  }
  if (!NetUtils.isValidPort(defPortStart)) {
    throw new InvalidParameterValueException("privatePort is an invalid value: " + defPortStart);
  }
  if (!NetUtils.isValidPort(defPortEnd)) {
    throw new InvalidParameterValueException("privatePort is an invalid value: " + defPortEnd);
  }
  if (defPortStart > defPortEnd) {
    throw new InvalidParameterValueException("private port range is invalid: " + defPortStart + "-"+ defPortEnd);
  }
  if ((lb.getAlgorithm() == null) || !NetUtils.isValidAlgorithm(lb.getAlgorithm())) {
    throw new InvalidParameterValueException("Invalid algorithm: " + lb.getAlgorithm());
  }
  Long networkId=lb.getNetworkId();
  if (networkId == -1) {
    networkId=ipAddr.getAssociatedNetworkId();
  }
  _accountMgr.checkAccess(caller.getAccount(),ipAddr);
  LoadBalancerVO newRule=new LoadBalancerVO(lb.getXid(),lb.getName(),lb.getDescription(),lb.getSourceIpAddress(),lb.getSourcePortEnd(),lb.getDefaultPortStart(),lb.getAlgorithm(),networkId,ipAddr.getAccountId(),ipAddr.getDomainId());
  newRule=_lbDao.persist(newRule);
  boolean success=false;
  try {
    _rulesMgr.detectRulesConflict(newRule,ipAddr);
    if (!_rulesDao.setStateToAdd(newRule)) {
      throw new CloudRuntimeException("Unable to update the state to add for " + newRule);
    }
    s_logger.debug("Load balancer " + newRule.getId() + " for Ip address "+ srcIp+ ", public port "+ srcPortStart+ ", private port "+ defPortStart+ " is added successfully.");
    success=true;
    return newRule;
  }
 catch (  Exception e) {
    _lbDao.remove(newRule.getId());
    if (e instanceof NetworkRuleConflictException) {
      throw (NetworkRuleConflictException)e;
    }
    throw new CloudRuntimeException("Unable to add rule for " + newRule.getSourceIpAddress(),e);
  }
 finally {
    long userId=caller.getUserId();
    EventVO event=new EventVO();
    event.setUserId(userId);
    event.setAccountId(ipAddr.getAllocatedToAccountId());
    event.setType(EventTypes.EVENT_LOAD_BALANCER_CREATE);
    if (!success) {
      event.setDescription("Failed to create load balancer " + lb.getName() + " on ip address "+ srcIp+ "["+ srcPortStart+ "->"+ defPortStart+ "]");
      event.setLevel(EventVO.LEVEL_ERROR);
    }
 else {
      event.setDescription("Successfully created load balancer " + lb.getName() + " on ip address "+ srcIp+ "["+ srcPortStart+ "->"+ defPortStart+ "]");
      String params="id=" + newRule.getId() + "\ndcId="+ ipAddr.getDataCenterId();
      event.setParameters(params);
      event.setLevel(EventVO.LEVEL_INFO);
    }
    _eventDao.persist(event);
  }
}

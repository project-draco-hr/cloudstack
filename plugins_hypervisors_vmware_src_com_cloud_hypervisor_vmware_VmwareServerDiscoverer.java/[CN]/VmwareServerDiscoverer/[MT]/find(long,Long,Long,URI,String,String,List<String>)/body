{
  if (s_logger.isInfoEnabled())   s_logger.info("Discover host. dc: " + dcId + ", pod: "+ podId+ ", cluster: "+ clusterId+ ", uri host: "+ url.getHost());
  if (podId == null) {
    if (s_logger.isInfoEnabled())     s_logger.info("No pod is assigned, assuming that it is not for vmware and skip it to next discoverer");
    return null;
  }
  ClusterVO cluster=_clusterDao.findById(clusterId);
  if (cluster == null || cluster.getHypervisorType() != HypervisorType.VMware) {
    if (s_logger.isInfoEnabled())     s_logger.info("invalid cluster id or cluster is not for VMware hypervisors");
    return null;
  }
  Map<String,String> clusterDetails=_clusterDetailsDao.findDetails(clusterId);
  boolean legacyZone=_vmwareMgr.isLegacyZone(dcId);
  if (!legacyZone) {
    String updatedInventoryPath=validateCluster(dcId,url,username,password);
    if (url.getPath() != updatedInventoryPath) {
      clusterDetails.put("url",url.getScheme() + "://" + url.getHost()+ updatedInventoryPath);
      _clusterDetailsDao.persist(clusterId,clusterDetails);
    }
  }
  List<HostVO> hosts=_resourceMgr.listAllHostsInCluster(clusterId);
  if (hosts != null && hosts.size() > 0) {
    int maxHostsPerCluster=_hvCapabilitiesDao.getMaxHostsPerCluster(hosts.get(0).getHypervisorType(),hosts.get(0).getHypervisorVersion());
    if (hosts.size() >= maxHostsPerCluster) {
      String msg="VMware cluster " + cluster.getName() + " is too big to add new host, current size: "+ hosts.size()+ ", max. size: "+ maxHostsPerCluster;
      s_logger.error(msg);
      throw new DiscoveredWithErrorException(msg);
    }
  }
  String privateTrafficLabel=null;
  String publicTrafficLabel=null;
  String guestTrafficLabel=null;
  Map<String,String> vsmCredentials=null;
  VirtualSwitchType defaultVirtualSwitchType=VirtualSwitchType.StandardVirtualSwitch;
  String paramGuestVswitchType=null;
  String paramGuestVswitchName=null;
  String paramPublicVswitchType=null;
  String paramPublicVswitchName=null;
  VmwareTrafficLabel guestTrafficLabelObj=new VmwareTrafficLabel(TrafficType.Guest);
  VmwareTrafficLabel publicTrafficLabelObj=new VmwareTrafficLabel(TrafficType.Public);
  DataCenterVO zone=_dcDao.findById(dcId);
  NetworkType zoneType=zone.getNetworkType();
  _readGlobalConfigParameters();
  if (useDVS) {
    paramGuestVswitchType=_urlParams.get(ApiConstants.VSWITCH_TYPE_GUEST_TRAFFIC);
    paramGuestVswitchName=_urlParams.get(ApiConstants.VSWITCH_NAME_GUEST_TRAFFIC);
    paramPublicVswitchType=_urlParams.get(ApiConstants.VSWITCH_TYPE_PUBLIC_TRAFFIC);
    paramPublicVswitchName=_urlParams.get(ApiConstants.VSWITCH_NAME_PUBLIC_TRAFFIC);
    defaultVirtualSwitchType=getDefaultVirtualSwitchType();
  }
  guestTrafficLabel=_netmgr.getDefaultGuestTrafficLabel(dcId,HypervisorType.VMware);
  guestTrafficLabelObj=getTrafficInfo(TrafficType.Guest,guestTrafficLabel,defaultVirtualSwitchType,paramGuestVswitchType,paramGuestVswitchName,clusterId);
  if (zoneType == NetworkType.Advanced) {
    publicTrafficLabel=_netmgr.getDefaultPublicTrafficLabel(dcId,HypervisorType.VMware);
    publicTrafficLabelObj=getTrafficInfo(TrafficType.Public,publicTrafficLabel,defaultVirtualSwitchType,paramPublicVswitchType,paramPublicVswitchName,clusterId);
    List<? extends PhysicalNetwork> pNetworkListGuestTraffic=_netmgr.getPhysicalNtwksSupportingTrafficType(dcId,TrafficType.Guest);
    List<? extends PhysicalNetwork> pNetworkListPublicTraffic=_netmgr.getPhysicalNtwksSupportingTrafficType(dcId,TrafficType.Public);
    PhysicalNetwork pNetworkPublic=pNetworkListPublicTraffic.get(0);
    if (pNetworkListGuestTraffic.contains(pNetworkPublic)) {
      if (publicTrafficLabelObj.getVirtualSwitchType() != guestTrafficLabelObj.getVirtualSwitchType()) {
        String msg="Both public traffic and guest traffic is over same physical network " + pNetworkPublic + ". And virtual switch type chosen for each traffic is different"+ ". A physical network cannot be shared by different types of virtual switches.";
        s_logger.error(msg);
        throw new InvalidParameterValueException(msg);
      }
    }
  }
 else {
    if (guestTrafficLabelObj.getVirtualSwitchType() != VirtualSwitchType.StandardVirtualSwitch) {
      String msg="Detected that Guest traffic is over Distributed virtual switch in Basic zone. Only Standard vSwitch is supported in Basic zone.";
      s_logger.error(msg);
      throw new DiscoveredWithErrorException(msg);
    }
  }
  privateTrafficLabel=_netmgr.getDefaultManagementTrafficLabel(dcId,HypervisorType.VMware);
  if (privateTrafficLabel != null) {
    s_logger.info("Detected private network label : " + privateTrafficLabel);
  }
  if (nexusDVS) {
    if (zoneType != NetworkType.Basic) {
      publicTrafficLabel=_netmgr.getDefaultPublicTrafficLabel(dcId,HypervisorType.VMware);
      if (publicTrafficLabel != null) {
        s_logger.info("Detected public network label : " + publicTrafficLabel);
      }
    }
    guestTrafficLabel=_netmgr.getDefaultGuestTrafficLabel(dcId,HypervisorType.VMware);
    if (guestTrafficLabel != null) {
      s_logger.info("Detected guest network label : " + guestTrafficLabel);
    }
    String vsmIp=_urlParams.get("vsmipaddress");
    String vsmUser=_urlParams.get("vsmusername");
    String vsmPassword=_urlParams.get("vsmpassword");
    String clusterName=cluster.getName();
    try {
      _nexusElement.validateVsmCluster(vsmIp,vsmUser,vsmPassword,clusterId,clusterName);
    }
 catch (    ResourceInUseException ex) {
      DiscoveryException discEx=new DiscoveryException(ex.getLocalizedMessage() + ". The resource is " + ex.getResourceName());
      throw discEx;
    }
    vsmCredentials=_vmwareMgr.getNexusVSMCredentialsByClusterId(clusterId);
  }
  VmwareContext context=null;
  try {
    context=VmwareContextFactory.create(url.getHost(),username,password);
    if (privateTrafficLabel != null)     context.registerStockObject("privateTrafficLabel",privateTrafficLabel);
    if (nexusDVS) {
      if (vsmCredentials != null) {
        s_logger.info("Stocking credentials of Nexus VSM");
        context.registerStockObject("vsmcredentials",vsmCredentials);
      }
    }
    List<ManagedObjectReference> morHosts=_vmwareMgr.addHostToPodCluster(context,dcId,podId,clusterId,URLDecoder.decode(url.getPath()));
    if (morHosts == null)     s_logger.info("Found 0 hosts.");
    if (privateTrafficLabel != null)     context.uregisterStockObject("privateTrafficLabel");
    if (morHosts == null) {
      s_logger.error("Unable to find host or cluster based on url: " + URLDecoder.decode(url.getPath()));
      return null;
    }
    ManagedObjectReference morCluster=null;
    clusterDetails=_clusterDetailsDao.findDetails(clusterId);
    if (clusterDetails.get("url") != null) {
      URI uriFromCluster=new URI(UriUtils.encodeURIComponent(clusterDetails.get("url")));
      morCluster=context.getHostMorByPath(URLDecoder.decode(uriFromCluster.getPath()));
      if (morCluster == null || !morCluster.getType().equalsIgnoreCase("ClusterComputeResource")) {
        s_logger.warn("Cluster url does not point to a valid vSphere cluster, url: " + clusterDetails.get("url"));
        return null;
      }
 else {
        ClusterMO clusterMo=new ClusterMO(context,morCluster);
        ClusterDasConfigInfo dasConfig=clusterMo.getDasConfig();
        if (dasConfig != null && dasConfig.isEnabled() != null && dasConfig.isEnabled().booleanValue()) {
          clusterDetails.put("NativeHA","true");
          _clusterDetailsDao.persist(clusterId,clusterDetails);
        }
      }
    }
    if (!validateDiscoveredHosts(context,morCluster,morHosts)) {
      if (morCluster == null)       s_logger.warn("The discovered host is not standalone host, can not be added to a standalone cluster");
 else       s_logger.warn("The discovered host does not belong to the cluster");
      return null;
    }
    Map<VmwareResource,Map<String,String>> resources=new HashMap<VmwareResource,Map<String,String>>();
    for (    ManagedObjectReference morHost : morHosts) {
      Map<String,String> details=new HashMap<String,String>();
      Map<String,Object> params=new HashMap<String,Object>();
      HostMO hostMo=new HostMO(context,morHost);
      details.put("url",hostMo.getHostName());
      details.put("username",username);
      details.put("password",password);
      String guid=morHost.getType() + ":" + morHost.getValue()+ "@"+ url.getHost();
      details.put("guid",guid);
      params.put("url",hostMo.getHostName());
      params.put("username",username);
      params.put("password",password);
      params.put("zone",Long.toString(dcId));
      params.put("pod",Long.toString(podId));
      params.put("cluster",Long.toString(clusterId));
      params.put("guid",guid);
      if (privateTrafficLabel != null) {
        params.put("private.network.vswitch.name",privateTrafficLabel);
      }
      params.put("guestTrafficInfo",guestTrafficLabelObj);
      params.put("publicTrafficInfo",publicTrafficLabelObj);
      VmwareResource resource=new VmwareResource();
      try {
        resource.configure("VMware",params);
      }
 catch (      ConfigurationException e) {
        _alertMgr.sendAlert(AlertManager.ALERT_TYPE_HOST,dcId,podId,"Unable to add " + url.getHost(),"Error is " + e.getMessage());
        s_logger.warn("Unable to instantiate " + url.getHost(),e);
      }
      resource.start();
      resources.put(resource,details);
    }
    cluster.setGuid(UUID.nameUUIDFromBytes(String.valueOf(clusterId).getBytes()).toString());
    _clusterDao.update(clusterId,cluster);
    return resources;
  }
 catch (  DiscoveredWithErrorException e) {
    throw e;
  }
catch (  Exception e) {
    s_logger.warn("Unable to connect to Vmware vSphere server. service address: " + url.getHost());
    return null;
  }
 finally {
    if (context != null)     context.close();
  }
}

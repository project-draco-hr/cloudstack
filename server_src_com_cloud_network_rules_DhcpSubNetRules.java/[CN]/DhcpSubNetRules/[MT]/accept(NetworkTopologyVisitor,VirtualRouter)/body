{
  _router=router;
  final UserVmVO vm=_userVmDao.findById(_profile.getId());
  _userVmDao.loadDetails(vm);
  final NicVO domr_guest_nic=_nicDao.findByInstanceIdAndIpAddressAndVmtype(router.getId(),_nicDao.getIpAddress(_nic.getNetworkId(),router.getId()),VirtualMachine.Type.DomainRouter);
  if (!NetUtils.sameSubnet(domr_guest_nic.getIp4Address(),_nic.getIp4Address(),_nic.getNetmask())) {
    final List<NicIpAliasVO> aliasIps=_nicIpAliasDao.listByNetworkIdAndState(domr_guest_nic.getNetworkId(),NicIpAlias.state.active);
    boolean ipInVmsubnet=false;
    for (    final NicIpAliasVO alias : aliasIps) {
      if (NetUtils.sameSubnet(alias.getIp4Address(),_nic.getIp4Address(),_nic.getNetmask())) {
        ipInVmsubnet=true;
        break;
      }
    }
    PublicIp routerPublicIP=null;
    final DataCenter dc=_dcDao.findById(router.getDataCenterId());
    if (ipInVmsubnet == false) {
      try {
        if (_network.getTrafficType() == TrafficType.Guest && _network.getGuestType() == GuestType.Shared) {
          _podDao.findById(vm.getPodIdToDeployIn());
          final Account caller=CallContext.current().getCallingAccount();
          final List<VlanVO> vlanList=_vlanDao.listVlansByNetworkIdAndGateway(_network.getId(),_nic.getGateway());
          final List<Long> vlanDbIdList=new ArrayList<Long>();
          for (          final VlanVO vlan : vlanList) {
            vlanDbIdList.add(vlan.getId());
          }
          if (dc.getNetworkType() == NetworkType.Basic) {
            routerPublicIP=_ipAddrMgr.assignPublicIpAddressFromVlans(router.getDataCenterId(),vm.getPodIdToDeployIn(),caller,Vlan.VlanType.DirectAttached,vlanDbIdList,_nic.getNetworkId(),null,false);
          }
 else {
            routerPublicIP=_ipAddrMgr.assignPublicIpAddressFromVlans(router.getDataCenterId(),null,caller,Vlan.VlanType.DirectAttached,vlanDbIdList,_nic.getNetworkId(),null,false);
          }
          _routerAliasIp=routerPublicIP.getAddress().addr();
        }
      }
 catch (      final InsufficientAddressCapacityException e) {
        s_logger.info(e.getMessage());
        s_logger.info("unable to configure dhcp for this VM.");
        return false;
      }
      _nicAlias=new NicIpAliasVO(domr_guest_nic.getId(),_routerAliasIp,router.getId(),CallContext.current().getCallingAccountId(),_network.getDomainId(),_nic.getNetworkId(),_nic.getGateway(),_nic.getNetmask());
      _nicAlias.setAliasCount((routerPublicIP.getIpMacAddress()));
      _nicIpAliasDao.persist(_nicAlias);
      final boolean result=visitor.visit(this);
      _routerAliasIp=null;
      if (result == false) {
        final NicIpAliasVO ipAliasVO=_nicIpAliasDao.findByInstanceIdAndNetworkId(_network.getId(),router.getId());
        final PublicIp routerPublicIPFinal=routerPublicIP;
        Transaction.execute(new TransactionCallbackNoReturn(){
          @Override public void doInTransactionWithoutResult(          final TransactionStatus status){
            _nicIpAliasDao.expunge(ipAliasVO.getId());
            _ipAddressDao.unassignIpAddress(routerPublicIPFinal.getId());
          }
        }
);
        throw new CloudRuntimeException("failed to configure ip alias on the router as a part of dhcp config");
      }
    }
    return true;
  }
  return visitor.visit(this);
}

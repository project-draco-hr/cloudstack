def check_auth_publickey(self, username, key):
    "\n        Determine if a given key supplied by the client is acceptable for use\n        in authentication.  You should override this method in server mode to\n        check the username and key and decide if you would accept a signature\n        made using this key.\n\n        Return L{AUTH_FAILED} if the key is not accepted,\n        L{AUTH_SUCCESSFUL} if the key is accepted and completes the\n        authentication, or L{AUTH_PARTIALLY_SUCCESSFUL} if your\n        authentication is stateful, and this password is accepted for\n        authentication, but more authentication is required.  (In this latter\n        case, L{get_allowed_auths} will be called to report to the client what\n        options it has for continuing the authentication.)\n\n        Note that you don't have to actually verify any key signtature here.\n        If you're willing to accept the key, paramiko will do the work of\n        verifying the client's signature.\n        \n        The default implementation always returns L{AUTH_FAILED}.\n\n        @param username: the username of the authenticating client\n        @type username: str\n        @param key: the key object provided by the client\n        @type key: L{PKey <pkey.PKey>}\n        @return: L{AUTH_FAILED} if the client can't authenticate\n            with this key; L{AUTH_SUCCESSFUL} if it can;\n            L{AUTH_PARTIALLY_SUCCESSFUL} if it can authenticate with\n            this key but must continue with authentication\n        @rtype: int\n        "
    return AUTH_FAILED

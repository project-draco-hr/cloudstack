@attr(tags=['advanced', 'nuagevsp'], required_hardware='true')
def test_06_nuage_internallb_algorithms_traffic(self):
    'Test Nuage VSP VPC Internal LB functionality with different LB algorithms by performing (wget) traffic tests\n        within a VPC\n        '
    self.debug('Creating Nuage VSP VPC offering with Internal LB service...')
    vpc_off = self.create_VpcOffering(self.test_data['nuagevsp']['vpc_offering_lb'])
    self.validate_VpcOffering(vpc_off, state='Enabled')
    self.debug('Creating a VPC with Internal LB service...')
    vpc = self.create_Vpc(vpc_off, cidr='10.1.0.0/16')
    self.validate_Vpc(vpc, state='Enabled')
    self.debug('Creating Nuage VSP VPC Network offering with Internal LB service...')
    net_off_1 = self.create_NetworkOffering(self.test_data['nuagevsp']['vpc_network_offering_internal_lb'])
    self.validate_NetworkOffering(net_off_1, state='Enabled')
    self.debug('Creating Nuage VSP VPC Network offering without Internal LB service...')
    net_off_2 = self.create_NetworkOffering(self.test_data['nuagevsp']['vpc_network_offering'])
    self.validate_NetworkOffering(net_off_2, state='Enabled')
    self.debug('Creating a VPC network with Internal LB service...')
    internal_tier = self.create_Network(net_off_1, gateway='10.1.1.1', vpc=vpc)
    self.validate_Network(internal_tier, state='Implemented')
    vr = self.get_Router(internal_tier)
    self.check_Router_state(vr, state='Running')
    self.debug('Deploying a VM in the created VPC network...')
    internal_vm = self.create_VM(internal_tier)
    self.check_VM_state(internal_vm, state='Running')
    self.verify_vsd_network(self.domain.id, internal_tier, vpc)
    self.verify_vsd_router(vr)
    self.verify_vsd_vm(internal_vm)
    self.debug('Creating a VPC network without Internal LB service...')
    public_tier = self.create_Network(net_off_2, gateway='10.1.2.1', vpc=vpc)
    self.validate_Network(public_tier, state='Implemented')
    vr = self.get_Router(public_tier)
    self.check_Router_state(vr, state='Running')
    self.debug('Deploying a VM in the created VPC network...')
    public_vm = self.create_VM(public_tier)
    self.check_VM_state(public_vm, state='Running')
    self.verify_vsd_network(self.domain.id, public_tier, vpc)
    self.verify_vsd_router(vr)
    self.verify_vsd_vm(public_vm)
    self.debug('Creating two Internal LB Rules (SSH & HTTP) with Round Robin Algorithm...')
    int_lb_rule_1 = self.create_Internal_LB_Rule(internal_tier, vm_array=[internal_vm])
    self.validate_Internal_LB_Rule(int_lb_rule_1, state='Active', vm_array=[internal_vm])
    int_lb_rule_2 = self.create_Internal_LB_Rule(internal_tier, vm_array=[internal_vm], services=self.test_data['internal_lbrule_http'], source_ip=int_lb_rule_1.sourceipaddress)
    self.validate_Internal_LB_Rule(int_lb_rule_2, state='Active', vm_array=[internal_vm])
    int_lb_vm_1 = self.get_InternalLbVm(internal_tier, int_lb_rule_1.sourceipaddress)
    self.check_InternalLbVm_state(internal_tier, int_lb_rule_1.sourceipaddress, state='Running')
    self.verify_vsd_lb_device(int_lb_vm_1)
    self.debug(('Deploying two more VMs in network - %s' % internal_tier.name))
    internal_vm_1 = self.create_VM(internal_tier)
    internal_vm_2 = self.create_VM(internal_tier)
    self.verify_vsd_vm(internal_vm_1)
    self.verify_vsd_vm(internal_vm_2)
    self.debug('Adding two more virtual machines to the created Internal LB rules...')
    int_lb_rule_1.assign(self.api_client, [internal_vm_1, internal_vm_2])
    self.validate_Internal_LB_Rule(int_lb_rule_1, state='Active', vm_array=[internal_vm, internal_vm_1, internal_vm_2])
    int_lb_rule_2.assign(self.api_client, [internal_vm_1, internal_vm_2])
    self.validate_Internal_LB_Rule(int_lb_rule_2, state='Active', vm_array=[internal_vm, internal_vm_1, internal_vm_2])
    self.check_InternalLbVm_state(internal_tier, int_lb_rule_1.sourceipaddress, state='Running')
    self.verify_vsd_lb_device(int_lb_vm_1)
    self.debug('Creating two Internal LB Rules (SSH & HTTP) with Least connections Algorithm...')
    self.test_data['internal_lbrule']['algorithm'] = 'leastconn'
    int_lb_rule_3 = self.create_Internal_LB_Rule(internal_tier, vm_array=[internal_vm, internal_vm_1, internal_vm_2], services=self.test_data['internal_lbrule'])
    self.validate_Internal_LB_Rule(int_lb_rule_3, state='Active', vm_array=[internal_vm, internal_vm_1, internal_vm_2])
    self.test_data['internal_lbrule_http']['algorithm'] = 'leastconn'
    int_lb_rule_4 = self.create_Internal_LB_Rule(internal_tier, vm_array=[internal_vm, internal_vm_1, internal_vm_2], services=self.test_data['internal_lbrule_http'], source_ip=int_lb_rule_3.sourceipaddress)
    self.validate_Internal_LB_Rule(int_lb_rule_4, state='Active', vm_array=[internal_vm, internal_vm_1, internal_vm_2])
    int_lb_vm_2 = self.get_InternalLbVm(internal_tier, int_lb_rule_3.sourceipaddress)
    self.check_InternalLbVm_state(internal_tier, int_lb_rule_3.sourceipaddress, state='Running')
    self.verify_vsd_lb_device(int_lb_vm_2)
    self.debug('Creating two Internal LB Rules (SSH & HTTP) with Source Algorithm...')
    self.test_data['internal_lbrule']['algorithm'] = 'source'
    int_lb_rule_5 = self.create_Internal_LB_Rule(internal_tier, vm_array=[internal_vm, internal_vm_1, internal_vm_2], services=self.test_data['internal_lbrule'])
    self.validate_Internal_LB_Rule(int_lb_rule_5, state='Active', vm_array=[internal_vm, internal_vm_1, internal_vm_2])
    self.test_data['internal_lbrule_http']['algorithm'] = 'source'
    int_lb_rule_6 = self.create_Internal_LB_Rule(internal_tier, vm_array=[internal_vm, internal_vm_1, internal_vm_2], services=self.test_data['internal_lbrule_http'], source_ip=int_lb_rule_5.sourceipaddress)
    self.validate_Internal_LB_Rule(int_lb_rule_6, state='Active', vm_array=[internal_vm, internal_vm_1, internal_vm_2])
    int_lb_vm_3 = self.get_InternalLbVm(internal_tier, int_lb_rule_5.sourceipaddress)
    self.check_InternalLbVm_state(internal_tier, int_lb_rule_5.sourceipaddress, state='Running')
    self.verify_vsd_lb_device(int_lb_vm_3)
    self.debug('Adding Network ACL rules to make the created Internal LB rules (SSH & HTTP) accessible...')
    ssh_rule = self.create_NetworkAclRule(self.test_data['ingress_rule'], network=internal_tier)
    http_rule = self.create_NetworkAclRule(self.test_data['http_rule'], network=internal_tier)
    self.verify_vsd_firewall_rule(ssh_rule)
    self.verify_vsd_firewall_rule(http_rule)
    public_ip = self.acquire_PublicIPAddress(public_tier, vpc)
    self.validate_PublicIPAddress(public_ip, public_tier)
    self.create_StaticNatRule_For_VM(public_vm, public_ip, public_tier)
    self.validate_PublicIPAddress(public_ip, public_tier, static_nat=True, vm=public_vm)
    self.verify_vsd_floating_ip(public_tier, public_vm, public_ip.ipaddress, vpc)
    self.debug('Adding Network ACL rule to make the created NAT rule (SSH) accessible...')
    public_ssh_rule = self.create_NetworkAclRule(self.test_data['ingress_rule'], network=public_tier)
    self.verify_vsd_firewall_rule(public_ssh_rule)
    ssh_client = self.ssh_into_VM(public_vm, public_ip)
    self.validate_internallb_algorithm_traffic(ssh_client, int_lb_rule_1.sourceipaddress, self.test_data['http_rule']['publicport'], [internal_vm, internal_vm_1, internal_vm_2], 'roundrobin')
    ssh_client = self.ssh_into_VM(public_vm, public_ip)
    self.validate_internallb_algorithm_traffic(ssh_client, int_lb_rule_3.sourceipaddress, self.test_data['http_rule']['publicport'], [internal_vm, internal_vm_1, internal_vm_2], 'leastconn')
    ssh_client = self.ssh_into_VM(public_vm, public_ip)
    self.validate_internallb_algorithm_traffic(ssh_client, int_lb_rule_5.sourceipaddress, self.test_data['http_rule']['publicport'], [internal_vm, internal_vm_1, internal_vm_2], 'source')

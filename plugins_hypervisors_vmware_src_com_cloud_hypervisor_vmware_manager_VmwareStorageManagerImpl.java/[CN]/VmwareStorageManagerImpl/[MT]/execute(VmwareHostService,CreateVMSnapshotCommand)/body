{
  List<VolumeObjectTO> volumeTOs=cmd.getVolumeTOs();
  String vmName=cmd.getVmName();
  String vmSnapshotName=cmd.getTarget().getSnapshotName();
  String vmSnapshotDesc=cmd.getTarget().getDescription();
  boolean snapshotMemory=cmd.getTarget().getType() == VMSnapshot.Type.DiskAndMemory;
  boolean quiescevm=cmd.getTarget().getQuiescevm();
  VirtualMachineMO vmMo=null;
  VmwareContext context=hostService.getServiceContext(cmd);
  Map<String,String> mapNewDisk=new HashMap<String,String>();
  try {
    VmwareHypervisorHost hyperHost=hostService.getHyperHost(context,cmd);
    ManagedObjectReference taskmgr=context.getServiceContent().getTaskManager();
    List<ManagedObjectReference> tasks=(ArrayList<ManagedObjectReference>)context.getVimClient().getDynamicProperty(taskmgr,"recentTask");
    for (    ManagedObjectReference taskMor : tasks) {
      TaskInfo info=(TaskInfo)(context.getVimClient().getDynamicProperty(taskMor,"info"));
      if (info.getEntityName().equals(cmd.getVmName()) && info.getName().equalsIgnoreCase("CreateSnapshot_Task")) {
        s_logger.debug("There is already a VM snapshot task running, wait for it");
        context.getVimClient().waitForTask(taskMor);
      }
    }
    vmMo=hyperHost.findVmOnHyperHost(vmName);
    if (vmMo == null) {
      vmMo=hyperHost.findVmOnPeerHyperHost(vmName);
    }
    if (vmMo == null) {
      String msg="Unable to find VM for CreateVMSnapshotCommand";
      s_logger.debug(msg);
      return new CreateVMSnapshotAnswer(cmd,false,msg);
    }
 else {
      if (vmMo.getSnapshotMor(vmSnapshotName) != null) {
        s_logger.debug("VM snapshot " + vmSnapshotName + " already exists");
      }
 else       if (!vmMo.createSnapshot(vmSnapshotName,vmSnapshotDesc,snapshotMemory,quiescevm)) {
        return new CreateVMSnapshotAnswer(cmd,false,"Unable to create snapshot due to esxi internal failed");
      }
      VirtualDisk[] vdisks=vmMo.getAllDiskDevice();
      for (int i=0; i < vdisks.length; i++) {
        List<Pair<String,ManagedObjectReference>> vmdkFiles=vmMo.getDiskDatastorePathChain(vdisks[i],false);
        for (        Pair<String,ManagedObjectReference> fileItem : vmdkFiles) {
          String vmdkName=fileItem.first().split(" ")[1];
          if (vmdkName.endsWith(".vmdk")) {
            vmdkName=vmdkName.substring(0,vmdkName.length() - (".vmdk").length());
          }
          String baseName=extractSnapshotBaseFileName(vmdkName);
          mapNewDisk.put(baseName,vmdkName);
        }
      }
      for (      VolumeObjectTO volumeTO : volumeTOs) {
        String baseName=extractSnapshotBaseFileName(volumeTO.getPath());
        String newPath=mapNewDisk.get(baseName);
        DataStoreTO store=volumeTO.getDataStore();
        long size=getVMSnapshotChainSize(context,hyperHost,baseName + "*.vmdk",store.getUuid(),newPath);
        if (volumeTO.getVolumeType() == Volume.Type.ROOT) {
          size=size + getVMSnapshotChainSize(context,hyperHost,cmd.getVmName() + "*.vmsn",store.getUuid(),null);
        }
        volumeTO.setSize(size);
        volumeTO.setPath(newPath);
      }
      return new CreateVMSnapshotAnswer(cmd,cmd.getTarget(),volumeTOs);
    }
  }
 catch (  Exception e) {
    String msg=e.getMessage();
    s_logger.error("failed to create snapshot for vm:" + vmName + " due to "+ msg);
    try {
      if (vmMo.getSnapshotMor(vmSnapshotName) != null) {
        vmMo.removeSnapshot(vmSnapshotName,false);
      }
    }
 catch (    Exception e1) {
    }
    return new CreateVMSnapshotAnswer(cmd,false,e.getMessage());
  }
}

{
  String displayText=cmd.getDisplayText();
  Long id=cmd.getId();
  String name=cmd.getNetworkOfferingName();
  String availabilityStr=cmd.getAvailability();
  Integer sortKey=cmd.getSortKey();
  Availability availability=null;
  String state=cmd.getState();
  UserContext.current().setEventDetails(" Id: " + id);
  NetworkOfferingVO offeringToUpdate=_networkOfferingDao.findById(id);
  if (offeringToUpdate == null) {
    throw new InvalidParameterValueException("unable to find network offering " + id);
  }
  if (offeringToUpdate.isSystemOnly()) {
    throw new InvalidParameterValueException("Can't update system network offerings");
  }
  NetworkOfferingVO offering=_networkOfferingDao.createForUpdate(id);
  if (name != null) {
    offering.setName(name);
  }
  if (displayText != null) {
    offering.setDisplayText(displayText);
  }
  if (sortKey != null) {
    offering.setSortKey(sortKey);
  }
  if (state != null) {
    boolean validState=false;
    for (    NetworkOffering.State st : NetworkOffering.State.values()) {
      if (st.name().equalsIgnoreCase(state)) {
        validState=true;
        offering.setState(st);
      }
    }
    if (!validState) {
      throw new InvalidParameterValueException("Incorrect state value: " + state);
    }
  }
  if (availabilityStr != null) {
    for (    Availability avlb : Availability.values()) {
      if (avlb.name().equalsIgnoreCase(availabilityStr)) {
        availability=avlb;
      }
    }
    if (availability == null) {
      throw new InvalidParameterValueException("Invalid value for Availability. Supported types: " + Availability.Required + ", "+ Availability.Optional+ ", "+ Availability.Unavailable);
    }
 else {
      offering.setAvailability(availability);
    }
  }
  Long networks=_networkDao.getNetworkCountByOfferingId(id);
  boolean networksExist=(networks != null && networks.longValue() > 0);
  Map<Network.Service,Set<Network.Provider>> serviceProviderMap=new HashMap<Network.Service,Set<Network.Provider>>();
  Set<Network.Provider> defaultProviders=new HashSet<Network.Provider>();
  defaultProviders.add(Network.Provider.defaultProvider);
  if (cmd.getDhcpService()) {
    serviceProviderMap.put(Network.Service.Dhcp,defaultProviders);
  }
  if (cmd.getDnsService()) {
    serviceProviderMap.put(Network.Service.Dns,defaultProviders);
  }
  if (cmd.getFirewallService()) {
    serviceProviderMap.put(Network.Service.Firewall,defaultProviders);
  }
  if (cmd.getGatewayService()) {
    serviceProviderMap.put(Network.Service.Gateway,defaultProviders);
  }
  if (cmd.getLbService()) {
    serviceProviderMap.put(Network.Service.Lb,defaultProviders);
  }
  if (cmd.getSourceNatService()) {
    if (offering.getGuestType() == GuestType.Shared) {
      throw new InvalidParameterValueException("Source nat service is is not supported for network offerings with guest ip type " + GuestType.Shared);
    }
    serviceProviderMap.put(Network.Service.SourceNat,defaultProviders);
  }
  if (cmd.getStaticNatService()) {
    serviceProviderMap.put(Network.Service.StaticNat,defaultProviders);
  }
  if (cmd.getPortForwardingService()) {
    serviceProviderMap.put(Network.Service.PortForwarding,defaultProviders);
  }
  if (cmd.getUserdataService()) {
    serviceProviderMap.put(Network.Service.UserData,defaultProviders);
  }
  if (cmd.getVpnService()) {
    serviceProviderMap.put(Network.Service.Vpn,defaultProviders);
  }
  if (cmd.getSecurityGroupService()) {
    if (offering.getGuestType() != GuestType.Shared) {
      throw new InvalidParameterValueException("Secrity group service is supported for network offerings with guest ip type " + GuestType.Shared);
    }
    Set<Network.Provider> sgProviders=new HashSet<Network.Provider>();
    sgProviders.add(Provider.SecurityGroupProvider);
    serviceProviderMap.put(Network.Service.SecurityGroup,sgProviders);
  }
  Map<String,List<String>> svcPrv=cmd.getServiceProviders();
  if (svcPrv != null) {
    for (    String serviceStr : svcPrv.keySet()) {
      Network.Service service=Network.Service.getService(serviceStr);
      if (serviceProviderMap.containsKey(service)) {
        Set<Provider> providers=new HashSet<Provider>();
        for (        String prvNameStr : svcPrv.get(serviceStr)) {
          Network.Provider provider;
          provider=Network.Provider.getProvider(prvNameStr);
          if (provider == null) {
            throw new InvalidParameterValueException("Invalid service provider: " + prvNameStr);
          }
          providers.add(provider);
        }
        serviceProviderMap.put(service,providers);
      }
 else {
        throw new InvalidParameterValueException("Service " + serviceStr + " is not enabled for the network offering, can't add a provider to it");
      }
    }
  }
  Map<Capability,String> lbServiceCapabilityMap=cmd.getServiceCapabilities(Service.Lb);
  boolean dedicatedLb=true;
  if (!cmd.getLbService() && lbServiceCapabilityMap != null && !lbServiceCapabilityMap.isEmpty()) {
    throw new InvalidParameterValueException("Capabilities for LB service can be specifed only when LB service is enabled for network offering.");
  }
  validateLoadBalancerServiceCapabilities(lbServiceCapabilityMap);
  if ((lbServiceCapabilityMap != null) && (!lbServiceCapabilityMap.isEmpty())) {
    String isolationCapability=lbServiceCapabilityMap.get(Capability.SupportedLBIsolation);
    dedicatedLb=isolationCapability.contains("dedicated");
  }
  offering.setDedicatedLb(dedicatedLb);
  Map<Capability,String> sourceNatServiceCapabilityMap=cmd.getServiceCapabilities(Service.SourceNat);
  boolean sharedSourceNat=false;
  if (!cmd.getSourceNatService() && sourceNatServiceCapabilityMap != null && !sourceNatServiceCapabilityMap.isEmpty()) {
    throw new InvalidParameterValueException("Capabilities for Firewall service can be specifed only when Firewall service is enabled for network offering.");
  }
  validateSourceNatServiceCapablities(sourceNatServiceCapabilityMap);
  if ((sourceNatServiceCapabilityMap != null) && (!sourceNatServiceCapabilityMap.isEmpty())) {
    String sourceNatType=sourceNatServiceCapabilityMap.get(Capability.SupportedSourceNatTypes.getName());
    sharedSourceNat=sourceNatType.contains("perzone");
  }
  offering.setSharedSourceNat(sharedSourceNat);
  Map<Capability,String> gatewayServiceCapabilityMap=cmd.getServiceCapabilities(Service.Gateway);
  boolean redundantRouter=false;
  if (!cmd.getGatewayService() && gatewayServiceCapabilityMap != null && !gatewayServiceCapabilityMap.isEmpty()) {
    throw new InvalidParameterValueException("Capabilities for Gateway service can be specifed only when Gateway service is enabled for network offering.");
  }
  validateGatewayServiceCapablities(gatewayServiceCapabilityMap);
  if ((gatewayServiceCapabilityMap != null) && (!gatewayServiceCapabilityMap.isEmpty())) {
    String param=gatewayServiceCapabilityMap.get(Capability.RedundantRouter.getName());
    redundantRouter=param.contains("true");
  }
  offering.setRedundantRouter(redundantRouter);
  if (svcPrv != null && !svcPrv.isEmpty()) {
    if (networksExist) {
      throw new InvalidParameterValueException("Unable to reset service providers as there are existing networks using this network offering");
    }
  }
  boolean success=true;
  Transaction txn=Transaction.currentTxn();
  txn.start();
  success=success && _networkOfferingDao.update(id,offering);
  if (!serviceProviderMap.isEmpty()) {
    _ntwkOffServiceMapDao.deleteByOfferingId(id);
    for (    Network.Service service : serviceProviderMap.keySet()) {
      for (      Network.Provider provider : serviceProviderMap.get(service)) {
        NetworkOfferingServiceMapVO offService=new NetworkOfferingServiceMapVO(offering.getId(),service,provider);
        _ntwkOffServiceMapDao.persist(offService);
        s_logger.trace("Added service for the network offering: " + offService);
      }
    }
  }
  txn.commit();
  if (success) {
    return _networkOfferingDao.findById(id);
  }
 else {
    return null;
  }
}

{
  Transaction txn=Transaction.currentTxn();
  txn.start();
  IPAddressVO ip=null;
  NicIpAliasVO ipAlias=null;
  try {
    Integer allocIpCount=0;
    allocIpCount=_publicIpAddressDao.countIPs(vlanRange.getDataCenterId(),vlanDbId,true);
    if (allocIpCount > 1) {
      throw new InvalidParameterValueException("Cannot delete this range as some of the vlans are in use.");
    }
 else     if (allocIpCount == 0) {
      deleteVLANFromDb(vlanDbId);
    }
 else {
      ipAlias=_nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(),vlanRange.getNetworkId(),NicIpAlias.state.active);
      if (ipAlias == null) {
        throw new InvalidParameterValueException("Cannot delete this range as some of the Ips are in use.");
      }
      ip=_publicIpAddressDao.findByIpAndVlanId(ipAlias.getIp4Address(),vlanDbId);
      if (ip != null && ip.getState() == IpAddress.State.Allocated) {
        List<VlanVO> vlanRanges=_vlanDao.listVlansByNetworkIdAndGateway(vlanRange.getNetworkId(),vlanRange.getVlanGateway());
        if (vlanRanges.size() == 1) {
          ipAlias.setState(NicIpAlias.state.revoked);
          _nicIpAliasDao.update(ipAlias.getId(),ipAlias);
          if (!dhcpServiceProvider.removeDhcpSupportForSubnet(network)) {
            s_logger.debug("Failed to delete the vlan range as we could not free the ip used to provide the dhcp service.");
            ipAlias.setState(NicIpAlias.state.active);
            _nicIpAliasDao.update(ipAlias.getId(),ipAlias);
          }
 else {
            _publicIpAddressDao.unassignIpAddress(ip.getId());
            deleteVLANFromDb(vlanDbId);
          }
        }
 else {
          s_logger.info("vlan Range" + vlanRange.getId() + " id being deleted, one of the Ips in this range is used to provide the dhcp service, will free the rest of the IPs in range.");
          _publicIpAddressDao.deletePublicIPRangeExceptAliasIP(vlanDbId,ipAlias.getIp4Address());
          VlanVO vlan=_vlanDao.findById(vlanDbId);
          vlan.setIpRange(ipAlias.getIp4Address() + "-" + ipAlias.getIp4Address());
          _vlanDao.update(vlan.getId(),vlan);
        }
      }
    }
  }
 catch (  CloudRuntimeException e) {
    txn.rollback();
    throw e;
  }
  txn.commit();
  return true;
}

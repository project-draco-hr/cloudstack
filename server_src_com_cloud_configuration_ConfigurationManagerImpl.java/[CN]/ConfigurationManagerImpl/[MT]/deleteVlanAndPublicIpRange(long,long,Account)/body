{
  VlanVO vlanRange=_vlanDao.findById(vlanDbId);
  if (vlanRange == null) {
    throw new InvalidParameterValueException("Please specify a valid IP range id.");
  }
  boolean isAccountSpecific=false;
  List<AccountVlanMapVO> acctVln=_accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());
  if (acctVln != null && !acctVln.isEmpty()) {
    isAccountSpecific=true;
  }
  long allocIpCount=_publicIpAddressDao.countIPs(vlanRange.getDataCenterId(),vlanDbId,true);
  List<IPAddressVO> ips=_publicIpAddressDao.listByVlanId(vlanDbId);
  boolean success=true;
  if (allocIpCount > 0) {
    if (isAccountSpecific) {
      try {
        vlanRange=_vlanDao.acquireInLockTable(vlanDbId,30);
        if (vlanRange == null) {
          throw new CloudRuntimeException("Unable to acquire vlan configuration: " + vlanDbId);
        }
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("lock vlan " + vlanDbId + " is acquired");
        }
        for (        IPAddressVO ip : ips) {
          if (ip.isOneToOneNat()) {
            throw new InvalidParameterValueException("Can't delete account specific vlan " + vlanDbId + " as ip "+ ip+ " belonging to the range is used for static nat purposes. Cleanup the rules first");
          }
          if (ip.isSourceNat()) {
            throw new InvalidParameterValueException("Can't delete account specific vlan " + vlanDbId + " as ip "+ ip+ " belonging to the range is a source nat ip for the network id="+ ip.getSourceNetworkId()+ ". IP range with the source nat ip address can be removed either as a part of Network, or account removal");
          }
          if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {
            throw new InvalidParameterValueException("Can't delete account specific vlan " + vlanDbId + " as ip "+ ip+ " belonging to the range has firewall rules applied. Cleanup the rules first");
          }
          success=success && _networkMgr.disassociatePublicIpAddress(ip.getId(),userId,caller);
        }
        if (!success) {
          s_logger.warn("Some ip addresses failed to be released as a part of vlan " + vlanDbId + " removal");
        }
      }
  finally {
        _vlanDao.releaseFromLockTable(vlanDbId);
      }
    }
  }
  if (success) {
    if (isAccountSpecific) {
      for (      IPAddressVO ip : ips) {
        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE,acctVln.get(0).getId(),ip.getDataCenterId(),ip.getId(),ip.getAddress().toString(),ip.isSourceNat(),vlanRange.getVlanType().toString(),ip.getSystem(),ip.getClass().getName(),ip.getUuid());
      }
    }
    if (_networkModel.areServicesSupportedInNetwork(vlanRange.getNetworkId(),Service.Dhcp)) {
      Network network=_networkDao.findById(vlanRange.getNetworkId());
      DhcpServiceProvider dhcpServiceProvider=_networkMgr.getDhcpServiceProvider(network);
      if (!dhcpServiceProvider.getProvider().getName().equalsIgnoreCase(Provider.VirtualRouter.getName())) {
        if (!deletePublicIPRange(vlanDbId)) {
          return false;
        }
        _vlanDao.expunge(vlanDbId);
        return true;
      }
      boolean aliasIpBelongsToThisVlan=false;
      long freeIpsInsubnet=0;
      NicIpAliasVO ipAlias=null;
      allocIpCount=_publicIpAddressDao.countIPs(vlanRange.getDataCenterId(),vlanDbId,true);
      if (allocIpCount > 1) {
        throw new InvalidParameterValueException("cannot delete this range as some of the vlans are in use.");
      }
      if (allocIpCount == 0) {
        if (!deletePublicIPRange(vlanDbId)) {
          return false;
        }
        _vlanDao.expunge(vlanDbId);
        return true;
      }
      ipAlias=_nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(),vlanRange.getNetworkId(),NicIpAlias.state.active);
      IPAddressVO ip=_publicIpAddressDao.findByIpAndVlanId(ipAlias.getIp4Address(),vlanDbId);
      if (ip != null && ip.getState() == IpAddress.State.Allocated) {
        aliasIpBelongsToThisVlan=true;
        List<VlanVO> vlanRanges=_vlanDao.listVlansByNetworkIdAndGateway(vlanRange.getNetworkId(),vlanRange.getVlanGateway());
        if (vlanRanges.size() == 1) {
          boolean result=dhcpServiceProvider.removeDhcpSupportForSubnet(network);
          if (result == false) {
            s_logger.debug("Failed to delete the vlan range as we could not free the ip used to provide the dhcp service.");
          }
 else {
            _publicIpAddressDao.unassignIpAddress(ip.getId());
            if (!deletePublicIPRange(vlanDbId)) {
              return false;
            }
            _vlanDao.expunge(vlanDbId);
            _nicIpAliasDao.expunge(ipAlias.getId());
          }
        }
 else {
          List<Long> vlanDbIdList=new ArrayList<Long>();
          for (          VlanVO vlanrange : vlanRanges) {
            if (vlanrange.getId() != vlanDbId) {
              vlanDbIdList.add(vlanrange.getId());
            }
          }
          s_logger.info("vlan Range" + vlanRange.getId() + " id being deleted, one of the Ips in this range is used to provide the dhcp service, trying to free this ip and allocate a new one.");
          for (          VlanVO vlanrange : vlanRanges) {
            if (vlanrange.getId() != vlanDbId) {
              freeIpsInsubnet=_publicIpAddressDao.countFreeIpsInVlan(vlanrange.getId());
              if (freeIpsInsubnet > 0) {
                Transaction txn=Transaction.currentTxn();
                ipAlias.setState(NicIpAlias.state.revoked);
                _nicIpAliasDao.update(ipAlias.getId(),ipAlias);
                boolean result=false;
                try {
                  PublicIp routerPublicIP=_networkMgr.assignPublicIpAddressFromVlans(network.getDataCenterId(),null,caller,Vlan.VlanType.DirectAttached,vlanDbIdList,network.getId(),null,false);
                  s_logger.info("creating a db entry for the new ip alias.");
                  NicIpAliasVO newipAlias=new NicIpAliasVO(ipAlias.getNicId(),routerPublicIP.getAddress().addr(),ipAlias.getVmId(),ipAlias.getAccountId(),network.getDomainId(),network.getId(),ipAlias.getGateway(),ipAlias.getNetmask());
                  newipAlias.setAliasCount(routerPublicIP.getIpMacAddress());
                  _nicIpAliasDao.persist(newipAlias);
                }
 catch (                InsufficientAddressCapacityException e) {
                  txn.rollback();
                  txn.close();
                  throw new InvalidParameterValueException("cannot delete  vlan range" + vlanRange.getId() + "one of the ips in this range is benig used to provide dhcp service. Cannot use some other ip as there are no free ips in this subnet");
                }
                s_logger.info("removing the old ip alias on router");
                result=dhcpServiceProvider.removeDhcpSupportForSubnet(network);
                if (result == false) {
                  s_logger.debug("could't delete the ip alias on the router");
                  txn.rollback();
                  txn.close();
                  return false;
                }
                _publicIpAddressDao.unassignIpAddress(ip.getId());
                if (!deletePublicIPRange(vlanDbId)) {
                  return false;
                }
                _vlanDao.expunge(vlanDbId);
                txn.commit();
                txn.close();
              }
            }
          }
        }
      }
    }
 else {
      if (!deletePublicIPRange(vlanDbId)) {
        return false;
      }
      _vlanDao.expunge(vlanDbId);
      return true;
    }
  }
  return false;
}

{
  VlanVO vlanRange=_vlanDao.findById(vlanDbId);
  if (vlanRange == null) {
    throw new InvalidParameterValueException("Please specify a valid IP range id.");
  }
  boolean isAccountSpecific=false;
  List<AccountVlanMapVO> acctVln=_accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());
  if (acctVln != null && !acctVln.isEmpty()) {
    isAccountSpecific=true;
  }
  long allocIpCount=_publicIpAddressDao.countIPs(vlanRange.getDataCenterId(),vlanDbId,true);
  List<IPAddressVO> ips=_publicIpAddressDao.listByVlanId(vlanDbId);
  boolean success=true;
  if (allocIpCount > 0) {
    if (isAccountSpecific) {
      try {
        vlanRange=_vlanDao.acquireInLockTable(vlanDbId,30);
        if (vlanRange == null) {
          throw new CloudRuntimeException("Unable to acquire vlan configuration: " + vlanDbId);
        }
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("lock vlan " + vlanDbId + " is acquired");
        }
        for (        IPAddressVO ip : ips) {
          if (ip.isOneToOneNat()) {
            throw new InvalidParameterValueException("Can't delete account specific vlan " + vlanDbId + " as ip "+ ip+ " belonging to the range is used for static nat purposes. Cleanup the rules first");
          }
          if (ip.isSourceNat()) {
            throw new InvalidParameterValueException("Can't delete account specific vlan " + vlanDbId + " as ip "+ ip+ " belonging to the range is a source nat ip for the network id="+ ip.getSourceNetworkId()+ ". IP range with the source nat ip address can be removed either as a part of Network, or account removal");
          }
          if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {
            throw new InvalidParameterValueException("Can't delete account specific vlan " + vlanDbId + " as ip "+ ip+ " belonging to the range has firewall rules applied. Cleanup the rules first");
          }
          success=success && _networkMgr.disassociatePublicIpAddress(ip.getId(),userId,caller);
        }
        if (!success) {
          s_logger.warn("Some ip addresses failed to be released as a part of vlan " + vlanDbId + " removal");
        }
      }
  finally {
        _vlanDao.releaseFromLockTable(vlanDbId);
      }
    }
  }
  if (success) {
    if (isAccountSpecific) {
      for (      IPAddressVO ip : ips) {
        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE,acctVln.get(0).getId(),ip.getDataCenterId(),ip.getId(),ip.getAddress().toString(),ip.isSourceNat(),vlanRange.getVlanType().toString(),ip.getSystem(),ip.getClass().getName(),ip.getUuid());
      }
    }
    if (_networkModel.areServicesSupportedInNetwork(vlanRange.getNetworkId(),Service.Dhcp)) {
      Network network=_networkDao.findById(vlanRange.getNetworkId());
      DhcpServiceProvider dhcpServiceProvider=_networkMgr.getDhcpServiceProvider(network);
      if (!dhcpServiceProvider.getProvider().getName().equalsIgnoreCase(Provider.VirtualRouter.getName())) {
        Transaction txn=Transaction.currentTxn();
        txn.start();
        if (!removeFromDb(vlanDbId)) {
          txn.rollback();
          return false;
        }
 else {
          txn.commit();
        }
        txn.close();
      }
 else {
        return handleIpAliasDeletion(vlanRange,vlanDbId,dhcpServiceProvider,network);
      }
    }
  }
  return true;
}

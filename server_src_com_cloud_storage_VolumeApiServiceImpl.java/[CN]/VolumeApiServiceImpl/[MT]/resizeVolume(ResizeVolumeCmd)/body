{
  Long newSize=null;
  boolean shrinkOk=cmd.getShrinkOk();
  VolumeVO volume=_volsDao.findById(cmd.getEntityId());
  if (volume == null) {
    throw new InvalidParameterValueException("No such volume");
  }
  DiskOfferingVO diskOffering=_diskOfferingDao.findById(volume.getDiskOfferingId());
  DiskOfferingVO newDiskOffering=null;
  newDiskOffering=_diskOfferingDao.findById(cmd.getNewDiskOfferingId());
  if (_volsDao.getHypervisorType(volume.getId()) != HypervisorType.KVM && _volsDao.getHypervisorType(volume.getId()) != HypervisorType.XenServer && _volsDao.getHypervisorType(volume.getId()) != HypervisorType.VMware && _volsDao.getHypervisorType(volume.getId()) != HypervisorType.None) {
    throw new InvalidParameterValueException("Cloudstack currently only supports volumes marked as KVM, VMware, XenServer hypervisor for resize");
  }
  if (volume.getState() != Volume.State.Ready && volume.getState() != Volume.State.Allocated) {
    throw new InvalidParameterValueException("Volume should be in ready or allocated state before attempting a resize. " + "Volume " + volume.getUuid() + " state is:"+ volume.getState());
  }
  if (newDiskOffering == null) {
    if (diskOffering.isCustomized() || volume.getVolumeType().equals(Volume.Type.ROOT)) {
      newSize=cmd.getSize();
      if (newSize == null) {
        throw new InvalidParameterValueException("new offering is of custom size, need to specify a size");
      }
      newSize=(newSize << 30);
    }
 else {
      throw new InvalidParameterValueException("current offering" + volume.getDiskOfferingId() + " cannot be resized, need to specify a disk offering");
    }
  }
 else {
    if (!volume.getVolumeType().equals(Volume.Type.DATADISK)) {
      throw new InvalidParameterValueException("Can only resize Data volumes via new disk offering");
    }
    if (newDiskOffering.getRemoved() != null || !DiskOfferingVO.Type.Disk.equals(newDiskOffering.getType())) {
      throw new InvalidParameterValueException("Disk offering ID is missing or invalid");
    }
    if (diskOffering.getTags() != null) {
      if (newDiskOffering.getTags() == null || !newDiskOffering.getTags().equals(diskOffering.getTags())) {
        throw new InvalidParameterValueException("Tags on new and old disk offerings must match");
      }
    }
 else     if (newDiskOffering.getTags() != null) {
      throw new InvalidParameterValueException("There are no tags on current disk offering, new disk offering needs to have no tags");
    }
    if (newDiskOffering.getDomainId() == null) {
    }
 else {
      _configMgr.checkDiskOfferingAccess(CallContext.current().getCallingAccount(),newDiskOffering);
    }
    if (newDiskOffering.isCustomized()) {
      newSize=cmd.getSize();
      if (newSize == null) {
        throw new InvalidParameterValueException("new offering is of custom size, need to specify a size");
      }
      newSize=(newSize << 30);
    }
 else {
      newSize=newDiskOffering.getDiskSize();
    }
  }
  if (newSize == null) {
    throw new InvalidParameterValueException("could not detect a size parameter or fetch one from the diskofferingid parameter");
  }
  if (!validateVolumeSizeRange(newSize)) {
    throw new InvalidParameterValueException("Requested size out of range");
  }
  _accountMgr.checkAccess(CallContext.current().getCallingAccount(),null,volume);
  long currentSize=volume.getSize();
  if (currentSize > newSize && !shrinkOk) {
    throw new InvalidParameterValueException("Going from existing size of " + currentSize + " to size of "+ newSize+ " would shrink the volume, need to sign off by supplying the shrinkok parameter with value of true");
  }
  if (!shrinkOk) {
    _resourceLimitMgr.checkResourceLimit(_accountMgr.getAccount(volume.getAccountId()),ResourceType.primary_storage,volume.isDisplayVolume(),new Long(newSize - currentSize));
  }
  if (volume.getState() == Volume.State.Allocated) {
    s_logger.debug("Volume is allocated, but never created, simply updating database with new size");
    volume.setSize(newSize);
    if (newDiskOffering != null) {
      volume.setDiskOfferingId(cmd.getNewDiskOfferingId());
    }
    _volsDao.update(volume.getId(),volume);
    return volume;
  }
  UserVmVO userVm=_userVmDao.findById(volume.getInstanceId());
  if (userVm != null) {
    AsyncJobExecutionContext jobContext=AsyncJobExecutionContext.getCurrentExecutionContext();
    if (!VmJobEnabled.value() || jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {
      VmWorkJobVO placeHolder=null;
      if (VmJobEnabled.value()) {
        placeHolder=createPlaceHolderWork(userVm.getId());
      }
      try {
        return orchestrateResizeVolume(volume.getId(),currentSize,newSize,newDiskOffering != null ? cmd.getNewDiskOfferingId() : null,shrinkOk);
      }
  finally {
        if (VmJobEnabled.value())         _workJobDao.expunge(placeHolder.getId());
      }
    }
 else {
      Outcome<Volume> outcome=resizeVolumeThroughJobQueue(userVm.getId(),volume.getId(),currentSize,newSize,newDiskOffering != null ? cmd.getNewDiskOfferingId() : null,shrinkOk);
      Volume vol=null;
      try {
        outcome.get();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Operation is interrupted",e);
      }
catch (      java.util.concurrent.ExecutionException e) {
        throw new RuntimeException("Execution excetion",e);
      }
      Object jobResult=_jobMgr.unmarshallResultObject(outcome.getJob());
      if (jobResult != null) {
        if (jobResult instanceof ConcurrentOperationException)         throw (ConcurrentOperationException)jobResult;
 else         if (jobResult instanceof Throwable)         throw new RuntimeException("Unexpected exception",(Throwable)jobResult);
 else         if (jobResult instanceof Long) {
          vol=_volsDao.findById((Long)jobResult);
        }
      }
      return volume;
    }
  }
  return orchestrateResizeVolume(volume.getId(),currentSize,newSize,newDiskOffering != null ? cmd.getNewDiskOfferingId() : null,shrinkOk);
}

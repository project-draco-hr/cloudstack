{
  final CallContext context=CallContext.current();
  final User callingUser=context.getCallingUser();
  final Account callingAccount=context.getCallingAccount();
  final VMInstanceVO vm=_vmInstanceDao.findById(vmId);
  Object[] result=Transaction.execute(new TransactionCallback<Object[]>(){
    @Override public Object[] doInTransaction(    TransactionStatus status){
      VmWorkJobVO workJob=null;
      _vmInstanceDao.lockInLockTable(String.valueOf(vm.getId()),Integer.MAX_VALUE);
      try {
        workJob=new VmWorkJobVO(context.getContextId());
        workJob.setDispatcher(VmWorkConstants.VM_WORK_JOB_DISPATCHER);
        workJob.setCmd(VmWorkResizeVolume.class.getName());
        workJob.setAccountId(callingAccount.getId());
        workJob.setUserId(callingUser.getId());
        workJob.setStep(VmWorkJobVO.Step.Starting);
        workJob.setVmType(VirtualMachine.Type.Instance);
        workJob.setVmInstanceId(vm.getId());
        workJob.setRelated(AsyncJobExecutionContext.getOriginJobId());
        VmWorkResizeVolume workInfo=new VmWorkResizeVolume(callingUser.getId(),callingAccount.getId(),vm.getId(),VolumeApiServiceImpl.VM_WORK_JOB_HANDLER,volumeId,currentSize,newSize,newMinIops,newMaxIops,newServiceOfferingId,shrinkOk);
        workJob.setCmdInfo(VmWorkSerializer.serialize(workInfo));
        _jobMgr.submitAsyncJob(workJob,VmWorkConstants.VM_WORK_QUEUE,vm.getId());
        return new Object[]{workJob,new Long(workJob.getId())};
      }
  finally {
        _vmInstanceDao.unlockFromLockTable(String.valueOf(vm.getId()));
      }
    }
  }
);
  final long jobId=(Long)result[1];
  AsyncJobExecutionContext.getCurrentExecutionContext().joinJob(jobId);
  return new VmJobVolumeOutcome((VmWorkJobVO)result[0],volumeId);
}

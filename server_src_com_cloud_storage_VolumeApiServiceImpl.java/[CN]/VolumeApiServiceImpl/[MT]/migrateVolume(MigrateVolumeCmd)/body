{
  Long volumeId=cmd.getVolumeId();
  Long storagePoolId=cmd.getStoragePoolId();
  VolumeVO vol=_volsDao.findById(volumeId);
  if (vol == null) {
    throw new InvalidParameterValueException("Failed to find the volume id: " + volumeId);
  }
  if (vol.getState() != Volume.State.Ready) {
    throw new InvalidParameterValueException("Volume must be in ready state");
  }
  boolean liveMigrateVolume=false;
  Long instanceId=vol.getInstanceId();
  VMInstanceVO vm=null;
  if (instanceId != null) {
    vm=_vmInstanceDao.findById(instanceId);
  }
  if (vm != null && vm.getState() == State.Running) {
    if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(),GPU.Keys.pciDevice.toString()) != null) {
      throw new InvalidParameterValueException("Live Migration of GPU enabled VM is not supported");
    }
    Long hostId=vm.getHostId();
    if (hostId != null) {
      HostVO host=_hostDao.findById(hostId);
      HypervisorCapabilitiesVO capabilities=null;
      if (host != null) {
        capabilities=_hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(host.getHypervisorType(),host.getHypervisorVersion());
      }
      if (capabilities != null) {
        liveMigrateVolume=capabilities.isStorageMotionSupported();
      }
    }
    if (!liveMigrateVolume) {
      throw new InvalidParameterValueException("Volume needs to be detached from VM");
    }
  }
  if (liveMigrateVolume && !cmd.isLiveMigrate()) {
    throw new InvalidParameterValueException("The volume " + vol + "is attached to a vm and for migrating it "+ "the parameter livemigrate should be specified");
  }
  StoragePool destPool=(StoragePool)dataStoreMgr.getDataStore(storagePoolId,DataStoreRole.Primary);
  if (destPool == null) {
    throw new InvalidParameterValueException("Failed to find the destination storage pool: " + storagePoolId);
  }
  if (_volumeMgr.volumeOnSharedStoragePool(vol)) {
    if (destPool.isLocal()) {
      throw new InvalidParameterValueException("Migration of volume from shared to local storage pool is not supported");
    }
  }
 else {
    throw new InvalidParameterValueException("Migration of volume from local storage pool is not supported");
  }
  if (vm != null) {
    AsyncJobExecutionContext jobContext=AsyncJobExecutionContext.getCurrentExecutionContext();
    if (!VmJobEnabled.value() || jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {
      VmWorkJobVO placeHolder=null;
      if (VmJobEnabled.value()) {
        placeHolder=createPlaceHolderWork(vm.getId());
      }
      try {
        return orchestrateMigrateVolume(vol.getId(),destPool.getId(),liveMigrateVolume);
      }
  finally {
        if (VmJobEnabled.value())         _workJobDao.expunge(placeHolder.getId());
      }
    }
 else {
      Outcome<Volume> outcome=migrateVolumeThroughJobQueue(vm.getId(),vol.getId(),destPool.getId(),liveMigrateVolume);
      try {
        outcome.get();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Operation is interrupted",e);
      }
catch (      java.util.concurrent.ExecutionException e) {
        throw new RuntimeException("Execution excetion",e);
      }
      Object jobResult=_jobMgr.unmarshallResultObject(outcome.getJob());
      if (jobResult != null) {
        if (jobResult instanceof ConcurrentOperationException)         throw (ConcurrentOperationException)jobResult;
 else         if (jobResult instanceof Throwable)         throw new RuntimeException("Unexpected exception",(Throwable)jobResult);
      }
      if (jobResult != null && jobResult instanceof Long) {
        return _entityMgr.findById(VolumeVO.class,((Long)jobResult));
      }
      return null;
    }
  }
  return orchestrateMigrateVolume(vol.getId(),destPool.getId(),liveMigrateVolume);
}

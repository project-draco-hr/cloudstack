{
  boolean success=true;
  final Network network=_networksDao.findById(networkId);
  final List<PortForwardingRuleVO> pfRules=_portForwardingRulesDao.listByNetwork(networkId);
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Releasing " + pfRules.size() + " port forwarding rules for network id="+ networkId+ " as a part of shutdownNetworkRules");
  }
  for (  final PortForwardingRuleVO pfRule : pfRules) {
    s_logger.trace("Marking pf rule " + pfRule + " with Revoke state");
    pfRule.setState(FirewallRule.State.Revoke);
  }
  try {
    if (!_firewallMgr.applyRules(pfRules,true,false)) {
      s_logger.warn("Failed to cleanup pf rules as a part of shutdownNetworkRules");
      success=false;
    }
  }
 catch (  final ResourceUnavailableException ex) {
    s_logger.warn("Failed to cleanup pf rules as a part of shutdownNetworkRules due to ",ex);
    success=false;
  }
  final List<FirewallRuleVO> firewallStaticNatRules=_firewallDao.listByNetworkAndPurpose(networkId,Purpose.StaticNat);
  final List<StaticNatRule> staticNatRules=new ArrayList<StaticNatRule>();
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Releasing " + firewallStaticNatRules.size() + " static nat rules for network id="+ networkId+ " as a part of shutdownNetworkRules");
  }
  for (  final FirewallRuleVO firewallStaticNatRule : firewallStaticNatRules) {
    s_logger.trace("Marking static nat rule " + firewallStaticNatRule + " with Revoke state");
    final IpAddress ip=_ipAddressDao.findById(firewallStaticNatRule.getSourceIpAddressId());
    final FirewallRuleVO ruleVO=_firewallDao.findById(firewallStaticNatRule.getId());
    if (ip == null || !ip.isOneToOneNat() || ip.getAssociatedWithVmId() == null) {
      throw new InvalidParameterValueException("Source ip address of the rule id=" + firewallStaticNatRule.getId() + " is not static nat enabled");
    }
    ruleVO.setState(FirewallRule.State.Revoke);
    staticNatRules.add(new StaticNatRuleImpl(ruleVO,ip.getVmIp()));
  }
  try {
    if (!_firewallMgr.applyRules(staticNatRules,true,false)) {
      s_logger.warn("Failed to cleanup static nat rules as a part of shutdownNetworkRules");
      success=false;
    }
  }
 catch (  final ResourceUnavailableException ex) {
    s_logger.warn("Failed to cleanup static nat rules as a part of shutdownNetworkRules due to ",ex);
    success=false;
  }
  try {
    if (!_lbMgr.revokeLoadBalancersForNetwork(networkId,Scheme.Public)) {
      s_logger.warn("Failed to cleanup public lb rules as a part of shutdownNetworkRules");
      success=false;
    }
  }
 catch (  final ResourceUnavailableException ex) {
    s_logger.warn("Failed to cleanup public lb rules as a part of shutdownNetworkRules due to ",ex);
    success=false;
  }
  try {
    if (!_lbMgr.revokeLoadBalancersForNetwork(networkId,Scheme.Internal)) {
      s_logger.warn("Failed to cleanup internal lb rules as a part of shutdownNetworkRules");
      success=false;
    }
  }
 catch (  final ResourceUnavailableException ex) {
    s_logger.warn("Failed to cleanup public lb rules as a part of shutdownNetworkRules due to ",ex);
    success=false;
  }
  final List<FirewallRuleVO> firewallRules=_firewallDao.listByNetworkPurposeTrafficType(networkId,Purpose.Firewall,FirewallRule.TrafficType.Ingress);
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Releasing " + firewallRules.size() + " firewall ingress rules for network id="+ networkId+ " as a part of shutdownNetworkRules");
  }
  for (  final FirewallRuleVO firewallRule : firewallRules) {
    s_logger.trace("Marking firewall ingress rule " + firewallRule + " with Revoke state");
    firewallRule.setState(FirewallRule.State.Revoke);
  }
  try {
    if (!_firewallMgr.applyRules(firewallRules,true,false)) {
      s_logger.warn("Failed to cleanup firewall ingress rules as a part of shutdownNetworkRules");
      success=false;
    }
  }
 catch (  final ResourceUnavailableException ex) {
    s_logger.warn("Failed to cleanup firewall ingress rules as a part of shutdownNetworkRules due to ",ex);
    success=false;
  }
  final List<FirewallRuleVO> firewallEgressRules=_firewallDao.listByNetworkPurposeTrafficType(networkId,Purpose.Firewall,FirewallRule.TrafficType.Egress);
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Releasing " + firewallEgressRules.size() + " firewall egress rules for network id="+ networkId+ " as a part of shutdownNetworkRules");
  }
  try {
    final DataCenter zone=_dcDao.findById(network.getDataCenterId());
    if (_networkModel.areServicesSupportedInNetwork(network.getId(),Service.Firewall) && (network.getGuestType() == Network.GuestType.Isolated || network.getGuestType() == Network.GuestType.Shared && zone.getNetworkType() == NetworkType.Advanced)) {
      _firewallMgr.applyDefaultEgressFirewallRule(network.getId(),_networkModel.getNetworkEgressDefaultPolicy(networkId),false);
    }
  }
 catch (  final ResourceUnavailableException ex) {
    s_logger.warn("Failed to cleanup firewall default egress rule as a part of shutdownNetworkRules due to ",ex);
    success=false;
  }
  for (  final FirewallRuleVO firewallRule : firewallEgressRules) {
    s_logger.trace("Marking firewall egress rule " + firewallRule + " with Revoke state");
    firewallRule.setState(FirewallRule.State.Revoke);
  }
  try {
    if (!_firewallMgr.applyRules(firewallEgressRules,true,false)) {
      s_logger.warn("Failed to cleanup firewall egress rules as a part of shutdownNetworkRules");
      success=false;
    }
  }
 catch (  final ResourceUnavailableException ex) {
    s_logger.warn("Failed to cleanup firewall egress rules as a part of shutdownNetworkRules due to ",ex);
    success=false;
  }
  if (network.getVpcId() != null) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Releasing Network ACL Items for network id=" + networkId + " as a part of shutdownNetworkRules");
    }
    try {
      if (!_networkACLMgr.revokeACLItemsForNetwork(networkId)) {
        s_logger.warn("Failed to cleanup network ACLs as a part of shutdownNetworkRules");
        success=false;
      }
    }
 catch (    final ResourceUnavailableException ex) {
      s_logger.warn("Failed to cleanup network ACLs as a part of shutdownNetworkRules due to ",ex);
      success=false;
    }
  }
  if (!_rulesMgr.applyStaticNatForNetwork(networkId,false,caller,true)) {
    s_logger.warn("Failed to disable static nats as part of shutdownNetworkRules for network id " + networkId);
    success=false;
  }
  final List<IPAddressVO> userIps=_ipAddressDao.listByAssociatedNetwork(networkId,null);
  final List<PublicIp> publicIpsToRelease=new ArrayList<PublicIp>();
  if (userIps != null && !userIps.isEmpty()) {
    for (    final IPAddressVO userIp : userIps) {
      userIp.setState(IpAddress.State.Releasing);
      final PublicIp publicIp=PublicIp.createFromAddrAndVlan(userIp,_vlanDao.findById(userIp.getVlanId()));
      publicIpsToRelease.add(publicIp);
    }
  }
  try {
    if (!_ipAddrMgr.applyIpAssociations(network,true,true,publicIpsToRelease)) {
      s_logger.warn("Unable to apply ip address associations for " + network + " as a part of shutdownNetworkRules");
      success=false;
    }
  }
 catch (  final ResourceUnavailableException e) {
    throw new CloudRuntimeException("We should never get to here because we used true when applyIpAssociations",e);
  }
  return success;
}

{
  _accountMgr.getActiveUser(CallContext.current().getCallingUserId());
  final HostVO host=_hostDao.findById(hostId);
  if (host == null) {
    throw new InvalidParameterValueException("Host with id " + hostId + " doesn't exist");
  }
  _accountMgr.checkAccessAndSpecifyAuthority(CallContext.current().getCallingAccount(),host.getDataCenterId());
  if (!isForced && host.getResourceState() != ResourceState.Maintenance) {
    throw new CloudRuntimeException("Host " + host.getUuid() + " cannot be deleted as it is not in maintenance mode. Either put the host into maintenance or perform a forced deletion.");
  }
  final List<StoragePoolHostVO> pools=_storagePoolHostDao.listByHostIdIncludingRemoved(hostId);
  final ResourceStateAdapter.DeleteHostAnswer answer=(ResourceStateAdapter.DeleteHostAnswer)dispatchToStateAdapters(ResourceStateAdapter.Event.DELETE_HOST,false,host,isForced,isForceDeleteStorage);
  if (answer == null) {
    throw new CloudRuntimeException("No resource adapter respond to DELETE_HOST event for " + host.getName() + " id = "+ hostId+ ", hypervisorType is "+ host.getHypervisorType()+ ", host type is "+ host.getType());
  }
  if (answer.getIsException()) {
    return false;
  }
  if (!answer.getIsContinue()) {
    return true;
  }
  long clusterId=host.getClusterId();
  _agentMgr.notifyMonitorsOfHostAboutToBeRemoved(host.getId());
  Transaction.execute(new TransactionCallbackNoReturn(){
    @Override public void doInTransactionWithoutResult(    final TransactionStatus status){
      _dcDao.releasePrivateIpAddress(host.getPrivateIpAddress(),host.getDataCenterId(),null);
      _agentMgr.disconnectWithoutInvestigation(hostId,Status.Event.Remove);
      _hostDetailsDao.deleteDetails(hostId);
      _hostGpuGroupsDao.deleteGpuEntries(hostId);
      _hostTagsDao.deleteTags(hostId);
      host.setGuid(null);
      final Long clusterId=host.getClusterId();
      host.setClusterId(null);
      _hostDao.update(host.getId(),host);
      _hostDao.remove(hostId);
      if (clusterId != null) {
        final List<HostVO> hosts=listAllHostsInCluster(clusterId);
        if (hosts.size() == 0) {
          final ClusterVO cluster=_clusterDao.findById(clusterId);
          cluster.setGuid(null);
          _clusterDao.update(clusterId,cluster);
        }
      }
      try {
        resourceStateTransitTo(host,ResourceState.Event.DeleteHost,_nodeId);
      }
 catch (      final NoTransitionException e) {
        s_logger.debug("Cannot transmit host " + host.getId() + " to Enabled state",e);
      }
      _storagePoolHostDao.deletePrimaryRecordsForHost(hostId);
      final List<VMInstanceVO> vms=_vmDao.listByHostId(hostId);
      for (      final VMInstanceVO vm : vms) {
        vm.setState(State.Stopped);
        vm.setHostId(null);
        _vmDao.persist(vm);
      }
      for (      final StoragePoolHostVO pool : pools) {
        final Long poolId=pool.getPoolId();
        final StoragePoolVO storagePool=_storagePoolDao.findById(poolId);
        if (storagePool.isLocal() && isForceDeleteStorage) {
          storagePool.setUuid(null);
          storagePool.setClusterId(null);
          _storagePoolDao.update(poolId,storagePool);
          _storagePoolDao.remove(poolId);
          s_logger.debug("Local storage id=" + poolId + " is removed as a part of host removal id="+ hostId);
        }
      }
      final Object[] capacityTypes={Capacity.CAPACITY_TYPE_CPU,Capacity.CAPACITY_TYPE_MEMORY};
      final SearchCriteria<CapacityVO> hostCapacitySC=_capacityDao.createSearchCriteria();
      hostCapacitySC.addAnd("hostOrPoolId",SearchCriteria.Op.EQ,hostId);
      hostCapacitySC.addAnd("capacityType",SearchCriteria.Op.IN,capacityTypes);
      _capacityDao.remove(hostCapacitySC);
      final DedicatedResourceVO dr=_dedicatedDao.findByHostId(hostId);
      if (dr != null) {
        _dedicatedDao.remove(dr.getId());
      }
    }
  }
);
  _agentMgr.notifyMonitorsOfRemovedHost(host.getId(),clusterId);
  return true;
}

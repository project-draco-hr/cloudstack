{
  final Vpc vpc=getActiveVpc(vpcId);
  if (vpc == null) {
    InvalidParameterValueException ex=new InvalidParameterValueException("Unable to find Enabled VPC by id specified");
    ex.addProxyObject(String.valueOf(vpcId),"VPC");
    throw ex;
  }
  PhysicalNetwork physNet=null;
  if (physicalNetworkId == null) {
    List<? extends PhysicalNetwork> pNtwks=_ntwkModel.getPhysicalNtwksSupportingTrafficType(vpc.getZoneId(),TrafficType.Guest);
    if (pNtwks.isEmpty() || pNtwks.size() != 1) {
      throw new InvalidParameterValueException("Physical network can't be determined; pass physical network id");
    }
    physNet=pNtwks.get(0);
    physicalNetworkId=physNet.getId();
  }
  if (physNet == null) {
    physNet=_entityMgr.findById(PhysicalNetwork.class,physicalNetworkId);
  }
  final Long dcId=physNet.getDataCenterId();
  final Long physicalNetworkIdFinal=physicalNetworkId;
  final PhysicalNetwork physNetFinal=physNet;
  VpcGatewayVO gatewayVO=null;
  try {
    gatewayVO=Transaction.execute(new TransactionCallbackWithException<VpcGatewayVO,Exception>(){
      @Override public VpcGatewayVO doInTransaction(      TransactionStatus status) throws ResourceAllocationException, ConcurrentOperationException, InsufficientCapacityException {
        s_logger.debug("Creating Private gateway for VPC " + vpc);
        Network privateNtwk=null;
        if (BroadcastDomainType.getSchemeValue(BroadcastDomainType.fromString(broadcastUri)) == BroadcastDomainType.Lswitch) {
          String cidr=NetUtils.ipAndNetMaskToCidr(gateway,netmask);
          privateNtwk=_ntwkDao.getPrivateNetwork(broadcastUri,cidr,gatewayOwnerId,dcId,networkOfferingId);
        }
        if (privateNtwk == null) {
          s_logger.info("creating new network for vpc " + vpc + " using broadcast uri: "+ broadcastUri);
          String networkName="vpc-" + vpc.getName() + "-privateNetwork";
          privateNtwk=_ntwkSvc.createPrivateNetwork(networkName,networkName,physicalNetworkIdFinal,broadcastUri,ipAddress,null,gateway,netmask,gatewayOwnerId,vpcId,isSourceNat,networkOfferingId);
        }
 else {
          s_logger.info("found and using existing network for vpc " + vpc + ": "+ broadcastUri);
          DataCenterVO dc=_dcDao.lockRow(physNetFinal.getDataCenterId(),true);
          PrivateIpVO privateIp=_privateIpDao.findByIpAndSourceNetworkId(privateNtwk.getId(),ipAddress);
          if (privateIp != null) {
            throw new InvalidParameterValueException("Private ip address " + ipAddress + " already used for private gateway"+ " in zone "+ _entityMgr.findById(DataCenter.class,dcId).getName());
          }
          Long mac=dc.getMacAddress();
          Long nextMac=mac + 1;
          dc.setMacAddress(nextMac);
          s_logger.info("creating private ip adress for vpc (" + ipAddress + ", "+ privateNtwk.getId()+ ", "+ nextMac+ ", "+ vpcId+ ", "+ isSourceNat+ ")");
          privateIp=new PrivateIpVO(ipAddress,privateNtwk.getId(),nextMac,vpcId,isSourceNat);
          _privateIpDao.persist(privateIp);
          _dcDao.update(dc.getId(),dc);
        }
        long networkAclId=NetworkACL.DEFAULT_DENY;
        if (aclId != null) {
          NetworkACLVO aclVO=_networkAclDao.findById(aclId);
          if (aclVO == null) {
            throw new InvalidParameterValueException("Invalid network acl id passed ");
          }
          if ((aclVO.getVpcId() != vpcId) && !(aclId == NetworkACL.DEFAULT_DENY || aclId == NetworkACL.DEFAULT_ALLOW)) {
            throw new InvalidParameterValueException("Private gateway and network acl are not in the same vpc");
          }
          networkAclId=aclId;
        }
{
          NetworkVO gatewaynet=_ntwkDao.findById(privateNtwk.getId());
          gatewaynet.setVpcId(vpcId);
          _ntwkDao.persist(gatewaynet);
        }
        VpcGatewayVO gatewayVO=new VpcGatewayVO(ipAddress,VpcGateway.Type.Private,vpcId,privateNtwk.getDataCenterId(),privateNtwk.getId(),broadcastUri,gateway,netmask,vpc.getAccountId(),vpc.getDomainId(),isSourceNat,networkAclId);
        _vpcGatewayDao.persist(gatewayVO);
        s_logger.debug("Created vpc gateway entry " + gatewayVO);
        return gatewayVO;
      }
    }
);
  }
 catch (  Exception e) {
    ExceptionUtil.rethrowRuntime(e);
    ExceptionUtil.rethrow(e,InsufficientCapacityException.class);
    ExceptionUtil.rethrow(e,ResourceAllocationException.class);
    throw new IllegalStateException(e);
  }
  CallContext.current().setEventDetails("Private Gateway Id: " + gatewayVO.getId());
  return getVpcPrivateGateway(gatewayVO.getId());
}

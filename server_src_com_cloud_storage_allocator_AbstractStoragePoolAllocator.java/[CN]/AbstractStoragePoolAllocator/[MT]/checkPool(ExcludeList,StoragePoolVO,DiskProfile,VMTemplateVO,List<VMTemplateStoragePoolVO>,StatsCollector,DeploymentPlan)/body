{
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Checking if storage pool is suitable, name: " + pool.getName() + " ,poolId: "+ pool.getId());
  }
  if (avoid.shouldAvoid(pool)) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("StoragePool is in avoid set, skipping this pool");
    }
    return false;
  }
  if (dskCh.getType().equals(Type.ROOT) && pool.getPoolType().equals(StoragePoolType.Iscsi)) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Disk needed for ROOT volume, but StoragePoolType is Iscsi, skipping this and trying other available pools");
    }
    return false;
  }
  if (!pool.getStatus().equals(StoragePoolStatus.Up)) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("StoragePool status is not UP, status is: " + pool.getStatus().name() + ", skipping this pool");
    }
    return false;
  }
  if (!poolIsCorrectType(dskCh,pool)) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("StoragePool is not of correct type, skipping this pool");
    }
    return false;
  }
  Long clusterId=pool.getClusterId();
  ClusterVO cluster=_clusterDao.findById(clusterId);
  if (!(cluster.getHypervisorType() == dskCh.getHypersorType())) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("StoragePool's Cluster does not have required hypervisorType, skipping this pool");
    }
    return false;
  }
  if (sc != null) {
    long totalSize=pool.getCapacityBytes();
    StorageStats stats=sc.getStoragePoolStats(pool.getId());
    if (stats == null) {
      stats=sc.getStorageStats(pool.getId());
    }
    if (stats != null) {
      double usedPercentage=((double)stats.getByteUsed() / (double)totalSize);
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Attempting to look for pool " + pool.getId() + " for storage, totalSize: "+ pool.getCapacityBytes()+ ", usedBytes: "+ stats.getByteUsed()+ ", usedPct: "+ usedPercentage+ ", threshold: "+ _storageUsedThreshold);
      }
      if (usedPercentage >= _storageUsedThreshold) {
        if (s_logger.isDebugEnabled()) {
          s_logger.debug("Cannot allocate this pool " + pool.getId() + " for storage since its usage percentage: "+ usedPercentage+ " has crossed the storage.capacity.threshold: "+ _storageUsedThreshold+ ", skipping this pool");
        }
        return false;
      }
    }
  }
  Pair<Long,Long> sizes=_volumeDao.getCountAndTotalByPool(pool.getId());
  long totalAllocatedSize=sizes.second() + sizes.first() * _extraBytesPerVolume;
  boolean tmpinstalled=false;
  List<VMTemplateStoragePoolVO> templatePoolVOs;
  if (templatesInPool != null) {
    templatePoolVOs=templatesInPool;
  }
 else {
    templatePoolVOs=_templatePoolDao.listByPoolId(pool.getId());
  }
  for (  VMTemplateStoragePoolVO templatePoolVO : templatePoolVOs) {
    if ((template != null) && !tmpinstalled && (templatePoolVO.getTemplateId() == template.getId())) {
      tmpinstalled=true;
    }
    long templateSize=templatePoolVO.getTemplateSize();
    totalAllocatedSize+=templateSize + _extraBytesPerVolume;
  }
  if ((template != null) && !tmpinstalled) {
    VMTemplateHostVO templateHostVO=_storageMgr.findVmTemplateHost(template.getId(),pool);
    if (templateHostVO == null) {
      s_logger.info("Did not find template downloaded on secondary hosts in zone " + plan.getDataCenterId());
      return false;
    }
 else {
      long templateSize=templateHostVO.getPhysicalSize();
      if (templateSize == 0) {
        templateSize=templateHostVO.getSize();
      }
      totalAllocatedSize+=(templateSize + _extraBytesPerVolume);
    }
  }
  long askingSize=dskCh.getSize();
  float storageOverprovisioningFactor=1.0f;
  if (pool.getPoolType() == StoragePoolType.NetworkFilesystem) {
    storageOverprovisioningFactor=_storageOverprovisioningFactor;
  }
  if (s_logger.isDebugEnabled()) {
    s_logger.debug("Attempting to look for pool " + pool.getId() + " for storage, maxSize : "+ (pool.getCapacityBytes() * storageOverprovisioningFactor)+ ", totalSize : "+ totalAllocatedSize+ ", askingSize : "+ askingSize);
  }
  if ((pool.getCapacityBytes() * storageOverprovisioningFactor) < (totalAllocatedSize + askingSize)) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Cannot allocate this pool " + pool.getId() + " for storage, not enough storage, maxSize : "+ (pool.getCapacityBytes() * storageOverprovisioningFactor)+ ", totalSize : "+ totalAllocatedSize+ ", askingSize : "+ askingSize);
    }
    return false;
  }
  return true;
}

{
  Set<Long> affectedVms=new HashSet<Long>();
  int commandNum=0;
  for (  Answer ans : answers) {
    if (ans instanceof SecurityIngressRuleAnswer) {
      SecurityIngressRuleAnswer ruleAnswer=(SecurityIngressRuleAnswer)ans;
      if (ans.getResult()) {
        s_logger.debug("Successfully programmed rule " + ruleAnswer.toString() + " into host "+ agentId);
        _workDao.updateStep(ruleAnswer.getVmId(),ruleAnswer.getLogSequenceNumber(),Step.Done);
      }
 else {
        _workDao.updateStep(ruleAnswer.getVmId(),ruleAnswer.getLogSequenceNumber(),Step.Error);
        ;
        s_logger.debug("Failed to program rule " + ruleAnswer.toString() + " into host "+ agentId+ " due to "+ ruleAnswer.getDetails()+ " and updated  jobs");
        if (ruleAnswer.getReason() == FailureReason.CANNOT_BRIDGE_FIREWALL) {
          s_logger.debug("Not retrying security group rules for vm " + ruleAnswer.getVmId() + " on failure since host "+ agentId+ " cannot do bridge firewalling");
        }
 else         if (ruleAnswer.getReason() == FailureReason.PROGRAMMING_FAILED) {
          s_logger.debug("Retrying on failure for vm " + ruleAnswer.getVmId());
          affectedVms.add(ruleAnswer.getVmId());
        }
      }
      commandNum++;
    }
  }
  if (affectedVms.size() > 0) {
    _securityGroupManager.scheduleRulesetUpdateToHosts(affectedVms,false,new Long(10 * 1000l));
  }
  return true;
}

{
  if (!_isEnabled) {
    return;
  }
  if (affectedVms == null) {
    return;
  }
  if (delayMs == null)   delayMs=new Long(100l);
  for (  Long vmId : affectedVms) {
    Transaction txn=Transaction.currentTxn();
    txn.start();
    VmFlowLogVO log=null;
    OvsWorkVO work=null;
    UserVm vm=null;
    try {
      vm=_userVMDao.acquireInLockTable(vmId);
      if (vm == null) {
        s_logger.warn("Ovs failed to acquire lock on vm id " + vmId);
        continue;
      }
      log=_flowLogDao.findByVmId(vmId);
      if (log == null) {
        log=new VmFlowLogVO(vmId);
        log=_flowLogDao.persist(log);
      }
      if (log != null && updateSeqno) {
        log.incrLogsequence();
        _flowLogDao.update(log.getId(),log);
      }
      work=_workDao.findByVmIdStep(vmId,Step.Scheduled);
      if (work == null) {
        work=new OvsWorkVO(vmId,null,null,OvsWorkVO.Step.Scheduled,null);
        work=_workDao.persist(work);
      }
      work.setLogsequenceNumber(log.getLogsequence());
      _workDao.update(work.getId(),work);
    }
  finally {
      if (vm != null) {
        _userVMDao.releaseFromLockTable(vmId);
      }
    }
    txn.commit();
    _executorPool.schedule(new WorkerThread(),delayMs,TimeUnit.MILLISECONDS);
  }
}

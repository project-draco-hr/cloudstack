{
  if (ipAddress == null || ipAddress.isEmpty()) {
    s_logger.debug("No ip association rules to be applied for network " + network.getId());
    return true;
  }
  VirtualRouter router=routers.get(0);
  if (router.getVpcId() == null) {
    return super.associatePublicIP(network,ipAddress,routers);
  }
  Pair<Map<String,PublicIpAddress>,Map<String,PublicIpAddress>> nicsToChange=getNicsToChangeOnRouter(ipAddress,router);
  Map<String,PublicIpAddress> nicsToPlug=nicsToChange.first();
  Map<String,PublicIpAddress> nicsToUnplug=nicsToChange.second();
  for (  String vlanTag : nicsToUnplug.keySet()) {
    Network publicNtwk=null;
    try {
      publicNtwk=_networkModel.getNetwork(nicsToUnplug.get(vlanTag).getNetworkId());
      URI broadcastUri=BroadcastDomainType.Vlan.toUri(vlanTag);
      _itMgr.removeVmFromNetwork(router,publicNtwk,broadcastUri);
    }
 catch (    ConcurrentOperationException e) {
      s_logger.warn("Failed to remove router " + router + " from vlan "+ vlanTag+ " in public network "+ publicNtwk+ " due to ",e);
      return false;
    }
  }
  Commands netUsagecmds=new Commands(OnError.Continue);
  VpcVO vpc=_vpcDao.findById(router.getVpcId());
  for (  String vlanTag : nicsToPlug.keySet()) {
    PublicIpAddress ip=nicsToPlug.get(vlanTag);
    NicProfile defaultNic=new NicProfile();
    if (ip.isSourceNat()) {
      defaultNic.setDefaultNic(true);
    }
    defaultNic.setIp4Address(ip.getAddress().addr());
    defaultNic.setGateway(ip.getGateway());
    defaultNic.setNetmask(ip.getNetmask());
    defaultNic.setMacAddress(ip.getMacAddress());
    defaultNic.setBroadcastType(BroadcastDomainType.Vlan);
    defaultNic.setBroadcastUri(BroadcastDomainType.Vlan.toUri(ip.getVlanTag()));
    defaultNic.setIsolationUri(IsolationType.Vlan.toUri(ip.getVlanTag()));
    NicProfile publicNic=null;
    Network publicNtwk=null;
    try {
      publicNtwk=_networkModel.getNetwork(ip.getNetworkId());
      publicNic=_itMgr.addVmToNetwork(router,publicNtwk,defaultNic);
    }
 catch (    ConcurrentOperationException e) {
      s_logger.warn("Failed to add router " + router + " to vlan "+ vlanTag+ " in public network "+ publicNtwk+ " due to ",e);
    }
catch (    InsufficientCapacityException e) {
      s_logger.warn("Failed to add router " + router + " to vlan "+ vlanTag+ " in public network "+ publicNtwk+ " due to ",e);
    }
 finally {
      if (publicNic == null) {
        s_logger.warn("Failed to add router " + router + " to vlan "+ vlanTag+ " in public network "+ publicNtwk);
        return false;
      }
    }
    NetworkUsageCommand netUsageCmd=new NetworkUsageCommand(router.getPrivateIpAddress(),router.getInstanceName(),true,defaultNic.getIp4Address(),vpc.getCidr());
    netUsagecmds.addCommand(netUsageCmd);
    UserStatisticsVO stats=_userStatsDao.findBy(router.getAccountId(),router.getDataCenterIdToDeployIn(),publicNtwk.getId(),publicNic.getIp4Address(),router.getId(),router.getType().toString());
    if (stats == null) {
      stats=new UserStatisticsVO(router.getAccountId(),router.getDataCenterIdToDeployIn(),publicNic.getIp4Address(),router.getId(),router.getType().toString(),publicNtwk.getId());
      _userStatsDao.persist(stats);
    }
  }
  boolean result=applyRules(network,routers,"vpc ip association",false,null,false,new RuleApplier(){
    @Override public boolean execute(    Network network,    VirtualRouter router) throws ResourceUnavailableException {
      Commands cmds=new Commands(OnError.Continue);
      Map<String,String> vlanMacAddress=new HashMap<String,String>();
      List<PublicIpAddress> ipsToSend=new ArrayList<PublicIpAddress>();
      for (      PublicIpAddress ipAddr : ipAddress) {
        String broadcastURI=BroadcastDomainType.Vlan.toUri(ipAddr.getVlanTag()).toString();
        Nic nic=_nicDao.findByNetworkIdInstanceIdAndBroadcastUri(ipAddr.getNetworkId(),router.getId(),broadcastURI);
        String macAddress=null;
        if (nic == null) {
          if (ipAddr.getState() != IpAddress.State.Releasing) {
            throw new CloudRuntimeException("Unable to find the nic in network " + ipAddr.getNetworkId() + "  to apply the ip address "+ ipAddr+ " for");
          }
          s_logger.debug("Not sending release for ip address " + ipAddr + " as its nic is already gone from VPC router "+ router);
        }
 else {
          macAddress=nic.getMacAddress();
          vlanMacAddress.put(ipAddr.getVlanTag(),macAddress);
          ipsToSend.add(ipAddr);
        }
      }
      if (!ipsToSend.isEmpty()) {
        createVpcAssociatePublicIPCommands(router,ipsToSend,cmds,vlanMacAddress);
        return sendCommandsToRouter(router,cmds);
      }
 else {
        return true;
      }
    }
  }
);
  if (result && netUsagecmds.size() > 0) {
    sendCommandsToRouter(router,netUsagecmds);
  }
  return result;
}

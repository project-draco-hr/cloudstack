{
  if (publicNetwork.getTrafficType() != TrafficType.Public) {
    s_logger.warn("Network " + publicNetwork + " is not of type "+ TrafficType.Public);
    return false;
  }
  boolean result=true;
  try {
    NicProfile defaultNic=new NicProfile();
    if (ipAddress.isSourceNat()) {
      defaultNic.setDefaultNic(true);
    }
    defaultNic.setIp4Address(ipAddress.getAddress().addr());
    defaultNic.setGateway(ipAddress.getGateway());
    defaultNic.setNetmask(ipAddress.getNetmask());
    defaultNic.setMacAddress(ipAddress.getMacAddress());
    defaultNic.setBroadcastType(BroadcastDomainType.Vlan);
    defaultNic.setBroadcastUri(BroadcastDomainType.Vlan.toUri(ipAddress.getVlanTag()));
    defaultNic.setIsolationUri(IsolationType.Vlan.toUri(ipAddress.getVlanTag()));
    NicProfile publicNic=_itMgr.addVmToNetwork(router,publicNetwork,defaultNic);
    if (publicNic != null) {
      if (ipAddress.isSourceNat()) {
        if (router.getPublicIpAddress() == null) {
          DomainRouterVO routerVO=_routerDao.findById(router.getId());
          routerVO.setPublicIpAddress(ipAddress.getAddress().toString());
          routerVO.setPublicNetmask(ipAddress.getNetmask());
          routerVO.setPublicMacAddress(ipAddress.getMacAddress());
          _routerDao.update(routerVO.getId(),routerVO);
        }
      }
      publicNic.setDefaultNic(true);
      if (ipAddress != null) {
        IPAddressVO ipVO=_ipAddressDao.findById(ipAddress.getId());
        PrivateIp publicIp=new PrivateIp(ipVO,_vlanDao.findById(ipVO.getVlanId()),NetUtils.createSequenceBasedMacAddress(ipVO.getMacAddress()));
        result=associtePublicIpInVpc(publicNetwork,router,false,publicIp);
      }
    }
 else {
      result=false;
      s_logger.warn("Failed to add public ip " + ipAddress + " to VPC router "+ router);
    }
  }
 catch (  Exception ex) {
    s_logger.warn("Failed to add ip address " + ipAddress + " from the public network "+ publicNetwork+ " to VPC router "+ router+ " due to ",ex);
    result=false;
  }
  return result;
}

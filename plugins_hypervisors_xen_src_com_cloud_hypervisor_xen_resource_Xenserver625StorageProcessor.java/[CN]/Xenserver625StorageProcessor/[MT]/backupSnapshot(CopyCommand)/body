{
  Connection conn=hypervisorResource.getConnection();
  DataTO srcData=cmd.getSrcTO();
  DataTO cacheData=cmd.getCacheTO();
  DataTO destData=cmd.getDestTO();
  int wait=cmd.getWait();
  PrimaryDataStoreTO primaryStore=(PrimaryDataStoreTO)srcData.getDataStore();
  String primaryStorageNameLabel=primaryStore.getUuid();
  String secondaryStorageUrl=null;
  NfsTO cacheStore=null;
  String destPath=null;
  if (cacheData != null) {
    cacheStore=(NfsTO)cacheData.getDataStore();
    secondaryStorageUrl=cacheStore.getUrl();
    destPath=cacheData.getPath();
  }
 else {
    cacheStore=(NfsTO)destData.getDataStore();
    secondaryStorageUrl=cacheStore.getUrl();
    destPath=destData.getPath();
  }
  SnapshotObjectTO snapshotTO=(SnapshotObjectTO)srcData;
  SnapshotObjectTO snapshotOnImage=(SnapshotObjectTO)destData;
  String snapshotUuid=snapshotTO.getPath();
  String prevBackupUuid=snapshotOnImage.getParentSnapshotPath();
  String prevSnapshotUuid=snapshotTO.getParentSnapshotPath();
  Map<String,String> options=cmd.getOptions();
  String details=null;
  String snapshotBackupUuid=null;
  boolean fullbackup=Boolean.parseBoolean(options.get("fullSnapshot"));
  try {
    SR primaryStorageSR=hypervisorResource.getSRByNameLabelandHost(conn,primaryStorageNameLabel);
    if (primaryStorageSR == null) {
      throw new InternalErrorException("Could not backup snapshot because the primary Storage SR could not be created from the name label: " + primaryStorageNameLabel);
    }
    String psUuid=primaryStorageSR.getUuid(conn);
    Boolean isISCSI=IsISCSI(primaryStorageSR.getType(conn));
    VDI snapshotVdi=getVDIbyUuid(conn,snapshotUuid);
    String snapshotPaUuid=null;
    URI uri=new URI(secondaryStorageUrl);
    String secondaryStorageMountPath=uri.getHost() + ":" + uri.getPath();
    DataStoreTO destStore=destData.getDataStore();
    String folder=destPath;
    String finalPath=null;
    String localMountPoint=BaseMountPointOnHost + File.separator + UUID.nameUUIDFromBytes(secondaryStorageUrl.getBytes()).toString();
    if (fullbackup) {
      SR snapshotSr=null;
      try {
        String localDir="/var/cloud_mount/" + UUID.nameUUIDFromBytes(secondaryStorageMountPath.getBytes());
        mountNfs(conn,secondaryStorageMountPath,localDir);
        boolean result=makeDirectory(conn,localDir + "/" + folder);
        if (!result) {
          details=" Filed to create folder " + folder + " in secondary storage";
          s_logger.warn(details);
          return new CopyCmdAnswer(details);
        }
        snapshotSr=createFileSr(conn,secondaryStorageMountPath,folder);
        Task task=snapshotVdi.copyAsync(conn,snapshotSr,null,null);
        hypervisorResource.waitForTask(conn,task,1000,wait * 1000);
        hypervisorResource.checkForSuccess(conn,task);
        VDI backedVdi=Types.toVDI(task,conn);
        snapshotBackupUuid=backedVdi.getUuid(conn);
        if (destStore instanceof SwiftTO) {
          try {
            String container="S-" + snapshotTO.getVolume().getVolumeId().toString();
            String destSnapshotName=swiftBackupSnapshot(conn,(SwiftTO)destStore,snapshotSr.getUuid(conn),snapshotBackupUuid,container,false,wait);
            String swiftPath=container + File.separator + destSnapshotName;
            finalPath=swiftPath;
          }
  finally {
            try {
              deleteSnapshotBackup(conn,localMountPoint,folder,secondaryStorageMountPath,snapshotBackupUuid);
            }
 catch (            Exception e) {
              s_logger.debug("Failed to delete snapshot on cache storages",e);
            }
          }
        }
 else         if (destStore instanceof S3TO) {
          try {
            finalPath=backupSnapshotToS3(conn,(S3TO)destStore,snapshotSr.getUuid(conn),folder,snapshotBackupUuid,isISCSI,wait);
            if (finalPath == null) {
              throw new CloudRuntimeException("S3 upload of snapshots " + snapshotBackupUuid + " failed");
            }
          }
  finally {
            try {
              deleteSnapshotBackup(conn,localMountPoint,folder,secondaryStorageMountPath,snapshotBackupUuid);
            }
 catch (            Exception e) {
              s_logger.debug("Failed to delete snapshot on cache storages",e);
            }
          }
        }
 else {
          finalPath=folder + File.separator + snapshotBackupUuid;
        }
      }
  finally {
        if (snapshotSr != null) {
          hypervisorResource.removeSR(conn,snapshotSr);
        }
      }
    }
 else {
      String primaryStorageSRUuid=primaryStorageSR.getUuid(conn);
      if (destStore instanceof SwiftTO) {
        String container="S-" + snapshotTO.getVolume().getVolumeId().toString();
        snapshotBackupUuid=swiftBackupSnapshot(conn,(SwiftTO)destStore,primaryStorageSRUuid,snapshotPaUuid,"S-" + snapshotTO.getVolume().getVolumeId().toString(),isISCSI,wait);
        finalPath=container + File.separator + snapshotBackupUuid;
      }
 else       if (destStore instanceof S3TO) {
        finalPath=backupSnapshotToS3(conn,(S3TO)destStore,primaryStorageSRUuid,folder,snapshotPaUuid,isISCSI,wait);
        if (finalPath == null) {
          throw new CloudRuntimeException("S3 upload of snapshots " + snapshotPaUuid + " failed");
        }
      }
 else {
        snapshotBackupUuid=backupSnapshot(conn,primaryStorageSRUuid,localMountPoint,folder,secondaryStorageMountPath,snapshotUuid,prevBackupUuid,prevSnapshotUuid,isISCSI,wait);
        finalPath=folder + File.separator + snapshotBackupUuid;
      }
    }
    String volumeUuid=snapshotTO.getVolume().getPath();
    destroySnapshotOnPrimaryStorageExceptThis(conn,volumeUuid,snapshotUuid);
    SnapshotObjectTO newSnapshot=new SnapshotObjectTO();
    newSnapshot.setPath(finalPath);
    if (fullbackup) {
      newSnapshot.setParentSnapshotPath(null);
    }
 else {
      newSnapshot.setParentSnapshotPath(prevBackupUuid);
    }
    return new CopyCmdAnswer(newSnapshot);
  }
 catch (  Types.XenAPIException e) {
    details="BackupSnapshot Failed due to " + e.toString();
    s_logger.warn(details,e);
  }
catch (  Exception e) {
    details="BackupSnapshot Failed due to " + e.getMessage();
    s_logger.warn(details,e);
  }
  return new CopyCmdAnswer(details);
}

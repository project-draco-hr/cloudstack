{
  final ServiceOfferingVO routerOffering=_serviceOfferingDao.findById(svcOffId);
  final List<HypervisorType> hypervisors=getHypervisors(dest,plan,supportedHypervisors);
  int allocateRetry=0;
  int startRetry=0;
  DomainRouterVO router=null;
  for (final Iterator<HypervisorType> iter=hypervisors.iterator(); iter.hasNext(); ) {
    HypervisorType hType=iter.next();
    try {
      final long id=_routerDao.getNextInSequence(Long.class,"id");
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Allocating the VR i=" + id + " in datacenter "+ dest.getDataCenter()+ "with the hypervisor type "+ hType);
      }
      String templateName=null;
switch (hType) {
case XenServer:
        templateName=RouterTemplateXen.valueIn(dest.getDataCenter().getId());
      break;
case KVM:
    templateName=RouterTemplateKvm.valueIn(dest.getDataCenter().getId());
  break;
case VMware:
templateName=RouterTemplateVmware.valueIn(dest.getDataCenter().getId());
break;
case Hyperv:
templateName=RouterTemplateHyperV.valueIn(dest.getDataCenter().getId());
break;
case LXC:
templateName=RouterTemplateLxc.valueIn(dest.getDataCenter().getId());
break;
case BareMetal:
String peerHvType=_configDao.getValue(Config.BaremetalPeerHypervisorType.key());
if (peerHvType == null) {
throw new CloudRuntimeException(String.format("To use baremetal in advanced networking, you must set %s to type of hypervisor(e.g XenServer)" + " that exists in the same zone with baremetal host. That hyperivsor is used to spring up virtual router for baremetal instance",Config.BaremetalPeerHypervisorType.key()));
}
hType=HypervisorType.getType(peerHvType);
if (HypervisorType.XenServer.toString().equals(peerHvType)) {
templateName=RouterTemplateXen.valueIn(dest.getDataCenter().getId());
}
 else if (HypervisorType.KVM.toString().equals(peerHvType)) {
templateName=RouterTemplateKvm.valueIn(dest.getDataCenter().getId());
}
 else if (HypervisorType.VMware.toString().equals(peerHvType)) {
templateName=RouterTemplateVmware.valueIn(dest.getDataCenter().getId());
}
 else {
throw new CloudRuntimeException(String.format("Baremetal only supports peer hypervisor(XenServer/KVM/VMWare) right now, you specified %s",peerHvType));
}
break;
default :
break;
}
final VMTemplateVO template=_templateDao.findRoutingTemplate(hType,templateName);
if (template == null) {
s_logger.debug(hType + " won't support system vm, skip it");
continue;
}
boolean offerHA=routerOffering.getOfferHA();
if (isRedundant) {
offerHA=false;
}
router=new DomainRouterVO(id,routerOffering.getId(),vrProvider.getId(),VirtualMachineName.getRouterName(id,_instance),template.getId(),template.getHypervisorType(),template.getGuestOSId(),owner.getDomainId(),owner.getId(),isRedundant,0,false,RedundantState.UNKNOWN,offerHA,false,vpcId);
router.setDynamicallyScalable(template.isDynamicallyScalable());
router.setRole(Role.VIRTUAL_ROUTER);
router=_routerDao.persist(router);
_itMgr.allocate(router.getInstanceName(),template,routerOffering,networks,plan,null);
router=_routerDao.findById(router.getId());
}
 catch (final InsufficientCapacityException ex) {
if (allocateRetry < 2 && iter.hasNext()) {
s_logger.debug("Failed to allocate the VR with hypervisor type " + hType + ", retrying one more time");
continue;
}
 else {
throw ex;
}
}
 finally {
allocateRetry++;
}
if (startRouter) {
try {
router=startVirtualRouter(router,_accountMgr.getSystemUser(),_accountMgr.getSystemAccount(),params);
break;
}
 catch (final InsufficientCapacityException ex) {
if (startRetry < 2 && iter.hasNext()) {
s_logger.debug("Failed to start the VR  " + router + " with hypervisor type "+ hType+ ", "+ "destroying it and recreating one more time");
destroyRouter(router.getId(),_accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM),User.UID_SYSTEM);
continue;
}
 else {
throw ex;
}
}
 finally {
startRetry++;
}
}
 else {
return router;
}
}
return router;
}

{
  DomainRouterVO router=profile.getVirtualMachine();
  DataCenterVO dcVo=_dcDao.findById(router.getDataCenterIdToDeployIn());
  NicProfile controlNic=null;
  if (profile.getHypervisorType() == HypervisorType.VMware && dcVo.getNetworkType() == NetworkType.Basic) {
    for (    NicProfile nic : profile.getNics()) {
      if (nic.getTrafficType() == TrafficType.Guest && nic.getIp4Address() != null) {
        controlNic=nic;
      }
    }
  }
 else {
    for (    NicProfile nic : profile.getNics()) {
      if (nic.getTrafficType() == TrafficType.Control && nic.getIp4Address() != null) {
        controlNic=nic;
      }
    }
  }
  if (controlNic == null) {
    s_logger.error("Control network doesn't exist for the router " + router);
    return false;
  }
  cmds.addCommand("checkSsh",new CheckSshCommand(profile.getInstanceName(),controlNic.getIp4Address(),3922,5,20));
  cmds.addCommand("networkUsage",new NetworkUsageCommand(controlNic.getIp4Address(),router.getHostName(),"create"));
  boolean restartNetwork=true;
  if (profile.getParameter(Param.RestartNetwork) != null && (Boolean)profile.getParameter(Param.RestartNetwork) == false) {
    restartNetwork=false;
  }
  if (router.getRole() == VirtualRouter.Role.DHCP_FIREWALL_LB_PASSWD_USERDATA && restartNetwork) {
    s_logger.debug("Resending ipAssoc, port forwarding, load balancing rules as a part of Virtual router start");
    long networkId=router.getNetworkId();
    long ownerId=router.getAccountId();
    long zoneId=router.getDataCenterIdToDeployIn();
    final List<IPAddressVO> userIps=_networkMgr.listPublicIpAddressesInVirtualNetwork(ownerId,zoneId,null,null);
    List<PublicIpAddress> publicIps=new ArrayList<PublicIpAddress>();
    if (userIps != null && !userIps.isEmpty()) {
      for (      IPAddressVO userIp : userIps) {
        PublicIp publicIp=new PublicIp(userIp,_vlanDao.findById(userIp.getVlanId()),NetUtils.createSequenceBasedMacAddress(userIp.getMacAddress()));
        publicIps.add(publicIp);
      }
    }
    s_logger.debug("Found " + publicIps.size() + " ip(s) to apply as a part of domR "+ router+ " start.");
    if (!publicIps.isEmpty()) {
      createAssociateIPCommands(router,publicIps,cmds,0);
      List<RemoteAccessVpn> vpns=new ArrayList<RemoteAccessVpn>();
      List<PortForwardingRule> pfRules=new ArrayList<PortForwardingRule>();
      List<FirewallRule> staticNatFirewallRules=new ArrayList<FirewallRule>();
      List<StaticNat> staticNats=new ArrayList<StaticNat>();
      List<FirewallRule> firewallRules=new ArrayList<FirewallRule>();
      for (      PublicIpAddress ip : publicIps) {
        pfRules.addAll(_pfRulesDao.listForApplication(ip.getId()));
        staticNatFirewallRules.addAll(_rulesDao.listByIpAndPurpose(ip.getId(),Purpose.StaticNat));
        firewallRules.addAll(_rulesDao.listByIpAndPurpose(ip.getId(),Purpose.Firewall));
        RemoteAccessVpn vpn=_vpnDao.findById(ip.getId());
        if (vpn != null) {
          vpns.add(vpn);
        }
        if (ip.isOneToOneNat()) {
          String dstIp=_networkMgr.getIpInNetwork(ip.getAssociatedWithVmId(),networkId);
          StaticNatImpl staticNat=new StaticNatImpl(ip.getAccountId(),ip.getDomainId(),networkId,ip.getId(),dstIp,false);
          staticNats.add(staticNat);
        }
      }
      s_logger.debug("Found " + staticNats.size() + " static nat(s) to apply as a part of domR "+ router+ " start.");
      if (!staticNats.isEmpty()) {
        createApplyStaticNatCommands(staticNats,router,cmds);
      }
      s_logger.debug("Found " + staticNats.size() + " firewall rule(s) to apply as a part of domR "+ router+ " start.");
      if (!firewallRules.isEmpty()) {
        createFirewallRulesCommands(firewallRules,router,cmds);
      }
      s_logger.debug("Found " + pfRules.size() + " port forwarding rule(s) to apply as a part of domR "+ router+ " start.");
      if (!pfRules.isEmpty()) {
        createApplyPortForwardingRulesCommands(pfRules,router,cmds);
      }
      s_logger.debug("Found " + staticNatFirewallRules.size() + " static nat rule(s) to apply as a part of domR "+ router+ " start.");
      if (!staticNatFirewallRules.isEmpty()) {
        List<StaticNatRule> staticNatRules=new ArrayList<StaticNatRule>();
        for (        FirewallRule rule : staticNatFirewallRules) {
          staticNatRules.add(_rulesMgr.buildStaticNatRule(rule));
        }
        createApplyStaticNatRulesCommands(staticNatRules,router,cmds);
      }
      s_logger.debug("Found " + vpns.size() + " vpn(s) to apply as a part of domR "+ router+ " start.");
      if (!vpns.isEmpty()) {
        for (        RemoteAccessVpn vpn : vpns) {
          createApplyVpnCommands(vpn,router,cmds);
        }
      }
      List<LoadBalancerVO> lbs=_loadBalancerDao.listByNetworkId(networkId);
      List<LoadBalancingRule> lbRules=new ArrayList<LoadBalancingRule>();
      for (      LoadBalancerVO lb : lbs) {
        List<LbDestination> dstList=_lbMgr.getExistingDestinations(lb.getId());
        LoadBalancingRule loadBalancing=new LoadBalancingRule(lb,dstList);
        lbRules.add(loadBalancing);
      }
      s_logger.debug("Found " + lbRules.size() + " load balancing rule(s) to apply as a part of domR "+ router+ " start.");
      if (!lbRules.isEmpty()) {
        createApplyLoadBalancingRulesCommands(lbRules,router,cmds);
      }
    }
  }
  s_logger.debug("Reapplying dhcp entries as a part of domR " + router + " start...");
  createDhcpEntriesCommands(router,cmds);
  s_logger.debug("Reapplying vm data (userData and metaData) entries as a part of domR " + router + " start...");
  createVmDataCommands(router,cmds);
  return true;
}

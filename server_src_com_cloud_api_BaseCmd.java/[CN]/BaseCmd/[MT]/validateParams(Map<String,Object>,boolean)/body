{
  List<Pair<Enum,Boolean>> properties=getProperties();
  Map<String,Object> processedParams=lowercaseParams(params,decode);
  Map<String,Object> validatedParams=new HashMap<String,Object>();
  for (  Pair<Enum,Boolean> propertyPair : properties) {
    Properties prop=(Properties)propertyPair.first();
    Object param=processedParams.get(prop.getName());
    if (param != null) {
      short propertyType=prop.getDataType();
      String decodedParam=null;
      if ((propertyType != TYPE_OBJECT) && (propertyType != TYPE_OBJECT_MAP)) {
        decodedParam=(String)param;
        if (decode) {
          try {
            decodedParam=URLDecoder.decode((String)param,"UTF-8");
          }
 catch (          UnsupportedEncodingException usex) {
            s_logger.warn(prop.getName() + " could not be decoded, value = " + param);
            throw new ServerApiException(PARAM_ERROR,prop.getName() + " could not be decoded");
          }
        }
      }
switch (propertyType) {
case TYPE_INT:
        try {
          validatedParams.put(prop.getName(),Integer.valueOf(Integer.parseInt(decodedParam)));
        }
 catch (        NumberFormatException ex) {
          s_logger.warn(prop.getName() + " (type is int) is malformed, value = " + decodedParam);
          throw new ServerApiException(MALFORMED_PARAMETER_ERROR,prop.getName() + " is malformed");
        }
      break;
case TYPE_LONG:
    try {
      validatedParams.put(prop.getName(),Long.valueOf(Long.parseLong(decodedParam)));
    }
 catch (    NumberFormatException ex) {
      s_logger.warn(prop.getName() + " (type is long) is malformed, value = " + decodedParam);
      throw new ServerApiException(MALFORMED_PARAMETER_ERROR,prop.getName() + " is malformed");
    }
  break;
case TYPE_DATE:
try {
synchronized (_format) {
    validatedParams.put(prop.getName(),_format.parse(decodedParam));
  }
}
 catch (ParseException ex) {
  s_logger.warn(prop.getName() + " (type is date) is malformed, value = " + decodedParam);
  throw new ServerApiException(MALFORMED_PARAMETER_ERROR,prop.getName() + " uses an unsupported date format");
}
break;
case TYPE_TZDATE:
try {
validatedParams.put(prop.getName(),DateUtil.parseTZDateString(decodedParam));
}
 catch (ParseException ex) {
s_logger.warn(prop.getName() + " (type is date) is malformed, value = " + decodedParam);
throw new ServerApiException(MALFORMED_PARAMETER_ERROR,prop.getName() + " uses an unsupported date format");
}
break;
case TYPE_FLOAT:
try {
validatedParams.put(prop.getName(),Float.valueOf(Float.parseFloat(decodedParam)));
}
 catch (NumberFormatException ex) {
s_logger.warn(prop.getName() + " (type is float) is malformed, value = " + decodedParam);
throw new ServerApiException(MALFORMED_PARAMETER_ERROR,prop.getName() + " is malformed");
}
break;
case TYPE_BOOLEAN:
validatedParams.put(prop.getName(),Boolean.valueOf(Boolean.parseBoolean(decodedParam)));
break;
case TYPE_STRING:
validatedParams.put(prop.getName(),decodedParam);
break;
default :
validatedParams.put(prop.getName(),param);
break;
}
}
 else if (propertyPair.second().booleanValue() == true) {
s_logger.warn("missing parameter, " + prop.getTagName() + " is not specified");
throw new ServerApiException(MALFORMED_PARAMETER_ERROR,prop.getTagName() + " is not specified");
}
}
return validatedParams;
}

{
  final CallContext context=CallContext.current();
  final Account account=context.getCallingAccount();
  final User user=context.getCallingUser();
  final VMInstanceVO vm=_vmDao.findByUuid(vmUuid);
  List<VmWorkJobVO> pendingWorkJobs=_workJobDao.listPendingWorkJobs(VirtualMachine.Type.Instance,vm.getId(),VmWorkReboot.class.getName());
  VmWorkJobVO workJob=null;
  if (pendingWorkJobs != null && pendingWorkJobs.size() > 0) {
    assert(pendingWorkJobs.size() == 1);
    workJob=pendingWorkJobs.get(0);
  }
 else {
    workJob=new VmWorkJobVO(context.getContextId());
    workJob.setDispatcher(VmWorkConstants.VM_WORK_JOB_DISPATCHER);
    workJob.setCmd(VmWorkReboot.class.getName());
    workJob.setAccountId(account.getId());
    workJob.setUserId(user.getId());
    workJob.setStep(VmWorkJobVO.Step.Prepare);
    workJob.setVmType(VirtualMachine.Type.Instance);
    workJob.setVmInstanceId(vm.getId());
    workJob.setRelated(AsyncJobExecutionContext.getOriginJobId());
    VmWorkReboot workInfo=new VmWorkReboot(user.getId(),account.getId(),vm.getId(),VirtualMachineManagerImpl.VM_WORK_JOB_HANDLER,params);
    workJob.setCmdInfo(VmWorkSerializer.serialize(workInfo));
    _jobMgr.submitAsyncJob(workJob,VmWorkConstants.VM_WORK_QUEUE,vm.getId());
  }
  AsyncJobExecutionContext.getCurrentExecutionContext().joinJob(workJob.getId());
  return new VmJobVirtualMachineOutcome(workJob,vm.getId());
}

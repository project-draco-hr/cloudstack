{
  final CallContext context=CallContext.current();
  final Account account=context.getCallingAccount();
  final User user=context.getCallingUser();
  final VMInstanceVO vm=_vmDao.findByUuid(vmUuid);
  Object[] result=Transaction.execute(new TransactionCallback<Object[]>(){
    @Override public Object[] doInTransaction(    TransactionStatus status){
      _vmDao.lockInLockTable(String.valueOf(vm.getId()),Integer.MAX_VALUE);
      try {
        List<VmWorkJobVO> pendingWorkJobs=_workJobDao.listPendingWorkJobs(vm.getType(),vm.getId(),VmWorkStop.class.getName());
        VmWorkJobVO workJob=null;
        if (pendingWorkJobs != null && pendingWorkJobs.size() > 0) {
          assert(pendingWorkJobs.size() == 1);
          workJob=pendingWorkJobs.get(0);
        }
 else {
          workJob=new VmWorkJobVO(context.getContextId());
          workJob.setDispatcher(VmWorkConstants.VM_WORK_JOB_DISPATCHER);
          workJob.setCmd(VmWorkStop.class.getName());
          workJob.setAccountId(account.getId());
          workJob.setUserId(user.getId());
          workJob.setStep(VmWorkJobVO.Step.Prepare);
          workJob.setVmType(VirtualMachine.Type.Instance);
          workJob.setVmInstanceId(vm.getId());
          workJob.setRelated(AsyncJobExecutionContext.getOriginJobId());
          VmWorkStop workInfo=new VmWorkStop(user.getId(),account.getId(),vm.getId(),VirtualMachineManagerImpl.VM_WORK_JOB_HANDLER,cleanup);
          workJob.setCmdInfo(VmWorkSerializer.serialize(workInfo));
          _jobMgr.submitAsyncJob(workJob,VmWorkConstants.VM_WORK_QUEUE,vm.getId());
        }
        return new Object[]{workJob,new Long(workJob.getId())};
      }
  finally {
        _vmDao.unlockFromLockTable(String.valueOf(vm.getId()));
      }
    }
  }
);
  final long jobId=(Long)result[1];
  AsyncJobExecutionContext.getCurrentExecutionContext().joinJob(jobId);
  return new VmStateSyncOutcome((VmWorkJobVO)result[0],VirtualMachine.PowerState.PowerOff,vm.getId(),null);
}

{
  AsyncJobExecutionContext jobContext=AsyncJobExecutionContext.getCurrentExecutionContext();
  if (!VmJobEnabled.value() || jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {
    VmWorkJobVO placeHolder=null;
    if (VmJobEnabled.value()) {
      VirtualMachine vm=_vmDao.findByUuid(vmUuid);
      placeHolder=createPlaceHolderWork(vm.getId());
    }
    try {
      try {
        orchestrateMigrateAway(vmUuid,srcHostId,null);
      }
 catch (      InsufficientServerCapacityException e) {
        s_logger.warn("Failed to deploy vm " + vmUuid + " with original planner, sending HAPlanner");
        orchestrateMigrateAway(vmUuid,srcHostId,_haMgr.getHAPlanner());
      }
    }
  finally {
      if (VmJobEnabled.value())       _workJobDao.expunge(placeHolder.getId());
    }
  }
 else {
    Outcome<VirtualMachine> outcome=migrateVmAwayThroughJobQueue(vmUuid,srcHostId);
    try {
      VirtualMachine vm=outcome.get();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException("Operation is interrupted",e);
    }
catch (    java.util.concurrent.ExecutionException e) {
      throw new RuntimeException("Execution excetion",e);
    }
    Object jobException=_jobMgr.unmarshallResultObject(outcome.getJob());
    if (jobException != null) {
      if (jobException instanceof InsufficientServerCapacityException)       throw (InsufficientServerCapacityException)jobException;
 else       if (jobException instanceof ConcurrentOperationException)       throw (ConcurrentOperationException)jobException;
 else       if (jobException instanceof RuntimeException)       throw (RuntimeException)jobException;
 else       if (jobException instanceof Throwable)       throw new RuntimeException("Unexpected exception",(Throwable)jobException);
    }
  }
}

{
  AsyncJobExecutionContext jobContext=AsyncJobExecutionContext.getCurrentExecutionContext();
  if (jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {
    VmWorkJobVO placeHolder=null;
    VirtualMachine vm=_vmDao.findByUuid(vmUuid);
    placeHolder=createPlaceHolderWork(vm.getId());
    try {
      return orchestrateReConfigureVm(vmUuid,oldServiceOffering,reconfiguringOnExistingHost);
    }
  finally {
      if (placeHolder != null) {
        _workJobDao.expunge(placeHolder.getId());
      }
    }
  }
 else {
    Outcome<VirtualMachine> outcome=reconfigureVmThroughJobQueue(vmUuid,oldServiceOffering,reconfiguringOnExistingHost);
    VirtualMachine vm=null;
    try {
      vm=outcome.get();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException("Operation is interrupted",e);
    }
catch (    java.util.concurrent.ExecutionException e) {
      throw new RuntimeException("Execution excetion",e);
    }
    Object jobResult=_jobMgr.unmarshallResultObject(outcome.getJob());
    if (jobResult != null) {
      if (jobResult instanceof ResourceUnavailableException)       throw (ResourceUnavailableException)jobResult;
 else       if (jobResult instanceof ConcurrentOperationException)       throw (ConcurrentOperationException)jobResult;
 else       if (jobResult instanceof InsufficientServerCapacityException)       throw (InsufficientServerCapacityException)jobResult;
 else       if (jobResult instanceof Throwable) {
        s_logger.error("Unhandled exception",(Throwable)jobResult);
        throw new RuntimeException("Unhandled exception",(Throwable)jobResult);
      }
    }
    return (VMInstanceVO)vm;
  }
}

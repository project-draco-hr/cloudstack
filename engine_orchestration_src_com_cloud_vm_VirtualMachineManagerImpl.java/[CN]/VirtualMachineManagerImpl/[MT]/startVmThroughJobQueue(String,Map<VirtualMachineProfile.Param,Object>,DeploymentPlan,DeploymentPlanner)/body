{
  final CallContext context=CallContext.current();
  final User callingUser=context.getCallingUser();
  final Account callingAccount=context.getCallingAccount();
  final VMInstanceVO vm=_vmDao.findByUuid(vmUuid);
  VmWorkJobVO workJob=null;
  List<VmWorkJobVO> pendingWorkJobs=_workJobDao.listPendingWorkJobs(VirtualMachine.Type.Instance,vm.getId(),VmWorkStart.class.getName());
  if (pendingWorkJobs.size() > 0) {
    assert(pendingWorkJobs.size() == 1);
    workJob=pendingWorkJobs.get(0);
  }
 else {
    workJob=new VmWorkJobVO(context.getContextId());
    workJob.setDispatcher(VmWorkConstants.VM_WORK_JOB_DISPATCHER);
    workJob.setCmd(VmWorkStart.class.getName());
    workJob.setAccountId(callingAccount.getId());
    workJob.setUserId(callingUser.getId());
    workJob.setStep(VmWorkJobVO.Step.Starting);
    workJob.setVmType(VirtualMachine.Type.Instance);
    workJob.setVmInstanceId(vm.getId());
    workJob.setRelated(AsyncJobExecutionContext.getOriginJobId());
    VmWorkStart workInfo=new VmWorkStart(callingUser.getId(),callingAccount.getId(),vm.getId(),VirtualMachineManagerImpl.VM_WORK_JOB_HANDLER);
    workInfo.setPlan(planToDeploy);
    workInfo.setParams(params);
    workJob.setCmdInfo(VmWorkSerializer.serialize(workInfo));
    _jobMgr.submitAsyncJob(workJob,VmWorkConstants.VM_WORK_QUEUE,vm.getId());
  }
  AsyncJobExecutionContext.getCurrentExecutionContext().joinJob(workJob.getId());
  return new VmStateSyncOutcome(workJob,VirtualMachine.PowerState.PowerOn,vm.getId(),null);
}

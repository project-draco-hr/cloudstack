{
  if (nicTo.getName() != null && !nicTo.getName().isEmpty()) {
    String[] tokens=nicTo.getName().split(",");
    if (tokens.length == 2 || tokens.length == 3) {
      String vlanToken=tokens[1];
      if (vlanToken.isEmpty()) {
        vlanToken=Vlan.UNTAGGED;
      }
      return new Pair<String,String>(tokens[0],vlanToken);
    }
 else {
      return new Pair<String,String>(nicTo.getName(),Vlan.UNTAGGED);
    }
  }
  if (nicTo.getType() == Networks.TrafficType.Guest) {
    return new Pair<String,String>(_guestTrafficInfo.getVirtualSwitchName(),Vlan.UNTAGGED);
  }
 else   if (nicTo.getType() == Networks.TrafficType.Control || nicTo.getType() == Networks.TrafficType.Management) {
    return new Pair<String,String>(_privateNetworkVSwitchName,Vlan.UNTAGGED);
  }
 else   if (nicTo.getType() == Networks.TrafficType.Public) {
    return new Pair<String,String>(_publicTrafficInfo.getVirtualSwitchName(),Vlan.UNTAGGED);
  }
 else   if (nicTo.getType() == Networks.TrafficType.Storage) {
    return new Pair<String,String>(_privateNetworkVSwitchName,Vlan.UNTAGGED);
  }
 else   if (nicTo.getType() == Networks.TrafficType.Vpn) {
    throw new Exception("Unsupported traffic type: " + nicTo.getType().toString());
  }
 else {
    throw new Exception("Unsupported traffic type: " + nicTo.getType().toString());
  }
}

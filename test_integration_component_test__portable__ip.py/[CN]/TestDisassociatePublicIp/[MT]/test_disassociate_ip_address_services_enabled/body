@attr(tags=['advanced'])
def test_disassociate_ip_address_services_enabled(self):
    ' Test disassociating portable ip\n        '
    portableip = PublicIPAddress.create(self.apiclient, accountid=self.account.name, zoneid=self.zone.id, domainid=self.account.domainid, networkid=self.network.id, isportable=True)
    self.debug(('created public ip address (portable): %s' % portableip.ipaddress.ipaddress))
    ipInCorrectState = is_public_ip_in_correct_state(self.apiclient, portableip.ipaddress.id, state='allocated')
    if (not ipInCorrectState):
        portableip.delete(self.apiclient)
        self.fail('Portable IP not in allocated state even after 10 mins')
    try:
        self.debug('Opening firewall on the portable public ip')
        FireWallRule.create(self.apiclient, ipaddressid=portableip.ipaddress.id, protocol=self.services['natrule']['protocol'], cidrlist=[self.services['natrule']['cidr']], startport=self.services['natrule']['publicport'], endport=self.services['natrule']['publicport'])
        self.debug('Creating NAT rule on the portable public ip')
        NATRule.create(self.apiclient, self.virtual_machine, self.services['natrule'], portableip.ipaddress.id)
    except Exception as e:
        portableip.delete(self.apiclient)
        self.fail(('Error: %s' % e))
    try:
        self.debug(('Disassociating portable ip: %s with id: %s' % (portableip.ipaddress.ipaddress, portableip.ipaddress.id)))
        portableip.delete(self.apiclient)
    except Exception as e:
        raise Exception(('Exception while disassociating portable ip: %s' % e))
    return

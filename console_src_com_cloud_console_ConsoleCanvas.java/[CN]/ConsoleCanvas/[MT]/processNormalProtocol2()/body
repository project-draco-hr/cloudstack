{
  byte[] bs=rfb.sis.getSplit();
  viewer.onPreProtocolProcess(bs);
  int msgType=rfb.readServerMessageType();
switch (msgType) {
case 250:
    int b=rfb.is.read();
  if (b == 1) {
    if (s_logger.isDebugEnabled())     s_logger.debug("S->C RFB msg VMOps DISCONNECT");
    viewer.onDisconnectMessage();
    break;
  }
 else   if (b == 2) {
    int n=rfb.is.readInt();
    if (s_logger.isDebugEnabled())     s_logger.debug("S->C RFB msg VMOps COMPRESSED");
    if (s_logger.isInfoEnabled())     s_logger.info("Reading compressed data size=" + n);
    byte[] buf=new byte[n];
    rfb.is.readFully(buf);
    ByteArrayInputStream bis=new ByteArrayInputStream(buf);
    DataInputStream oldis=rfb.is;
    rfb.is=new DataInputStream(new GZIPInputStream(bis,65536));
    try {
      processNormalProtocol2();
    }
  finally {
      rfb.is=oldis;
    }
    break;
  }
 else   if (b == 3) {
    if (s_logger.isDebugEnabled())     s_logger.debug("S->C RFB msg VMOps KEEP-ALIVE");
    rfb.writeClientCustomMessage(0);
    break;
  }
throw new Exception("Message type 250 comes with bad submessage type: " + b);
case RfbProto.FramebufferUpdate:
if (s_logger.isDebugEnabled()) s_logger.debug("S->C RFB FramebufferUpdate");
rfb.readFramebufferUpdate();
boolean cursorPosReceived=false;
boolean fullUpdateNeeded=false;
for (int i=0; i < rfb.updateNRects; i++) {
rfb.readFramebufferUpdateRectHdr();
int rx=rfb.updateRectX, ry=rfb.updateRectY;
int rw=rfb.updateRectW, rh=rfb.updateRectH;
if (rfb.updateRectEncoding == rfb.EncodingLastRect) {
if (s_logger.isInfoEnabled()) s_logger.info("Received EncodingLastRect packet in iteration " + i + " of "+ rfb.updateNRects);
break;
}
if (rfb.updateRectEncoding == rfb.EncodingNewFBSize) {
rfb.setFramebufferSize(rw,rh);
updateFramebufferSize();
if (s_logger.isInfoEnabled()) s_logger.info("Frame buffer size is changed to (" + rw + ", "+ rh+ "), packet in iteration "+ i+ " of "+ rfb.updateNRects);
break;
}
if (rfb.updateRectEncoding == rfb.EncodingXCursor || rfb.updateRectEncoding == rfb.EncodingRichCursor) {
byte[] cursorData=new byte[ConsoleCanvas.getCursorDataSize(rfb.updateRectEncoding,rw,rh)];
handleCursorShapeUpdate(rfb.updateRectEncoding,rx,ry,rw,rh,cursorData);
viewer.onFramebufferCursorShapeChange(rfb.updateRectEncoding,rx,ry,rw,rh,cursorData);
if (s_logger.isInfoEnabled()) s_logger.info("Received CursorShapeUpdate packet in iteration " + i + " of "+ rfb.updateNRects);
continue;
}
if (rfb.updateRectEncoding == rfb.EncodingPointerPos) {
softCursorMove(rx,ry);
cursorPosReceived=true;
viewer.onFramebufferCursorMove(rx,ry);
if (s_logger.isInfoEnabled()) s_logger.info("Received PointerPosUpdate packet in iteration " + i + " of "+ rfb.updateNRects);
continue;
}
rfb.startTiming();
switch (rfb.updateRectEncoding) {
case RfbProto.EncodingRaw:
handleRawRect(rx,ry,rw,rh);
break;
case RfbProto.EncodingCopyRect:
handleCopyRect(rx,ry,rw,rh);
break;
case RfbProto.EncodingRRE:
handleRRERect(rx,ry,rw,rh);
break;
case RfbProto.EncodingCoRRE:
handleCoRRERect(rx,ry,rw,rh);
break;
case RfbProto.EncodingHextile:
handleHextileRect(rx,ry,rw,rh);
break;
case RfbProto.EncodingZRLE:
handleZRLERect(rx,ry,rw,rh);
break;
case RfbProto.EncodingZlib:
handleZlibRect(rx,ry,rw,rh);
break;
case RfbProto.EncodingTight:
handleTightRect(rx,ry,rw,rh);
break;
default :
throw new Exception("Unknown RFB rectangle encoding " + rfb.updateRectEncoding);
}
viewer.onFramebufferUpdate(rx,ry,rw,rh);
rfb.stopTiming();
fullUpdateNeeded=viewer.onPostFrameBufferUpdateProcess(cursorPosReceived);
}
if (!viewer.isProxy()) {
if (s_logger.isDebugEnabled()) s_logger.debug("Send FrameBufferUpdateRequest in response of server update return");
rfb.writeFramebufferUpdateRequest(0,0,rfb.framebufferWidth,rfb.framebufferHeight,!fullUpdateNeeded);
}
 else {
if (!viewer.hasClientConnection()) {
if (s_logger.isDebugEnabled()) s_logger.debug("No client is connected, send FrameBufferUpdateRequest from proxy");
rfb.writeFramebufferUpdateRequest(0,0,rfb.framebufferWidth,rfb.framebufferHeight,!fullUpdateNeeded);
}
 else {
if (s_logger.isDebugEnabled()) s_logger.debug("Client is connected, let client to send FrameBufferUpdateRequest");
}
}
break;
case RfbProto.SetColourMapEntries:
if (s_logger.isDebugEnabled()) s_logger.debug("S->C RFB SetColourMapEntries");
throw new Exception("Can't handle SetColourMapEntries message");
case RfbProto.Bell:
if (s_logger.isDebugEnabled()) s_logger.debug("S->C RFB Bell");
viewer.onBellMessage();
break;
case RfbProto.ServerCutText:
if (s_logger.isDebugEnabled()) s_logger.debug("S->C RFB ServerCutText");
String s=rfb.readServerCutText();
break;
default :
if (s_logger.isDebugEnabled()) s_logger.debug("S->C RFB Unknown message type " + msgType);
throw new Exception("Unknown RFB message type " + msgType);
}
}

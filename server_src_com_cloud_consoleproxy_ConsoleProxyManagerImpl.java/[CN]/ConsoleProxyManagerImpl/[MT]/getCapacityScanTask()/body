{
  return new Runnable(){
    @Override public void run(){
      Transaction txn=Transaction.open(Transaction.CLOUD_DB);
      try {
        reallyRun();
      }
 catch (      Throwable e) {
        s_logger.warn("Unexpected exception " + e.getMessage(),e);
      }
 finally {
        StackMaid.current().exitCleanup();
        txn.close();
      }
    }
    private void reallyRun(){
      if (s_logger.isTraceEnabled()) {
        s_logger.trace("Begin console proxy capacity scan");
      }
      String restart=_configDao.getValue("consoleproxy.restart");
      if (restart != null && restart.equalsIgnoreCase("false")) {
        s_logger.debug("Capacity scan disabled purposefully, consoleproxy.restart = false. This happens when the primarystorage is in maintenance mode");
        return;
      }
      Map<Long,ZoneHostInfo> zoneHostInfoMap=getZoneHostInfo();
      if (isServiceReady(zoneHostInfoMap)) {
        if (s_logger.isTraceEnabled()) {
          s_logger.trace("Service is ready, check to see if we need to allocate standby capacity");
        }
        if (!_capacityScanLock.lock(ACQUIRE_GLOBAL_LOCK_TIMEOUT_FOR_COOPERATION)) {
          if (s_logger.isTraceEnabled()) {
            s_logger.trace("Capacity scan lock is used by others, skip and wait for my turn");
          }
          return;
        }
        if (s_logger.isTraceEnabled()) {
          s_logger.trace("*** Begining capacity scan... ***");
        }
        try {
          checkPendingProxyVMs();
          long defaultId=0;
          List<ConsoleProxyLoadInfo> l=_consoleProxyDao.getDatacenterProxyLoadMatrix();
          List<ConsoleProxyLoadInfo> listVmCounts=_consoleProxyDao.getDatacenterSessionLoadMatrix();
          Map<Long,ConsoleProxyLoadInfo> mapVmCounts=new HashMap<Long,ConsoleProxyLoadInfo>();
          if (listVmCounts != null) {
            for (            ConsoleProxyLoadInfo info : listVmCounts) {
              mapVmCounts.put(info.getId(),info);
            }
          }
          for (          ConsoleProxyLoadInfo info : l) {
            if (info.getName().equals(_instance)) {
              ConsoleProxyLoadInfo vmInfo=mapVmCounts.get(info.getId());
              if (!checkCapacity(info,vmInfo != null ? vmInfo : new ConsoleProxyLoadInfo())) {
                if (isZoneReady(zoneHostInfoMap,info.getId())) {
                  allocCapacity(info.getId());
                }
 else {
                  if (s_logger.isTraceEnabled()) {
                    s_logger.trace("Zone " + info.getId() + " is not ready to alloc standy console proxy");
                  }
                }
              }
              defaultId=info.getId();
              break;
            }
          }
          for (          ConsoleProxyLoadInfo info : l) {
            if (info.getId() != defaultId) {
              ConsoleProxyLoadInfo vmInfo=mapVmCounts.get(info.getId());
              if (!checkCapacity(info,vmInfo != null ? vmInfo : new ConsoleProxyLoadInfo())) {
                if (isZoneReady(zoneHostInfoMap,info.getId())) {
                  allocCapacity(info.getId());
                }
 else {
                  if (s_logger.isTraceEnabled()) {
                    s_logger.trace("Zone " + info.getId() + " is not ready to alloc standy console proxy");
                  }
                }
              }
            }
          }
          if (s_logger.isTraceEnabled()) {
            s_logger.trace("*** Stop capacity scan ***");
          }
        }
  finally {
          _capacityScanLock.unlock();
        }
      }
 else {
        if (s_logger.isTraceEnabled()) {
          s_logger.trace("Service is not ready for capacity preallocation, wait for next time");
        }
      }
      if (s_logger.isTraceEnabled()) {
        s_logger.trace("End of console proxy capacity scan");
      }
    }
  }
;
}

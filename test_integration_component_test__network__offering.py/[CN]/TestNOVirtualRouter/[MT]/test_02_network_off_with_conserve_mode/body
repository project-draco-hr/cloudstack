@attr(tags=['advanced'])
def test_02_network_off_with_conserve_mode(self):
    'Test Network offering with Conserve mode ON and VR - All services\n        '
    self.debug('Creating n/w offering with all services in VR & conserve mode:off')
    self.network_offering = NetworkOffering.create(self.api_client, self.services['network_offering'], conservemode=True)
    self.cleanup.append(self.network_offering)
    self.debug(('Created n/w offering with ID: %s' % self.network_offering.id))
    self.network_offering.update(self.apiclient, state='Enabled')
    self.debug(('Creating network with network offering: %s' % self.network_offering.id))
    self.network = Network.create(self.apiclient, self.services['network'], accountid=self.account.name, domainid=self.account.domainid, networkofferingid=self.network_offering.id, zoneid=self.zone.id)
    self.debug(('Created network with ID: %s' % self.network.id))
    self.debug(('Deploying VM in account: %s' % self.account.name))
    virtual_machine = VirtualMachine.create(self.apiclient, self.services['virtual_machine'], accountid=self.account.name, domainid=self.account.domainid, serviceofferingid=self.service_offering.id, networkids=[str(self.network.id)])
    self.debug(('Deployed VM in network: %s' % self.network.id))
    src_nat_list = PublicIPAddress.list(self.apiclient, associatednetworkid=self.network.id, account=self.account.name, domainid=self.account.domainid, listall=True, issourcenat=True)
    self.assertEqual(isinstance(src_nat_list, list), True, 'List Public IP should return a valid source NAT')
    self.assertNotEqual(len(src_nat_list), 0, 'Length of response from listPublicIp should not be 0')
    src_nat = src_nat_list[0]
    self.debug(('Trying to create LB rule on source NAT IP: %s' % src_nat.ipaddress))
    lb_rule = LoadBalancerRule.create(self.apiclient, self.services['lbrule'], ipaddressid=src_nat.id, accountid=self.account.name)
    self.debug(('Created LB rule on source NAT: %s' % src_nat.ipaddress))
    lb_rules = LoadBalancerRule.list(self.apiclient, id=lb_rule.id)
    self.assertEqual(isinstance(lb_rules, list), True, 'List lb rules should return a valid lb rules')
    self.assertNotEqual(len(lb_rules), 0, 'Length of response from listLbRules should not be 0')
    self.debug(('Trying to create a port forwarding rule in source NAT: %s' % src_nat.ipaddress))
    nat_rule = NATRule.create(self.apiclient, virtual_machine, self.services['natrule'], ipaddressid=src_nat.id)
    self.debug(('Created PF rule on source NAT: %s' % src_nat.ipaddress))
    nat_rules = NATRule.list(self.apiclient, id=nat_rule.id)
    self.assertEqual(isinstance(nat_rules, list), True, 'List NAT should return a valid port forwarding rules')
    self.assertNotEqual(len(nat_rules), 0, 'Length of response from listLbRules should not be 0')
    self.debug(('Creating firewall rule on source NAT: %s' % src_nat.ipaddress))
    fw_rule = FireWallRule.create(self.apiclient, ipaddressid=src_nat.id, protocol='TCP', cidrlist=[self.services['fw_rule']['cidr']], startport=self.services['fw_rule']['startport'], endport=self.services['fw_rule']['endport'])
    self.debug(('Created firewall rule: %s' % fw_rule.id))
    fw_rules = FireWallRule.list(self.apiclient, id=fw_rule.id)
    self.assertEqual(isinstance(fw_rules, list), True, 'List fw rules should return a valid firewall rules')
    self.assertNotEqual(len(fw_rules), 0, 'Length of fw rules response should not be zero')
    self.debug(('Associating public IP for network: %s' % self.network.id))
    public_ip = PublicIPAddress.create(self.apiclient, accountid=self.account.name, zoneid=self.zone.id, domainid=self.account.domainid, networkid=self.network.id)
    self.debug(('Associated %s with network %s' % (public_ip.ipaddress, self.network.id)))
    self.debug(('Creating PF rule for IP address: %s' % public_ip.ipaddress))
    NATRule.create(self.apiclient, virtual_machine, self.services['natrule'], ipaddressid=public_ip.ipaddress.id)
    self.debug(('Trying to create LB rule on IP with NAT: %s' % public_ip.ipaddress))
    lb_rule = LoadBalancerRule.create(self.apiclient, self.services['lbrule'], ipaddressid=public_ip.ipaddress.id, accountid=self.account.name)
    self.debug('Creating PF rule with public port: 66')
    nat_rule = NATRule.create(self.apiclient, virtual_machine, self.services['natrule_port_66'], ipaddressid=public_ip.ipaddress.id)
    nat_rules = NATRule.list(self.apiclient, id=nat_rule.id)
    self.assertEqual(isinstance(nat_rules, list), True, 'List NAT rules should return valid list')
    self.debug('Creating LB rule with public port: 2221')
    lb_rule = LoadBalancerRule.create(self.apiclient, self.services['lbrule_port_2221'], ipaddressid=public_ip.ipaddress.id, accountid=self.account.name)
    lb_rules = LoadBalancerRule.list(self.apiclient, id=lb_rule.id)
    self.assertEqual(isinstance(lb_rules, list), True, 'List LB rules should return valid list')
    self.debug(('Created VPN with source NAT IP: %s' % src_nat.ipaddress))
    vpn = Vpn.create(self.apiclient, src_nat.id, account=self.account.name, domainid=self.account.domainid)
    vpns = Vpn.list(self.apiclient, publicipid=src_nat.id, listall=True)
    self.assertEqual(isinstance(vpns, list), True, 'List VPNs should return a valid VPN list')
    self.assertNotEqual(len(vpns), 0, 'Length of list VPN response should not be zero')
    return

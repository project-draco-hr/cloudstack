@attr(speed='slow')
@attr(tags=['advancedns'])
def test_02_nwupgrade_netscaler_conserve_off(self):
    'Test Nw upgrade to netscaler lb service and conserve mode OFF\n        '
    self.debug(('Creating network with network offering: %s' % self.network_offering.id))
    self.network = Network.create(self.apiclient, self.services['network'], accountid=self.account.name, domainid=self.account.domainid, networkofferingid=self.network_offering.id, zoneid=self.zone.id)
    self.debug(('Created network with ID: %s' % self.network.id))
    self.debug(('Deploying VM in account: %s' % self.account.name))
    virtual_machine = VirtualMachine.create(self.apiclient, self.services['virtual_machine'], accountid=self.account.name, domainid=self.account.domainid, serviceofferingid=self.service_offering.id, networkids=[str(self.network.id)])
    self.debug(('Deployed VM in network: %s' % self.network.id))
    src_nat_list = PublicIPAddress.list(self.apiclient, associatednetworkid=self.network.id, account=self.account.name, domainid=self.account.domainid, listall=True, issourcenat=True)
    self.assertEqual(isinstance(src_nat_list, list), True, 'List Public IP should return a valid source NAT')
    self.assertNotEqual(len(src_nat_list), 0, 'Length of response from listPublicIp should not be 0')
    src_nat = src_nat_list[0]
    self.debug(('Trying to create LB rule on source NAT IP: %s' % src_nat.ipaddress))
    lb_rule = LoadBalancerRule.create(self.apiclient, self.services['lbrule'], ipaddressid=src_nat.id, accountid=self.account.name)
    self.debug(('Created LB rule on source NAT: %s' % src_nat.ipaddress))
    lb_rules = LoadBalancerRule.list(self.apiclient, id=lb_rule.id)
    self.assertEqual(isinstance(lb_rules, list), True, 'List lb rules should return a valid lb rules')
    self.assertNotEqual(len(lb_rules), 0, 'Length of response from listLbRules should not be 0')
    self.debug(('Trying to create a port forwarding rule in source NAT: %s' % src_nat.ipaddress))
    nat_rule = NATRule.create(self.apiclient, virtual_machine, self.services['natrule'], ipaddressid=src_nat.id)
    self.debug(('Created PF rule on source NAT: %s' % src_nat.ipaddress))
    nat_rules = NATRule.list(self.apiclient, id=nat_rule.id)
    self.assertEqual(isinstance(nat_rules, list), True, 'List NAT should return a valid port forwarding rules')
    self.assertNotEqual(len(nat_rules), 0, 'Length of response from listLbRules should not be 0')
    self.debug('Creating n/w offering with all services in VR & conserve mode:ON LB- Netscaler')
    ns_lb_offering = NetworkOffering.create(self.api_client, self.services['network_offering_netscaler'], conservemode=False)
    self.cleanup.append(ns_lb_offering)
    ns_lb_offering.update(self.apiclient, state='Enabled')
    self.debug(('Stopping the VM: %s' % virtual_machine.name))
    virtual_machine.stop(self.apiclient)
    self.debug(('Updating network offering for network: %s' % self.network.id))
    with self.assertRaises(Exception):
        self.network.update(self.apiclient, networkofferingid=ns_lb_offering.id, changecidr=True)
    self.debug('Network upgrade failed!')
    self.debug(('Deleting LB Rule: %s' % lb_rule.id))
    lb_rule.delete(self.apiclient)
    self.debug('LB rule deleted')
    self.debug('Enabling VPN on source NAT')
    vpn = Vpn.create(self.apiclient, src_nat.id, account=self.account.name, domainid=self.account.domainid)
    vpns = Vpn.list(self.apiclient, publicipid=src_nat.id, listall=True)
    self.assertEqual(isinstance(vpns, list), True, 'List VPNs should return a valid VPN list')
    self.assertNotEqual(len(vpns), 0, 'Length of list VPN response should not be zero')
    self.debug(('Upgrading the network: %s' % self.network.id))
    with self.assertRaises(Exception):
        self.network.update(self.apiclient, networkofferingid=ns_lb_offering.id, changecidr=True)
    return

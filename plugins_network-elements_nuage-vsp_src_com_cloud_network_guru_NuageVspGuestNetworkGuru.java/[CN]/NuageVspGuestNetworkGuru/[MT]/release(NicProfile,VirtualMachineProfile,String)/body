{
  long networkId=nic.getNetworkId();
  Network network=_networkDao.findById(networkId);
  logger.debug("Handling release() call back, which is called when a VM is stopped or destroyed, to delete the VM with state " + vm.getVirtualMachine().getState() + " from netork "+ network.getName());
  if (vm.getVirtualMachine().getState().equals(VirtualMachine.State.Stopping)) {
    try {
      HostVO nuageVspHost=getNuageVspHost(network.getPhysicalNetworkId());
      ReleaseVmVspCommand cmd=new ReleaseVmVspCommand(network.getUuid(),vm.getUuid(),vm.getInstanceName());
      ReleaseVmVspAnswer answer=(ReleaseVmVspAnswer)_agentMgr.easySend(nuageVspHost.getId(),cmd);
      if (answer == null || !answer.getResult()) {
        logger.error("ReleaseVmNuageVspCommand for VM " + vm.getUuid() + " failed");
        if ((null != answer) && (null != answer.getDetails())) {
          logger.error(answer.getDetails());
        }
      }
    }
 catch (    InsufficientVirtualNetworkCapacityException e) {
      logger.debug("Handling release() call back. Failed to delete CS VM " + vm.getInstanceName() + " in VSP. "+ e.getMessage());
    }
  }
 else {
    logger.debug("Handling release() call back. VM " + vm.getInstanceName() + " is in "+ vm.getVirtualMachine().getState()+ " state. So, the CS VM is not deleted."+ " This could be a case where VM interface is deleted. deallocate() call back should be called later");
  }
  return super.release(nic,vm,reservationId);
}

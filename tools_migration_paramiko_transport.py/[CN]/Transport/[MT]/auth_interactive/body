def auth_interactive(self, username, handler, submethods=''):
    "\n        Authenticate to the server interactively.  A handler is used to answer\n        arbitrary questions from the server.  On many servers, this is just a\n        dumb wrapper around PAM.\n\n        This method will block until the authentication succeeds or fails,\n        peroidically calling the handler asynchronously to get answers to\n        authentication questions.  The handler may be called more than once\n        if the server continues to ask questions.\n\n        The handler is expected to be a callable that will handle calls of the\n        form: C{handler(title, instructions, prompt_list)}.  The C{title} is\n        meant to be a dialog-window title, and the C{instructions} are user\n        instructions (both are strings).  C{prompt_list} will be a list of\n        prompts, each prompt being a tuple of C{(str, bool)}.  The string is\n        the prompt and the boolean indicates whether the user text should be\n        echoed.\n\n        A sample call would thus be:\n        C{handler('title', 'instructions', [('Password:', False)])}.\n\n        The handler should return a list or tuple of answers to the server's\n        questions.\n\n        If the server requires multi-step authentication (which is very rare),\n        this method will return a list of auth types permissible for the next\n        step.  Otherwise, in the normal case, an empty list is returned.\n\n        @param username: the username to authenticate as\n        @type username: string\n        @param handler: a handler for responding to server questions\n        @type handler: callable\n        @param submethods: a string list of desired submethods (optional)\n        @type submethods: str\n        @return: list of auth types permissible for the next stage of\n            authentication (normally empty).\n        @rtype: list\n\n        @raise BadAuthenticationType: if public-key authentication isn't\n            allowed by the server for this user\n        @raise AuthenticationException: if the authentication failed\n        @raise SSHException: if there was a network error\n\n        @since: 1.5\n        "
    if ((not self.active) or (not self.initial_kex_done)):
        raise SSHException('No existing session')
    my_event = threading.Event()
    self.auth_handler = AuthHandler(self)
    self.auth_handler.auth_interactive(username, handler, my_event, submethods)
    return self.auth_handler.wait_for_response(my_event)

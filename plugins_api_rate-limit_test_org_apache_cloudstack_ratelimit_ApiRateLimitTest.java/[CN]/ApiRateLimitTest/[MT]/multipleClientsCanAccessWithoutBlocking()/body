{
  int allowedRequests=200;
  s_limitService.setMaxAllowed(allowedRequests);
  s_limitService.setTimeToLive(1);
  final User key=createFakeUser();
  int clientCount=allowedRequests;
  Runnable[] clients=new Runnable[clientCount];
  final boolean[] isUsable=new boolean[clientCount];
  final CountDownLatch startGate=new CountDownLatch(1);
  final CountDownLatch endGate=new CountDownLatch(clientCount);
  for (int i=0; i < isUsable.length; ++i) {
    final int j=i;
    clients[j]=new Runnable(){
      /** 
 * {@inheritDoc}
 */
      @Override public void run(){
        try {
          startGate.await();
          isUsable[j]=isUnderLimit(key);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
 finally {
          endGate.countDown();
        }
      }
    }
;
  }
  ExecutorService executor=Executors.newFixedThreadPool(clientCount);
  for (  Runnable runnable : clients) {
    executor.execute(runnable);
  }
  startGate.countDown();
  endGate.await();
  for (  boolean b : isUsable) {
    assertTrue("Concurrent client request should be allowed within limit",b);
  }
}

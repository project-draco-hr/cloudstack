{
  HostVO host=_hostDao.findById(hostId);
  if (host == null) {
    if (s_logger.isDebugEnabled()) {
      s_logger.debug("Host: " + hostId + " does not even exist.  Delete call is ignored.");
    }
    return true;
  }
  AgentAttache attache=findAttache(hostId);
  List<StoragePoolHostVO> pools=_storagePoolHostDao.listByHostIdIncludingRemoved(hostId);
  try {
    if (host.getType() == Type.Routing) {
      Status currentState=host.getStatus();
      Status nextState=currentState.getNextStatus(Status.Event.Remove);
      if (nextState == null && !isForced) {
        s_logger.debug("There is no transition from state " + currentState.toString() + " to state "+ Status.Event.Remove.toString());
        return false;
      }
      if (s_logger.isDebugEnabled()) {
        s_logger.debug("Deleting Host: " + hostId + " Guid:"+ host.getGuid());
      }
      List<VMInstanceVO> vms=_vmDao.listByHostId(hostId);
      if (!vms.isEmpty()) {
        if (isForced) {
          for (          VMInstanceVO vm : vms) {
            if (!vm.isHaEnabled() || vm.getState() == State.Stopping) {
              s_logger.debug("Stopping vm: " + vm + " as a part of deleteHost id="+ hostId);
              if (!_vmMgr.advanceStop(vm,true,caller,_accountMgr.getAccount(vm.getAccountId()))) {
                String errorMsg="There was an error stopping the vm: " + vm + " as a part of hostDelete id="+ hostId;
                s_logger.warn(errorMsg);
                throw new CloudRuntimeException(errorMsg);
              }
            }
 else             if (vm.isHaEnabled() && (vm.getState() == State.Running || vm.getState() == State.Starting)) {
              s_logger.debug("Scheduling restart for vm: " + vm + " "+ vm.getState()+ " on the host id="+ hostId);
              _haMgr.scheduleRestart(vm,false);
            }
          }
        }
 else {
          throw new CloudRuntimeException("Unable to delete the host as there are vms in " + vms.get(0).getState() + " state using this host and isForced=false specified");
        }
      }
      if (host.getHypervisorType() == HypervisorType.XenServer) {
        if (host.getClusterId() != null) {
          List<HostVO> hosts=_hostDao.listBy(Type.Routing,host.getClusterId(),host.getPodId(),host.getDataCenterId());
          hosts.add(host);
          boolean success=true;
          for (          HostVO thost : hosts) {
            long thostId=thost.getId();
            PoolEjectCommand eject=new PoolEjectCommand(host.getGuid());
            Answer answer=easySend(thostId,eject);
            if (answer != null && answer.getResult()) {
              s_logger.debug("Eject Host: " + hostId + " from "+ thostId+ " Succeed");
              success=true;
              break;
            }
 else {
              success=false;
              s_logger.warn("Eject Host: " + hostId + " from "+ thostId+ " failed due to "+ (answer != null ? answer.getDetails() : "no answer"));
            }
          }
          if (!success) {
            String msg="Unable to eject host " + host.getGuid() + " due to there is no host up in this cluster, please execute xe pool-eject host-uuid="+ host.getGuid()+ "in this host "+ host.getPrivateIpAddress();
            s_logger.warn(msg);
            _alertMgr.sendAlert(AlertManager.ALERT_TYPE_HOST,host.getDataCenterId(),host.getPodId(),"Unable to eject host " + host.getGuid(),msg);
          }
        }
      }
 else       if (host.getHypervisorType() == HypervisorType.KVM) {
        try {
          ShutdownCommand cmd=new ShutdownCommand(ShutdownCommand.DeleteHost,null);
          send(host.getId(),cmd);
        }
 catch (        AgentUnavailableException e) {
          s_logger.warn("Sending ShutdownCommand failed: ",e);
        }
catch (        OperationTimedoutException e) {
          s_logger.warn("Sending ShutdownCommand failed: ",e);
        }
      }
 else       if (host.getHypervisorType() == HypervisorType.BareMetal) {
        List<VMInstanceVO> deadVms=_vmDao.listByLastHostId(hostId);
        for (        VMInstanceVO vm : deadVms) {
          if (vm.getState() == State.Running || vm.getHostId() != null) {
            throw new CloudRuntimeException("VM " + vm.getId() + "is still running on host "+ hostId);
          }
          _vmDao.remove(vm.getId());
        }
      }
    }
    Transaction txn=Transaction.currentTxn();
    txn.start();
    _dcDao.releasePrivateIpAddress(host.getPrivateIpAddress(),host.getDataCenterId(),null);
    if (attache != null) {
      handleDisconnect(attache,Status.Event.Remove,false);
    }
    _hostDetailsDao.deleteDetails(hostId);
    host.setGuid(null);
    Long clusterId=host.getClusterId();
    host.setClusterId(null);
    _hostDao.update(host.getId(),host);
    _hostDao.remove(hostId);
    if (clusterId != null) {
      List<HostVO> hosts=_hostDao.listByCluster(clusterId);
      if (hosts.size() == 0) {
        ClusterVO cluster=_clusterDao.findById(clusterId);
        cluster.setGuid(null);
        _clusterDao.update(clusterId,cluster);
      }
    }
    _storagePoolHostDao.deletePrimaryRecordsForHost(hostId);
    for (    StoragePoolHostVO pool : pools) {
      Long poolId=pool.getPoolId();
      StoragePoolVO storagePool=_storagePoolDao.findById(poolId);
      if (storagePool.isLocal()) {
        storagePool.setUuid(null);
        storagePool.setClusterId(null);
        _storagePoolDao.update(poolId,storagePool);
        _storagePoolDao.remove(poolId);
        s_logger.debug("Local storage id=" + poolId + " is removed as a part of host removal id="+ hostId);
      }
    }
    Object[] capacityTypes={Capacity.CAPACITY_TYPE_CPU,Capacity.CAPACITY_TYPE_MEMORY};
    SearchCriteria<CapacityVO> hostCapacitySC=_capacityDao.createSearchCriteria();
    hostCapacitySC.addAnd("hostOrPoolId",SearchCriteria.Op.EQ,hostId);
    hostCapacitySC.addAnd("capacityType",SearchCriteria.Op.IN,capacityTypes);
    _capacityDao.remove(hostCapacitySC);
    txn.commit();
    return true;
  }
 catch (  Throwable t) {
    s_logger.error("Unable to delete host: " + hostId,t);
    return false;
  }
}
